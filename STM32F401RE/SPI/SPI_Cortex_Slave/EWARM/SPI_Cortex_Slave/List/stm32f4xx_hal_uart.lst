###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
#    Command line =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\stm32f4xx_hal_uart.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\stm32f4xx_hal_uart.o
#
###############################################################################

C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @brief   UART HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions  
     11            *           + Peripheral State and Errors functions  
     12            *           
     13            @verbatim       
     14            ==============================================================================
     15                                  ##### How to use this driver #####
     16            ==============================================================================
     17            [..]
     18              The UART HAL driver can be used as follows:
     19              
     20              (#) Declare a UART_HandleTypeDef handle structure.
     21            
     22              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     23                  (##) Enable the USARTx interface clock.
     24                  (##) UART pins configuration:
     25                      (+++) Enable the clock for the UART GPIOs.
     26                      (+++) Configure these UART pins as alternate function pull-up.
     27                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     28                       and HAL_UART_Receive_IT() APIs):
     29                      (+++) Configure the USARTx interrupt priority.
     30                      (+++) Enable the NVIC USART IRQ handle.
     31                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     32                       and HAL_UART_Receive_DMA() APIs):
     33                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     34                      (+++) Enable the DMAx interface clock.
     35                      (+++) Configure the declared DMA handle structure with the required 
     36                            Tx/Rx parameters.                
     37                      (+++) Configure the DMA Tx/Rx Stream.
     38                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     39                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     40                            interrupt on the DMA Tx/Rx Stream.
     41          
     42              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     43                  flow control and Mode(Receiver/Transmitter) in the Init structure.
     44          
     45              (#) For the UART asynchronous mode, initialize the UART registers by calling
     46                  the HAL_UART_Init() API.
     47              
     48              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     49                  the HAL_HalfDuplex_Init() API.
     50              
     51              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     52              
     53              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     54                  the HAL_MultiProcessor_Init() API.
     55                  
     56               [..] 
     57                 (@) The specific UART interrupts (Transmission complete interrupt, 
     58                      RXNE interrupt and Error Interrupts) will be managed using the macros
     59                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     60                      and receive process.
     61                    
     62               [..] 
     63                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     64                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customized 
     65                      HAL_UART_MspInit() API.
     66                    
     67               [..] 
     68                  Three operation modes are available within this driver :     
     69            
     70               *** Polling mode IO operation ***
     71               =================================
     72               [..]    
     73                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     74                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     75                 
     76               *** Interrupt mode IO operation ***    
     77               ===================================
     78               [..]    
     79                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     80                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     81                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     82                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     83                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     84                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     85                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     86                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     87          
     88               *** DMA mode IO operation ***    
     89               ==============================
     90               [..] 
     91                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     92                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     93                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     94                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     95                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     96                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
     97                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
     98                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
     99                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    100                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    101                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    102                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    103                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()      
    104                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()  
    105                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()      
    106              
    107               *** UART HAL driver macros list ***
    108               ============================================= 
    109               [..]
    110                 Below the list of most used macros in UART HAL driver.
    111                 
    112                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    113                (+) __HAL_UART_DISABLE: Disable the UART peripheral     
    114                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    115                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    116                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    117                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    118                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    119                
    120               [..] 
    121                 (@) You can refer to the UART HAL driver header file for more useful macros 
    122                
    123            @endverbatim
    124            ******************************************************************************
    125            * @attention
    126            *
    127            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
    128            *
    129            * Redistribution and use in source and binary forms, with or without modification,
    130            * are permitted provided that the following conditions are met:
    131            *   1. Redistributions of source code must retain the above copyright notice,
    132            *      this list of conditions and the following disclaimer.
    133            *   2. Redistributions in binary form must reproduce the above copyright notice,
    134            *      this list of conditions and the following disclaimer in the documentation
    135            *      and/or other materials provided with the distribution.
    136            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    137            *      may be used to endorse or promote products derived from this software
    138            *      without specific prior written permission.
    139            *
    140            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    141            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    142            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    143            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    144            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    145            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    146            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    147            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    148            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    149            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    150            *
    151            ******************************************************************************
    152            */ 
    153          
    154          /* Includes ------------------------------------------------------------------*/
    155          #include "stm32f4xx_hal.h"
    156          
    157          /** @addtogroup STM32F4xx_HAL_Driver
    158            * @{
    159            */
    160          
    161          /** @defgroup UART UART
    162            * @brief HAL UART module driver
    163            * @{
    164            */
    165          #ifdef HAL_UART_MODULE_ENABLED
    166              
    167          /* Private typedef -----------------------------------------------------------*/
    168          /* Private define ------------------------------------------------------------*/
    169          /** @addtogroup UART_Private_Constants
    170            * @{
    171            */
    172          /**
    173            * @}
    174            */
    175          /* Private macro -------------------------------------------------------------*/
    176          /* Private variables ---------------------------------------------------------*/
    177          /* Private function prototypes -----------------------------------------------*/
    178          /** @addtogroup UART_Private_Functions   UART Private Functions
    179            * @{
    180            */
    181          static void UART_EndTxTransfer(UART_HandleTypeDef *huart);
    182          static void UART_EndRxTransfer(UART_HandleTypeDef *huart);
    183          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    184          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    185          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    186          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    187          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    188          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    189          static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    190          static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    191          static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
    192          static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
    193          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    194          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    195          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    196          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout);
    197          static void UART_SetConfig (UART_HandleTypeDef *huart);
    198          /**
    199            * @}
    200            */
    201          
    202          /* Exported functions ---------------------------------------------------------*/
    203          /** @defgroup UART_Exported_Functions UART Exported Functions
    204            * @{
    205            */
    206          
    207          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    208            *  @brief    Initialization and Configuration functions 
    209            *
    210          @verbatim    
    211          ===============================================================================
    212                      ##### Initialization and Configuration functions #####
    213           ===============================================================================  
    214              [..]
    215              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    216              in asynchronous mode.
    217                (+) For the asynchronous mode only these parameters can be configured: 
    218                  (++) Baud Rate
    219                  (++) Word Length 
    220                  (++) Stop Bit
    221                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    222                       in the data register is transmitted but is changed by the parity bit.
    223                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    224                       please refer to Reference manual for possible UART frame formats.           
    225                  (++) Hardware flow control
    226                  (++) Receiver/transmitter modes
    227                  (++) Over Sampling Method
    228              [..]
    229              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    230              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    231              configuration procedures (details for the procedures are available in reference manual (RM0329)).
    232          
    233          @endverbatim
    234            * @{
    235            */
    236          
    237          /**
    238            * @brief  Initializes the UART mode according to the specified parameters in
    239            *         the UART_InitTypeDef and create the associated handle.
    240            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    241            *                the configuration information for the specified UART module.
    242            * @retval HAL status
    243            */

   \                                 In section .text, align 2, keep-with-next
    244          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    245          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246            /* Check the UART handle allocation */
    247            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_UART_Init_0
    248            {
    249              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    250            }
    251          
    252            /* Check the parameters */
    253            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
    254            { 
    255              /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    256              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    257              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    258            }
    259            else
    260            {
    261              assert_param(IS_UART_INSTANCE(huart->Instance));
    262            }
    263            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    264            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    265            
    266            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0xB918             CBNZ.N   R0,??HAL_UART_Init_1
    267            {  
    268              /* Allocate lock resource and initialize it */
    269              huart->Lock = HAL_UNLOCKED;
   \   00000010   0x.... 0x....      BL       ?Subroutine7
    270              /* Init the low level hardware */
    271              HAL_UART_MspInit(huart);
    272            }
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000014   0x.... 0x....      BL       HAL_UART_MspInit
    273          
    274            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_1: (+1)
   \   00000018   0x.... 0x....      BL       ?Subroutine5
    275          
    276            /* Disable the peripheral */
    277            __HAL_UART_DISABLE(huart);
    278            
    279            /* Set the UART Communication parameters */
    280            UART_SetConfig(huart);
    281            
    282            /* In asynchronous mode, the following bits must be kept cleared: 
    283               - LINEN and CLKEN bits in the USART_CR2 register,
    284               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    285            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \                     ??CrossCallReturnLabel_3: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6901             LDR      R1,[R0, #+16]
   \   00000020   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   00000024   0x6101             STR      R1,[R0, #+16]
    286            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6941             LDR      R1,[R0, #+20]
   \   0000002A   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   0000002E   0x....             B.N      ?Subroutine0
    287            
    288            /* Enable the peripheral */
    289            __HAL_UART_ENABLE(huart);
    290            
    291            /* Initialize the UART state */
    292            huart->ErrorCode = HAL_UART_ERROR_NONE;
    293            huart->gState= HAL_UART_STATE_READY;
    294            huart->RxState= HAL_UART_STATE_READY;
    295            
    296            return HAL_OK;
    297          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6141             STR      R1,[R0, #+20]
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0x68C1             LDR      R1,[R0, #+12]
   \   00000006   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x63E0             STR      R0,[R4, #+60]
   \   00000010   0x2020             MOVS     R0,#+32
   \   00000012   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000016                      REQUIRE ??Subroutine14_0
   \   00000016                      ;; // Fall through to label ??Subroutine14_0

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine14_0: (+1)
   \   00000000   0xF884 0x003A      STRB     R0,[R4, #+58]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x2024             MOVS     R0,#+36
   \   00000002   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   \   0000000A   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      B.W      UART_SetConfig
    298          
    299          /**
    300            * @brief  Initializes the half-duplex mode according to the specified
    301            *         parameters in the UART_InitTypeDef and create the associated handle.
    302            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    303            *                the configuration information for the specified UART module.
    304            * @retval HAL status
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    307          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    308            /* Check the UART handle allocation */
    309            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    310            {
    311              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    312            }
    313           
    314            /* Check the parameters */ 
    315            assert_param(IS_UART_INSTANCE(huart->Instance));
    316            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    317            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    318          
    319            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000A   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000E   0xB918             CBNZ.N   R0,??HAL_HalfDuplex_Init_1
    320            { 
    321              /* Allocate lock resource and initialize it */
    322              huart->Lock = HAL_UNLOCKED;
   \   00000010   0x.... 0x....      BL       ?Subroutine7
    323              /* Init the low level hardware */
    324              HAL_UART_MspInit(huart);
    325            }
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000014   0x.... 0x....      BL       HAL_UART_MspInit
    326          
    327            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000018   0x.... 0x....      BL       ?Subroutine5
    328          
    329            /* Disable the peripheral */
    330            __HAL_UART_DISABLE(huart);
    331            
    332            /* Set the UART Communication parameters */
    333            UART_SetConfig(huart);
    334            
    335            /* In half-duplex mode, the following bits must be kept cleared: 
    336               - LINEN and CLKEN bits in the USART_CR2 register,
    337               - SCEN and IREN bits in the USART_CR3 register.*/
    338            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6901             LDR      R1,[R0, #+16]
   \   00000020   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   00000024   0x6101             STR      R1,[R0, #+16]
    339            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6941             LDR      R1,[R0, #+20]
   \   0000002A   0xF021 0x0122      BIC      R1,R1,#0x22
   \   0000002E   0x6141             STR      R1,[R0, #+20]
    340            
    341            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    342            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6941             LDR      R1,[R0, #+20]
   \   00000034   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000038                      REQUIRE ?Subroutine0
   \   00000038                      ;; // Fall through to label ?Subroutine0
    343           
    344            /* Enable the peripheral */
    345            __HAL_UART_ENABLE(huart);
    346            
    347            /* Initialize the UART state*/
    348            huart->ErrorCode = HAL_UART_ERROR_NONE;
    349            huart->gState= HAL_UART_STATE_READY;
    350            huart->RxState= HAL_UART_STATE_READY;
    351            
    352            return HAL_OK;
    353          }
    354          
    355          /**
    356            * @brief  Initializes the LIN mode according to the specified
    357            *         parameters in the UART_InitTypeDef and create the associated handle.
    358            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    359            *                the configuration information for the specified UART module.
    360            * @param  BreakDetectLength Specifies the LIN break detection length.
    361            *         This parameter can be one of the following values:
    362            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    363            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    364            * @retval HAL status
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    367          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460D             MOV      R5,R1
    368            /* Check the UART handle allocation */
    369            if(huart == NULL)
   \   00000006   0xD101             BNE.N    ??HAL_LIN_Init_0
    370            {
    371              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xBD32             POP      {R1,R4,R5,PC}
    372            }
    373             
    374            /* Check the parameters */
    375            assert_param(IS_UART_INSTANCE(huart->Instance));
    376            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    377            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    378            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    379            
    380            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0xB918             CBNZ.N   R0,??HAL_LIN_Init_1
    381            {
    382              /* Allocate lock resource and initialize it */
    383              huart->Lock = HAL_UNLOCKED;
   \   00000012   0x.... 0x....      BL       ?Subroutine7
    384              /* Init the low level hardware */
    385              HAL_UART_MspInit(huart);
    386            }
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000016   0x.... 0x....      BL       HAL_UART_MspInit
    387          
    388            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_1: (+1)
   \   0000001A   0x.... 0x....      BL       ?Subroutine5
    389          
    390            /* Disable the peripheral */
    391            __HAL_UART_DISABLE(huart);
    392            
    393            /* Set the UART Communication parameters */
    394            UART_SetConfig(huart);
    395            
    396            /* In LIN mode, the following bits must be kept cleared: 
    397               - LINEN and CLKEN bits in the USART_CR2 register,
    398               - SCEN and IREN bits in the USART_CR3 register.*/
    399            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6901             LDR      R1,[R0, #+16]
   \   00000022   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000026   0x6101             STR      R1,[R0, #+16]
    400            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x6941             LDR      R1,[R0, #+20]
   \   0000002C   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000030   0x6141             STR      R1,[R0, #+20]
    401            
    402            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    403            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6901             LDR      R1,[R0, #+16]
   \   00000036   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000003A   0x6101             STR      R1,[R0, #+16]
    404            
    405            /* Set the USART LIN Break detection length. */
    406            CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6901             LDR      R1,[R0, #+16]
   \   00000040   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000044   0x6101             STR      R1,[R0, #+16]
    407            SET_BIT(huart->Instance->CR2, BreakDetectLength);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6901             LDR      R1,[R0, #+16]
   \   0000004A   0x4329             ORRS     R1,R5,R1
   \   0000004C   0x6101             STR      R1,[R0, #+16]
    408            
    409            /* Enable the peripheral */
    410            __HAL_UART_ENABLE(huart);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x68C1             LDR      R1,[R0, #+12]
   \   00000052   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000056   0x60C1             STR      R1,[R0, #+12]
    411            
    412            /* Initialize the UART state*/
    413            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x63E0             STR      R0,[R4, #+60]
    414            huart->gState= HAL_UART_STATE_READY;
   \   0000005C   0x2020             MOVS     R0,#+32
   \   0000005E   0xF884 0x0039      STRB     R0,[R4, #+57]
    415            huart->RxState= HAL_UART_STATE_READY;
   \   00000062   0xF884 0x003A      STRB     R0,[R4, #+58]
    416            
    417            return HAL_OK;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    418          }
    419          
    420          /**
    421            * @brief  Initializes the Multi-Processor mode according to the specified
    422            *         parameters in the UART_InitTypeDef and create the associated handle.
    423            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    424            *                the configuration information for the specified UART module.
    425            * @param  Address USART address
    426            * @param  WakeUpMethod specifies the USART wake-up method.
    427            *          This parameter can be one of the following values:
    428            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wake-up by an idle line detection
    429            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wake-up by an address mark
    430            * @retval HAL status
    431            */

   \                                 In section .text, align 2, keep-with-next
    432          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    433          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    434            /* Check the UART handle allocation */
    435            if(huart == NULL)
   \   00000008   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    436            {
    437              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD70             POP      {R4-R6,PC}
    438            }
    439          
    440            /* Check the parameters */
    441            assert_param(IS_UART_INSTANCE(huart->Instance));
    442            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    443            assert_param(IS_UART_ADDRESS(Address));
    444            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    445            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    446          
    447            if(huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0xB918             CBNZ.N   R0,??HAL_MultiProcessor_Init_1
    448            {
    449              /* Allocate lock resource and initialize it */
    450              huart->Lock = HAL_UNLOCKED;
   \   00000014   0x.... 0x....      BL       ?Subroutine7
    451              /* Init the low level hardware */
    452              HAL_UART_MspInit(huart);
    453            }
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000018   0x.... 0x....      BL       HAL_UART_MspInit
    454          
    455            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   0000001C   0x.... 0x....      BL       ?Subroutine5
    456          
    457            /* Disable the peripheral */
    458            __HAL_UART_DISABLE(huart);
    459            
    460            /* Set the UART Communication parameters */
    461            UART_SetConfig(huart);
    462            
    463            /* In Multi-Processor mode, the following bits must be kept cleared: 
    464               - LINEN and CLKEN bits in the USART_CR2 register,
    465               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    466            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6901             LDR      R1,[R0, #+16]
   \   00000024   0xF421 0x4190      BIC      R1,R1,#0x4800
   \   00000028   0x6101             STR      R1,[R0, #+16]
    467            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x6941             LDR      R1,[R0, #+20]
   \   0000002E   0xF021 0x012A      BIC      R1,R1,#0x2A
   \   00000032   0x6141             STR      R1,[R0, #+20]
    468            
    469            /* Clear the USART address */
    470            CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0x0909             LSRS     R1,R1,#+4
   \   0000003A   0x0109             LSLS     R1,R1,#+4
   \   0000003C   0x6101             STR      R1,[R0, #+16]
    471            /* Set the USART address node */
    472            SET_BIT(huart->Instance->CR2, Address);
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6901             LDR      R1,[R0, #+16]
   \   00000042   0x4331             ORRS     R1,R6,R1
   \   00000044   0x6101             STR      R1,[R0, #+16]
    473            
    474            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    475            CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x68C1             LDR      R1,[R0, #+12]
   \   0000004A   0xF421 0x6100      BIC      R1,R1,#0x800
   \   0000004E   0x60C1             STR      R1,[R0, #+12]
    476            SET_BIT(huart->Instance->CR1, WakeUpMethod);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x68C1             LDR      R1,[R0, #+12]
   \   00000054   0x4329             ORRS     R1,R5,R1
   \   00000056   0x60C1             STR      R1,[R0, #+12]
    477            
    478            /* Enable the peripheral */
    479            __HAL_UART_ENABLE(huart);
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x68C1             LDR      R1,[R0, #+12]
   \   0000005C   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000060   0x60C1             STR      R1,[R0, #+12]
    480            
    481            /* Initialize the UART state */
    482            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x63E0             STR      R0,[R4, #+60]
    483            huart->gState= HAL_UART_STATE_READY;
   \   00000066   0x2020             MOVS     R0,#+32
   \   00000068   0xF884 0x0039      STRB     R0,[R4, #+57]
    484            huart->RxState= HAL_UART_STATE_READY;
   \   0000006C   0xF884 0x003A      STRB     R0,[R4, #+58]
    485            
    486            return HAL_OK;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    487          }
    488          
    489          /**
    490            * @brief  DeInitializes the UART peripheral. 
    491            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    492            *                the configuration information for the specified UART module.
    493            * @retval HAL status
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    496          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    497            /* Check the UART handle allocation */
    498            if(huart == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_UART_DeInit_0
    499            {
    500              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}
    501            }
    502            
    503            /* Check the parameters */
    504            assert_param(IS_UART_INSTANCE(huart->Instance));
    505          
    506            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000A   0xF104 0x0538      ADD      R5,R4,#+56
   \   0000000E   0x2024             MOVS     R0,#+36
   \   00000010   0x7068             STRB     R0,[R5, #+1]
    507            
    508            /* DeInit the low level hardware */
    509            HAL_UART_MspDeInit(huart);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       HAL_UART_MspDeInit
    510            
    511            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6068             STR      R0,[R5, #+4]
    512            huart->gState = HAL_UART_STATE_RESET;
   \   0000001C   0x7068             STRB     R0,[R5, #+1]
    513            huart->RxState = HAL_UART_STATE_RESET;
   \   0000001E   0x70A8             STRB     R0,[R5, #+2]
    514          
    515            /* Process Lock */
    516            __HAL_UNLOCK(huart);
   \   00000020   0xF884 0x0038      STRB     R0,[R4, #+56]
    517          
    518            return HAL_OK;
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    519          }
    520          
    521          /**
    522            * @brief  UART MSP Init.
    523            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    524            *                the configuration information for the specified UART module.
    525            * @retval None
    526            */

   \                                 In section .text, align 2, keep-with-next
    527           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    528          {
    529             /* Prevent unused argument(s) compilation warning */
    530            UNUSED(huart);
    531            /* NOTE: This function Should not be modified, when the callback is needed,
    532                     the HAL_UART_MspInit could be implemented in the user file
    533             */ 
    534          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    535          
    536          /**
    537            * @brief  UART MSP DeInit.
    538            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    539            *                the configuration information for the specified UART module.
    540            * @retval None
    541            */

   \                                 In section .text, align 2, keep-with-next
    542           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    543          {
    544            /* Prevent unused argument(s) compilation warning */
    545            UNUSED(huart);
    546            /* NOTE: This function Should not be modified, when the callback is needed,
    547                     the HAL_UART_MspDeInit could be implemented in the user file
    548             */ 
    549          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    550          
    551          /**
    552            * @}
    553            */
    554          
    555          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    556            *  @brief UART Transmit and Receive functions 
    557            *
    558          @verbatim   
    559            ==============================================================================
    560                                ##### IO operation functions #####
    561            ==============================================================================  
    562            [..]
    563              This subsection provides a set of functions allowing to manage the UART asynchronous
    564              and Half duplex data transfers.
    565          
    566              (#) There are two modes of transfer:
    567                 (++) Blocking mode: The communication is performed in polling mode. 
    568                      The HAL status of all data processing is returned by the same function 
    569                      after finishing transfer.  
    570                 (++) Non blocking mode: The communication is performed using Interrupts 
    571                      or DMA, these APIs return the HAL status.
    572                      The end of the data processing will be indicated through the 
    573                      dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    574                      using DMA mode.
    575                      The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    576                      will be executed respectively at the end of the transmit or receive process.
    577                      The HAL_UART_ErrorCallback() user callback will be executed when 
    578                      a communication error is detected.
    579          
    580              (#) Blocking mode APIs are:
    581                  (++) HAL_UART_Transmit()
    582                  (++) HAL_UART_Receive() 
    583                  
    584              (#) Non Blocking mode APIs with Interrupt are:
    585                  (++) HAL_UART_Transmit_IT()
    586                  (++) HAL_UART_Receive_IT()
    587                  (++) HAL_UART_IRQHandler()
    588          
    589              (#) Non Blocking mode functions with DMA are:
    590                  (++) HAL_UART_Transmit_DMA()
    591                  (++) HAL_UART_Receive_DMA()
    592          
    593              (#) A set of Transfer Complete Callbacks are provided in non blocking mode:
    594                  (++) HAL_UART_TxCpltCallback()
    595                  (++) HAL_UART_RxCpltCallback()
    596                  (++) HAL_UART_ErrorCallback()
    597          
    598              [..] 
    599                (@) In the Half duplex communication, it is forbidden to run the transmit 
    600                    and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX 
    601                    can't be useful.
    602                
    603          @endverbatim
    604            * @{
    605            */
    606          
    607          /**
    608            * @brief  Sends an amount of data in blocking mode. 
    609            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    610            *                the configuration information for the specified UART module.
    611            * @param  pData Pointer to data buffer
    612            * @param  Size Amount of data to be sent
    613            * @param  Timeout Timeout duration  
    614            * @retval HAL status
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    617          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    618            uint16_t* tmp;
    619            uint32_t tickstart = 0U;
    620            
    621            /* Check that a Tx process is not already ongoing */
    622            if(huart->gState == HAL_UART_STATE_READY) 
   \   00000008   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000C   0x460D             MOV      R5,R1
   \   0000000E   0x4616             MOV      R6,R2
   \   00000010   0x461F             MOV      R7,R3
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xD145             BNE.N    ??HAL_UART_Transmit_0
    623            {
    624              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xBF14             ITE      NE 
   \   0000001A   0x2E00             CMPNE    R6,#+0
    625              {
    626                return  HAL_ERROR;
   \   0000001C   0x2001             MOVEQ    R0,#+1
   \   0000001E   0xD041             BEQ.N    ??HAL_UART_Transmit_1
    627              }
    628              
    629              /* Process Locked */
    630              __HAL_LOCK(huart);
   \   00000020   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD03C             BEQ.N    ??HAL_UART_Transmit_0
   \   00000028   0x.... 0x....      BL       ?Subroutine8
    631              
    632              huart->ErrorCode = HAL_UART_ERROR_NONE;
    633              huart->gState = HAL_UART_STATE_BUSY_TX;
   \                     ??CrossCallReturnLabel_13: (+1)
   \   0000002C   0x2021             MOVS     R0,#+33
   \   0000002E   0xF884 0x0039      STRB     R0,[R4, #+57]
    634          	
    635              /* Init tickstart for timeout managment */
    636              tickstart = HAL_GetTick();
   \   00000032   0x.... 0x....      BL       HAL_GetTick
    637          
    638              huart->TxXferSize = Size;
   \   00000036   0x84A6             STRH     R6,[R4, #+36]
   \   00000038   0x4680             MOV      R8,R0
    639              huart->TxXferCount = Size;
   \   0000003A   0x84E6             STRH     R6,[R4, #+38]
   \   0000003C   0xE003             B.N      ??HAL_UART_Transmit_2
    640              while(huart->TxXferCount > 0U)
    641              {
    642                huart->TxXferCount--;
    643                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    644                {
    645                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
    646                  { 
    647                    return HAL_TIMEOUT;
    648                  }
    649                  tmp = (uint16_t*) pData;
    650                  huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
    651                  if(huart->Init.Parity == UART_PARITY_NONE)
    652                  {
    653                    pData +=2U;
    654                  }
    655                  else
    656                  { 
    657                    pData +=1U;
    658                  }
    659                } 
    660                else
    661                {
    662                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
    663                  {
    664                    return HAL_TIMEOUT;
    665                  }
    666                  huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
   \                     ??HAL_UART_Transmit_3: (+1)
   \   0000003E   0x6821             LDR      R1,[R4, #+0]
   \   00000040   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   00000044   0x6048             STR      R0,[R1, #+4]
   \                     ??HAL_UART_Transmit_2: (+1)
   \   00000046   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000048   0xB1D8             CBZ.N    R0,??HAL_UART_Transmit_4
   \   0000004A   0x4643             MOV      R3,R8
   \   0000004C   0x8CE0             LDRH     R0,[R4, #+38]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x84E0             STRH     R0,[R4, #+38]
   \   00000052   0x68A0             LDR      R0,[R4, #+8]
   \   00000054   0x9700             STR      R7,[SP, #+0]
   \   00000056   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000005A   0xD10D             BNE.N    ??HAL_UART_Transmit_5
   \   0000005C   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000060   0xB9B0             CBNZ.N   R0,??HAL_UART_Transmit_6
   \   00000062   0x8828             LDRH     R0,[R5, #+0]
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x05C0             LSLS     R0,R0,#+23
   \   00000068   0x0DC0             LSRS     R0,R0,#+23
   \   0000006A   0x6048             STR      R0,[R1, #+4]
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xBF14             ITE      NE 
   \   00000072   0x1C6D             ADDNE    R5,R5,#+1
   \   00000074   0x1CAD             ADDEQ    R5,R5,#+2
   \   00000076   0xE7E6             B.N      ??HAL_UART_Transmit_2
   \                     ??HAL_UART_Transmit_5: (+1)
   \   00000078   0x.... 0x....      BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_7: (+1)
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD0DE             BEQ.N    ??HAL_UART_Transmit_3
   \   00000080   0xE006             B.N      ??HAL_UART_Transmit_6
    667                } 
    668              }
    669              
    670              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_4: (+1)
   \   00000082   0x9700             STR      R7,[SP, #+0]
   \   00000084   0x4643             MOV      R3,R8
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x2140             MOVS     R1,#+64
   \   0000008A   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \   0000008E   0xB108             CBZ.N    R0,??HAL_UART_Transmit_7
    671              { 
    672                return HAL_TIMEOUT;
   \                     ??HAL_UART_Transmit_6: (+1)
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0xE007             B.N      ??HAL_UART_Transmit_1
    673              }
    674              
    675              /* At end of Tx process, restore huart->gState to Ready */
    676                huart->gState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_7: (+1)
   \   00000094   0x2020             MOVS     R0,#+32
   \   00000096   0xF884 0x0039      STRB     R0,[R4, #+57]
    677              
    678              /* Process Unlocked */
    679              __HAL_UNLOCK(huart);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF884 0x0038      STRB     R0,[R4, #+56]
    680              
    681              return HAL_OK;
   \   000000A0   0xE000             B.N      ??HAL_UART_Transmit_1
    682            }
    683            else
    684            {
    685              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_0: (+1)
   \   000000A2   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_1: (+1)
   \   000000A4   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    686            }
    687          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF884 0x0038      STRB     R0,[R4, #+56]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x63E0             STR      R0,[R4, #+60]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x2180             MOVS     R1,#+128
   \                     ??Subroutine6_0: (+1)
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      B.W      UART_WaitOnFlagUntilTimeout
    688          
    689          /**
    690            * @brief  Receives an amount of data in blocking mode. 
    691            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    692            *                the configuration information for the specified UART module.
    693            * @param  pData Pointer to data buffer
    694            * @param  Size Amount of data to be received
    695            * @param  Timeout Timeout duration
    696            * @retval HAL status
    697            */

   \                                 In section .text, align 2, keep-with-next
    698          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    699          { 
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    700            uint16_t* tmp;
    701            uint32_t tickstart = 0U;
    702            
    703            /* Check that a Rx process is not already ongoing */
    704            if(huart->RxState == HAL_UART_STATE_READY) 
   \   00000008   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \   0000000C   0x460D             MOV      R5,R1
   \   0000000E   0x4616             MOV      R6,R2
   \   00000010   0x461F             MOV      R7,R3
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xD149             BNE.N    ??HAL_UART_Receive_0
    705            { 
    706              if((pData == NULL ) || (Size == 0)) 
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xBF14             ITE      NE 
   \   0000001A   0x2E00             CMPNE    R6,#+0
    707              {
    708                return  HAL_ERROR;
   \   0000001C   0x2001             MOVEQ    R0,#+1
   \   0000001E   0xD045             BEQ.N    ??HAL_UART_Receive_1
    709              }
    710              
    711              /* Process Locked */
    712              __HAL_LOCK(huart);
   \   00000020   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD040             BEQ.N    ??HAL_UART_Receive_0
   \   00000028   0x.... 0x....      BL       ?Subroutine8
    713              
    714              huart->ErrorCode = HAL_UART_ERROR_NONE;
    715              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000002C   0x2022             MOVS     R0,#+34
   \   0000002E   0xF884 0x003A      STRB     R0,[R4, #+58]
    716          	
    717              /* Init tickstart for timeout managment */
    718              tickstart = HAL_GetTick();
   \   00000032   0x.... 0x....      BL       HAL_GetTick
    719                  
    720              huart->RxXferSize = Size; 
   \   00000036   0x85A6             STRH     R6,[R4, #+44]
   \   00000038   0x4680             MOV      R8,R0
    721              huart->RxXferCount = Size;
   \   0000003A   0x85E6             STRH     R6,[R4, #+46]
   \   0000003C   0xE003             B.N      ??HAL_UART_Receive_2
    722              
    723              /* Check the remain data to be received */
    724              while(huart->RxXferCount > 0U)
    725              {
    726                huart->RxXferCount--;
    727                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    728                {
    729                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
    730                  { 
    731                    return HAL_TIMEOUT;
    732                  }
    733                  tmp = (uint16_t*) pData;
    734                  if(huart->Init.Parity == UART_PARITY_NONE)
    735                  {
    736                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \                     ??HAL_UART_Receive_3: (+1)
   \   0000003E   0x05C0             LSLS     R0,R0,#+23
   \   00000040   0x0DC0             LSRS     R0,R0,#+23
   \   00000042   0xF825 0x0B02      STRH     R0,[R5], #+2
    737                    pData +=2U;
    738                  }
   \                     ??HAL_UART_Receive_2: (+1)
   \   00000046   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000048   0xB340             CBZ.N    R0,??HAL_UART_Receive_4
   \   0000004A   0x4643             MOV      R3,R8
   \   0000004C   0x8DE0             LDRH     R0,[R4, #+46]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x85E0             STRH     R0,[R4, #+46]
   \   00000052   0x68A0             LDR      R0,[R4, #+8]
   \   00000054   0x9700             STR      R7,[SP, #+0]
   \   00000056   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000005A   0xD10D             BNE.N    ??HAL_UART_Receive_5
   \   0000005C   0x2200             MOVS     R2,#+0
   \   0000005E   0x2120             MOVS     R1,#+32
   \   00000060   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000064   0xB968             CBNZ.N   R0,??HAL_UART_Receive_6
   \   00000066   0x6920             LDR      R0,[R4, #+16]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x6840             LDR      R0,[R0, #+4]
   \   0000006E   0xD0E6             BEQ.N    ??HAL_UART_Receive_3
    739                  else
    740                  {
    741                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0xF825 0x0B01      STRH     R0,[R5], #+1
    742                    pData +=1U;
   \   00000076   0xE7E6             B.N      ??HAL_UART_Receive_2
    743                  }
    744          
    745                } 
    746                else
    747                {
    748                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_5: (+1)
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x2120             MOVS     R1,#+32
   \   0000007C   0x.... 0x....      BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_4: (+1)
   \   00000080   0xB108             CBZ.N    R0,??HAL_UART_Receive_7
    749                  { 
    750                    return HAL_TIMEOUT;
   \                     ??HAL_UART_Receive_6: (+1)
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0xE012             B.N      ??HAL_UART_Receive_1
    751                  }
    752                  if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_7: (+1)
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6840             LDR      R0,[R0, #+4]
   \   0000008E   0xD102             BNE.N    ??HAL_UART_Receive_8
    753                  {
    754                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \                     ??HAL_UART_Receive_9: (+1)
   \   00000090   0xF805 0x0B01      STRB     R0,[R5], #+1
   \   00000094   0xE7D7             B.N      ??HAL_UART_Receive_2
    755                  }
    756                  else
    757                  {
    758                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_UART_Receive_8: (+1)
   \   00000096   0xF000 0x007F      AND      R0,R0,#0x7F
   \   0000009A   0xE7F9             B.N      ??HAL_UART_Receive_9
    759                  }
    760                  
    761                }
    762              }
    763              
    764              /* At end of Rx process, restore huart->RxState to Ready */
    765              huart->RxState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_4: (+1)
   \   0000009C   0x2020             MOVS     R0,#+32
   \   0000009E   0xF884 0x003A      STRB     R0,[R4, #+58]
    766              
    767              /* Process Unlocked */
    768              __HAL_UNLOCK(huart);
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF884 0x0038      STRB     R0,[R4, #+56]
    769              
    770              return HAL_OK;
   \   000000A8   0xE000             B.N      ??HAL_UART_Receive_1
    771            }
    772            else
    773            {
    774              return HAL_BUSY;   
   \                     ??HAL_UART_Receive_0: (+1)
   \   000000AA   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_1: (+1)
   \   000000AC   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    775            }
    776          }
    777          
    778          /**
    779            * @brief  Sends an amount of data in non blocking mode.
    780            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    781            *                the configuration information for the specified UART module.
    782            * @param  pData Pointer to data buffer
    783            * @param  Size Amount of data to be sent
    784            * @retval HAL status
    785            */

   \                                 In section .text, align 2, keep-with-next
    786          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    787          {
    788            /* Check that a Tx process is not already ongoing */
    789            if(huart->gState == HAL_UART_STATE_READY)
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xF890 0x3039      LDRB     R3,[R0, #+57]
   \   00000004   0x2B20             CMP      R3,#+32
   \   00000006   0xD11C             BNE.N    ??HAL_UART_Transmit_IT_0
    790            {
    791              if((pData == NULL ) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_UART_Transmit_IT_1
    792              {
    793                return HAL_ERROR;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
    794              }
    795              
    796              /* Process Locked */
    797              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   00000014   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD012             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3038      STRB     R3,[R0, #+56]
    798              
    799              huart->pTxBuffPtr = pData;
   \   00000022   0x6201             STR      R1,[R0, #+32]
    800              huart->TxXferSize = Size;
   \   00000024   0x8482             STRH     R2,[R0, #+36]
    801              huart->TxXferCount = Size;
   \   00000026   0x84C2             STRH     R2,[R0, #+38]
    802          
    803              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x63C1             STR      R1,[R0, #+60]
    804              huart->gState = HAL_UART_STATE_BUSY_TX;
   \   0000002C   0x2121             MOVS     R1,#+33
   \   0000002E   0xF880 0x1039      STRB     R1,[R0, #+57]
    805          
    806              /* Process Unlocked */
    807              __HAL_UNLOCK(huart);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xF880 0x1038      STRB     R1,[R0, #+56]
    808          
    809              /* Enable the UART Transmit data register empty Interrupt */
    810              SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x68C1             LDR      R1,[R0, #+12]
   \   0000003C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000040   0x....             B.N      ?Subroutine3
    811              
    812              return HAL_OK;
    813            }
    814            else
    815            {
    816              return HAL_BUSY;   
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x4770             BX       LR               ;; return
    817            }
    818          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR
    819          
    820          /**
    821            * @brief  Receives an amount of data in non blocking mode 
    822            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    823            *                the configuration information for the specified UART module.
    824            * @param  pData Pointer to data buffer
    825            * @param  Size Amount of data to be received
    826            * @retval HAL status
    827            */

   \                                 In section .text, align 2, keep-with-next
    828          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    829          {
    830            /* Check that a Rx process is not already ongoing */ 
    831            if(huart->RxState == HAL_UART_STATE_READY)
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xF890 0x303A      LDRB     R3,[R0, #+58]
   \   00000004   0x2B20             CMP      R3,#+32
   \   00000006   0xD121             BNE.N    ??HAL_UART_Receive_IT_0
    832            {
    833              if((pData == NULL ) || (Size == 0)) 
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2A00             CMPNE    R2,#+0
   \   0000000E   0xD101             BNE.N    ??HAL_UART_Receive_IT_1
    834              {
    835                return HAL_ERROR;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
    836              }
    837              
    838              /* Process Locked */
    839              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   00000014   0xF890 0x3038      LDRB     R3,[R0, #+56]
   \   00000018   0x2B01             CMP      R3,#+1
   \   0000001A   0xD017             BEQ.N    ??HAL_UART_Receive_IT_0
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0xF880 0x3038      STRB     R3,[R0, #+56]
    840              
    841              huart->pRxBuffPtr = pData;
   \   00000022   0x6281             STR      R1,[R0, #+40]
    842              huart->RxXferSize = Size;
   \   00000024   0x8582             STRH     R2,[R0, #+44]
    843              huart->RxXferCount = Size;
   \   00000026   0x85C2             STRH     R2,[R0, #+46]
    844              
    845              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x63C1             STR      R1,[R0, #+60]
    846              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \   0000002C   0x2122             MOVS     R1,#+34
   \   0000002E   0xF880 0x103A      STRB     R1,[R0, #+58]
    847              
    848              /* Process Unlocked */
    849              __HAL_UNLOCK(huart);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xF880 0x1038      STRB     R1,[R0, #+56]
    850                  
    851              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    852              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x694A             LDR      R2,[R1, #+20]
   \   0000003C   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000040   0x614A             STR      R2,[R1, #+20]
    853          
    854              /* Enable the UART Parity Error and Data Register not empty Interrupts */
    855              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x68C1             LDR      R1,[R0, #+12]
   \   00000046   0xF441 0x7190      ORR      R1,R1,#0x120
   \   0000004A   0x....             B.N      ?Subroutine3
    856              
    857              return HAL_OK;
    858            }
    859            else
    860            {
    861              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x4770             BX       LR               ;; return
    862            }
    863          }
    864          
    865          /**
    866            * @brief  Sends an amount of data in non blocking mode. 
    867            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    868            *                the configuration information for the specified UART module.
    869            * @param  pData Pointer to data buffer
    870            * @param  Size Amount of data to be sent
    871            * @retval HAL status
    872            */

   \                                 In section .text, align 2, keep-with-next
    873          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    874          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    875            uint32_t *tmp;
    876            
    877            /* Check that a Tx process is not already ongoing */
    878            if(huart->gState == HAL_UART_STATE_READY)
   \   00000004   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD137             BNE.N    ??HAL_UART_Transmit_DMA_0
    879            {
    880              if((pData == NULL ) || (Size == 0))
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2A00             CMPNE    R2,#+0
   \   00000012   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_1
    881              {
    882                return HAL_ERROR;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xBD10             POP      {R4,PC}
    883              }
    884          
    885              /* Process Locked */
    886              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   00000018   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD02D             BEQ.N    ??HAL_UART_Transmit_DMA_0
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x0038      STRB     R0,[R4, #+56]
    887          
    888              huart->pTxBuffPtr = pData;
   \   00000026   0x6221             STR      R1,[R4, #+32]
    889              huart->TxXferSize = Size;
   \   00000028   0x84A2             STRH     R2,[R4, #+36]
    890              huart->TxXferCount = Size;
   \   0000002A   0x84E2             STRH     R2,[R4, #+38]
    891          
    892              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x63E0             STR      R0,[R4, #+60]
    893              huart->gState = HAL_UART_STATE_BUSY_TX;
   \   00000030   0x2021             MOVS     R0,#+33
   \   00000032   0xF884 0x0039      STRB     R0,[R4, #+57]
    894          
    895              /* Set the UART DMA transfer complete callback */
    896              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \   00000036   0x6B23             LDR      R3,[R4, #+48]
   \   00000038   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    897          
    898              /* Set the UART DMA Half transfer complete callback */
    899              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   0000003E   0x6B23             LDR      R3,[R4, #+48]
   \   00000040   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   00000044   0x6418             STR      R0,[R3, #+64]
    900          
    901              /* Set the DMA error callback */
    902              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   00000046   0x6B23             LDR      R3,[R4, #+48]
   \   00000048   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000004C   0x64D8             STR      R0,[R3, #+76]
    903          
    904              /* Set the DMA abort callback */
    905              huart->hdmatx->XferAbortCallback = NULL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6B23             LDR      R3,[R4, #+48]
   \   00000052   0x6518             STR      R0,[R3, #+80]
    906          
    907              /* Enable the UART transmit DMA Stream */
    908              tmp = (uint32_t*)&pData;
    909              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
   \   00000054   0x4613             MOV      R3,R2
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x1D02             ADDS     R2,R0,#+4
   \   0000005A   0x6B20             LDR      R0,[R4, #+48]
   \   0000005C   0x.... 0x....      BL       HAL_DMA_Start_IT
    910              
    911              /* Clear the TC flag in the SR register by writing 0 to it */
    912              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0xF06F 0x0040      MVN      R0,#+64
   \   00000066   0x6008             STR      R0,[R1, #+0]
    913              
    914              /* Process Unlocked */
    915              __HAL_UNLOCK(huart);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF884 0x0038      STRB     R0,[R4, #+56]
    916              
    917              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    918                 in the UART CR3 register */
    919              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x6941             LDR      R1,[R0, #+20]
   \   00000072   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000076   0x6141             STR      R1,[R0, #+20]
    920              
    921              return HAL_OK;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBD10             POP      {R4,PC}
    922            }
    923            else
    924            {
    925              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   0000007C   0x2002             MOVS     R0,#+2
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
    926            }
    927          }
    928          
    929          /**
    930            * @brief  Receives an amount of data in non blocking mode. 
    931            * @param  huart pointer to a UART_HandleTypeDef structure that contains
    932            *                the configuration information for the specified UART module.
    933            * @param  pData Pointer to data buffer
    934            * @param  Size Amount of data to be received
    935            * @note   When the UART parity is enabled (PCE = 1) the data received contain the parity bit.
    936            * @retval HAL status
    937            */

   \                                 In section .text, align 2, keep-with-next
    938          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    939          {  
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xB082             SUB      SP,SP,#+8
    940            uint32_t *tmp;
    941            
    942            /* Check that a Rx process is not already ongoing */
    943            if(huart->RxState == HAL_UART_STATE_READY) 
   \   00000006   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \   0000000A   0x2820             CMP      R0,#+32
   \   0000000C   0xD144             BNE.N    ??HAL_UART_Receive_DMA_0
    944            {
    945              if((pData == NULL ) || (Size == 0)) 
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2A00             CMPNE    R2,#+0
   \   00000014   0xD101             BNE.N    ??HAL_UART_Receive_DMA_1
    946              {
    947                return HAL_ERROR;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD16             POP      {R1,R2,R4,PC}
    948              }
    949              
    950              /* Process Locked */
    951              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   0000001A   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD03A             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF884 0x0038      STRB     R0,[R4, #+56]
    952              
    953              huart->pRxBuffPtr = pData;
   \   00000028   0x62A1             STR      R1,[R4, #+40]
    954              huart->RxXferSize = Size;
   \   0000002A   0x85A2             STRH     R2,[R4, #+44]
    955              
    956              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x63E0             STR      R0,[R4, #+60]
    957              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \   00000030   0x2022             MOVS     R0,#+34
   \   00000032   0xF884 0x003A      STRB     R0,[R4, #+58]
    958                  
    959              /* Set the UART DMA transfer complete callback */
    960              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \   00000036   0x6B63             LDR      R3,[R4, #+52]
   \   00000038   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    961              
    962              /* Set the UART DMA Half transfer complete callback */
    963              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   0000003E   0x6B63             LDR      R3,[R4, #+52]
   \   00000040   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000044   0x6418             STR      R0,[R3, #+64]
    964              
    965              /* Set the DMA error callback */
    966              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   00000046   0x6B63             LDR      R3,[R4, #+52]
   \   00000048   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000004C   0x64D8             STR      R0,[R3, #+76]
    967              
    968              /* Set the DMA abort callback */
    969              huart->hdmarx->XferAbortCallback = NULL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6B63             LDR      R3,[R4, #+52]
   \   00000052   0x6518             STR      R0,[R3, #+80]
    970          
    971              /* Enable the DMA Stream */
    972              tmp = (uint32_t*)&pData;
    973              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
   \   00000054   0x4613             MOV      R3,R2
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x460A             MOV      R2,R1
   \   0000005A   0x1D01             ADDS     R1,R0,#+4
   \   0000005C   0x6B60             LDR      R0,[R4, #+52]
   \   0000005E   0x.... 0x....      BL       HAL_DMA_Start_IT
    974          
    975              /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
    976              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x9100             STR      R1,[SP, #+0]
   \   0000006C   0x6841             LDR      R1,[R0, #+4]
   \   0000006E   0x9100             STR      R1,[SP, #+0]
   \   00000070   0x9900             LDR      R1,[SP, #+0]
    977          
    978              /* Process Unlocked */
    979              __HAL_UNLOCK(huart);
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xF884 0x1038      STRB     R1,[R4, #+56]
    980          
    981              /* Enable the UART Parity Error Interrupt */
    982              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   00000078   0x68C1             LDR      R1,[R0, #+12]
   \   0000007A   0xF441 0x7180      ORR      R1,R1,#0x100
   \   0000007E   0x60C1             STR      R1,[R0, #+12]
    983          
    984              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    985              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6941             LDR      R1,[R0, #+20]
   \   00000084   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000088   0x6141             STR      R1,[R0, #+20]
    986              
    987              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
    988              in the UART CR3 register */
    989              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x6941             LDR      R1,[R0, #+20]
   \   0000008E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000092   0x6141             STR      R1,[R0, #+20]
    990          
    991              return HAL_OK;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xBD16             POP      {R1,R2,R4,PC}
    992            }
    993            else
    994            {
    995              return HAL_BUSY; 
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    996            }
    997          }
    998              
    999          /**
   1000            * @brief Pauses the DMA Transfer.
   1001            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1002            *                the configuration information for the specified UART module.
   1003            * @retval HAL status
   1004            */

   \                                 In section .text, align 2, keep-with-next
   1005          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1006          {
   1007             uint32_t dmarequest = 0x00U;
   1008          
   1009            /* Process Locked */
   1010            __HAL_LOCK(huart);
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1011            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x694A             LDR      R2,[R1, #+20]
   1012            if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \   00000016   0xF890 0x3039      LDRB     R3,[R0, #+57]
   \   0000001A   0x2B21             CMP      R3,#+33
   \   0000001C   0xD105             BNE.N    ??HAL_UART_DMAPause_1
   \   0000001E   0x0612             LSLS     R2,R2,#+24
   \   00000020   0xD503             BPL.N    ??HAL_UART_DMAPause_1
   1013            {
   1014              /* Disable the UART DMA Tx request */
   1015              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000022   0x694A             LDR      R2,[R1, #+20]
   \   00000024   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000028   0x614A             STR      R2,[R1, #+20]
   1016            }
   1017            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x694A             LDR      R2,[R1, #+20]
   1018            if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \   0000002E   0xF890 0x303A      LDRB     R3,[R0, #+58]
   \   00000032   0x2B22             CMP      R3,#+34
   \   00000034   0xD10F             BNE.N    ??HAL_UART_DMAPause_2
   \   00000036   0x0652             LSLS     R2,R2,#+25
   \   00000038   0xD50D             BPL.N    ??HAL_UART_DMAPause_2
   1019            {
   1020              /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1021              CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   0000003A   0x68CA             LDR      R2,[R1, #+12]
   \   0000003C   0xF422 0x7280      BIC      R2,R2,#0x100
   \   00000040   0x60CA             STR      R2,[R1, #+12]
   1022              CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x694A             LDR      R2,[R1, #+20]
   \   00000046   0x0852             LSRS     R2,R2,#+1
   \   00000048   0x0052             LSLS     R2,R2,#+1
   \   0000004A   0x614A             STR      R2,[R1, #+20]
   1023              
   1024              /* Disable the UART DMA Rx request */
   1025              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   0000004C   0x6801             LDR      R1,[R0, #+0]
   \   0000004E   0x694A             LDR      R2,[R1, #+20]
   \   00000050   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000054   0x614A             STR      R2,[R1, #+20]
   1026            }
   1027            
   1028            /* Process Unlocked */
   1029            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   00000056   0x....             B.N      ??Subroutine15_0
   1030            
   1031            return HAL_OK; 
   1032          }

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine15_0: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x1038      STRB     R1,[R0, #+56]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4770             BX       LR               ;; return
   1033          
   1034          /**
   1035            * @brief Resumes the DMA Transfer.
   1036            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1037            *                the configuration information for the specified UART module.
   1038            * @retval HAL status
   1039            */

   \                                 In section .text, align 2, keep-with-next
   1040          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1041          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   1042            /* Process Locked */
   1043            __HAL_LOCK(huart);
   \   00000002   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xBF08             IT       EQ 
   \   0000000A   0x2002             MOVEQ    R0,#+2
   \   0000000C   0xD029             BEQ.N    ??HAL_UART_DMAResume_0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF880 0x1038      STRB     R1,[R0, #+56]
   1044            
   1045            if(huart->gState == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF890 0x1039      LDRB     R1,[R0, #+57]
   \   00000018   0x2921             CMP      R1,#+33
   \   0000001A   0xD104             BNE.N    ??HAL_UART_DMAResume_1
   1046            {
   1047              /* Enable the UART DMA Tx request */
   1048              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0x694A             LDR      R2,[R1, #+20]
   \   00000020   0xF042 0x0280      ORR      R2,R2,#0x80
   \   00000024   0x614A             STR      R2,[R1, #+20]
   1049            }
   1050            if(huart->RxState == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000026   0xF890 0x103A      LDRB     R1,[R0, #+58]
   \   0000002A   0x2922             CMP      R1,#+34
   \   0000002C   0xD115             BNE.N    ??HAL_UART_DMAResume_2
   1051            {
   1052              /* Clear the Overrun flag before resuming the Rx transfer*/
   1053              __HAL_UART_CLEAR_OREFLAG(huart);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x9100             STR      R1,[SP, #+0]
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x680A             LDR      R2,[R1, #+0]
   \   00000036   0x9200             STR      R2,[SP, #+0]
   \   00000038   0x684A             LDR      R2,[R1, #+4]
   \   0000003A   0x9200             STR      R2,[SP, #+0]
   \   0000003C   0x9A00             LDR      R2,[SP, #+0]
   1054              
   1055              /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
   1056              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   0000003E   0x68CA             LDR      R2,[R1, #+12]
   \   00000040   0xF442 0x7280      ORR      R2,R2,#0x100
   \   00000044   0x60CA             STR      R2,[R1, #+12]
   1057              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   00000046   0x6801             LDR      R1,[R0, #+0]
   \   00000048   0x694A             LDR      R2,[R1, #+20]
   \   0000004A   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000004E   0x614A             STR      R2,[R1, #+20]
   1058              
   1059              /* Enable the UART DMA Rx request */
   1060              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x694A             LDR      R2,[R1, #+20]
   \   00000054   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000058   0x614A             STR      R2,[R1, #+20]
   1061            }
   1062            
   1063            /* Process Unlocked */
   1064            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xF880 0x1038      STRB     R1,[R0, #+56]
   1065            
   1066            return HAL_OK;
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   00000062   0xB001             ADD      SP,SP,#+4
   \   00000064   0x4770             BX       LR               ;; return
   1067          }
   1068          
   1069          /**
   1070            * @brief Stops the DMA Transfer.
   1071            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1072            *                the configuration information for the specified UART module.
   1073            * @retval HAL status
   1074            */

   \                                 In section .text, align 2, keep-with-next
   1075          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1076          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1077            uint32_t dmarequest = 0x00U;
   1078            /* The Lock is not implemented on this API to allow the user application
   1079               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1080               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1081               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1082               */
   1083            
   1084            /* Stop UART DMA Tx request if ongoing */
   1085            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6941             LDR      R1,[R0, #+20]
   1086            if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \   00000008   0xF894 0x2039      LDRB     R2,[R4, #+57]
   \   0000000C   0x2A21             CMP      R2,#+33
   \   0000000E   0xD109             BNE.N    ??HAL_UART_DMAStop_0
   \   00000010   0x0609             LSLS     R1,R1,#+24
   \   00000012   0xD507             BPL.N    ??HAL_UART_DMAStop_0
   1087            {
   1088              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000014   0x.... 0x....      BL       ?Subroutine12
   1089          
   1090              /* Abort the UART DMA Tx channel */
   1091              if(huart->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_22: (+1)
   \   00000018   0xB108             CBZ.N    R0,??HAL_UART_DMAStop_1
   1092              {
   1093                HAL_DMA_Abort(huart->hdmatx);
   \   0000001A   0x.... 0x....      BL       HAL_DMA_Abort
   1094              }
   1095              UART_EndTxTransfer(huart);
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       UART_EndTxTransfer
   1096            }
   1097          
   1098            /* Stop UART DMA Rx request if ongoing */
   1099            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6941             LDR      R1,[R0, #+20]
   1100            if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \   00000028   0xF894 0x203A      LDRB     R2,[R4, #+58]
   \   0000002C   0x2A22             CMP      R2,#+34
   \   0000002E   0xD109             BNE.N    ??HAL_UART_DMAStop_2
   \   00000030   0x0649             LSLS     R1,R1,#+25
   \   00000032   0xD507             BPL.N    ??HAL_UART_DMAStop_2
   1101            {
   1102              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000034   0x.... 0x....      BL       ?Subroutine9
   1103          
   1104              /* Abort the UART DMA Rx channel */
   1105              if(huart->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000038   0xB108             CBZ.N    R0,??HAL_UART_DMAStop_3
   1106              {
   1107                HAL_DMA_Abort(huart->hdmarx);
   \   0000003A   0x.... 0x....      BL       HAL_DMA_Abort
   1108              }
   1109              UART_EndRxTransfer(huart);
   \                     ??HAL_UART_DMAStop_3: (+1)
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       UART_EndRxTransfer
   1110            }
   1111          
   1112            return HAL_OK;
   \                     ??HAL_UART_DMAStop_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   1113          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x6941             LDR      R1,[R0, #+20]
   \   00000002   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000006   0x6141             STR      R1,[R0, #+20]
   \   00000008   0x6B20             LDR      R0,[R4, #+48]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x6941             LDR      R1,[R0, #+20]
   \   00000002   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000006   0x6141             STR      R1,[R0, #+20]
   \   00000008   0x6B60             LDR      R0,[R4, #+52]
   \   0000000A   0x4770             BX       LR
   1114          
   1115          /**
   1116            * @brief  Abort ongoing transfers (blocking mode).
   1117            * @param  huart UART handle.
   1118            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. 
   1119            *         This procedure performs following operations :
   1120            *           - Disable PPP Interrupts
   1121            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1122            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1123            *           - Set handle State to READY
   1124            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1125            * @retval HAL status
   1126          */

   \                                 In section .text, align 2, keep-with-next
   1127          HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
   1128          {
   \                     HAL_UART_Abort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1129            /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1130            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF421 0x71F0      BIC      R1,R1,#0x1E0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1131            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x0849             LSRS     R1,R1,#+1
   \   00000014   0x0049             LSLS     R1,R1,#+1
   \   00000016   0x6141             STR      R1,[R0, #+20]
   1132            
   1133            /* Disable the UART DMA Tx request if enabled */
   1134            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6941             LDR      R1,[R0, #+20]
   \   0000001C   0x0609             LSLS     R1,R1,#+24
   \   0000001E   0xD507             BPL.N    ??CrossCallReturnLabel_19
   1135            {
   1136              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000020   0x6941             LDR      R1,[R0, #+20]
   \   00000022   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000026   0x6141             STR      R1,[R0, #+20]
   1137          
   1138              /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
   1139              if(huart->hdmatx != NULL)
   \   00000028   0x6B20             LDR      R0,[R4, #+48]
   \   0000002A   0xB108             CBZ.N    R0,??CrossCallReturnLabel_19
   1140              {
   1141                /* Set the UART DMA Abort callback to Null. 
   1142                   No call back execution at end of DMA abort procedure */
   1143                huart->hdmatx->XferAbortCallback = NULL;
   \   0000002C   0x.... 0x....      BL       ?Subroutine10
   1144          
   1145                HAL_DMA_Abort(huart->hdmatx);
   1146              }
   1147            }
   1148          
   1149            /* Disable the UART DMA Rx request if enabled */
   1150            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x6941             LDR      R1,[R0, #+20]
   \   00000034   0x0649             LSLS     R1,R1,#+25
   \   00000036   0xD507             BPL.N    ??CrossCallReturnLabel_21
   1151            {
   1152              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000038   0x6941             LDR      R1,[R0, #+20]
   \   0000003A   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000003E   0x6141             STR      R1,[R0, #+20]
   1153          
   1154              /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
   1155              if(huart->hdmarx != NULL)
   \   00000040   0x6B60             LDR      R0,[R4, #+52]
   \   00000042   0xB108             CBZ.N    R0,??CrossCallReturnLabel_21
   1156              {
   1157                /* Set the UART DMA Abort callback to Null. 
   1158                   No call back execution at end of DMA abort procedure */
   1159                huart->hdmarx->XferAbortCallback = NULL;
   \   00000044   0x.... 0x....      BL       ?Subroutine11
   1160          
   1161                HAL_DMA_Abort(huart->hdmarx);
   1162              }
   1163            }
   1164          
   1165            /* Reset Tx and Rx transfer counters */
   1166            huart->TxXferCount = 0x00U;
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x84E0             STRH     R0,[R4, #+38]
   1167            huart->RxXferCount = 0x00U;
   \   0000004C   0x85E0             STRH     R0,[R4, #+46]
   1168          
   1169            /* Reset ErrorCode */
   1170            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000004E   0x63E0             STR      R0,[R4, #+60]
   1171          
   1172            /* Restore huart->RxState and huart->gState to Ready */
   1173            huart->RxState = HAL_UART_STATE_READY;
   \   00000050   0x2020             MOVS     R0,#+32
   \   00000052   0xF884 0x003A      STRB     R0,[R4, #+58]
   1174            huart->gState = HAL_UART_STATE_READY;
   \   00000056   0x....             B.N      ?Subroutine1
   1175          
   1176            return HAL_OK;
   1177          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6501             STR      R1,[R0, #+80]
   \   00000004   0x6B20             LDR      R0,[R4, #+48]
   \   00000006   0x.... 0x....      B.W      HAL_DMA_Abort

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6501             STR      R1,[R0, #+80]
   \   00000004   0x6B60             LDR      R0,[R4, #+52]
   \   00000006   0x.... 0x....      B.W      HAL_DMA_Abort
   1178          
   1179          /**
   1180            * @brief  Abort ongoing Transmit transfer (blocking mode).
   1181            * @param  huart UART handle.
   1182            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. 
   1183            *         This procedure performs following operations :
   1184            *           - Disable PPP Interrupts
   1185            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1186            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1187            *           - Set handle State to READY
   1188            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1189            * @retval HAL status
   1190          */

   \                                 In section .text, align 2, keep-with-next
   1191          HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
   1192          {
   \                     HAL_UART_AbortTransmit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1193            /* Disable TXEIE and TCIE interrupts */
   1194            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF021 0x01C0      BIC      R1,R1,#0xC0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1195          
   1196            /* Disable the UART DMA Tx request if enabled */
   1197            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xD507             BPL.N    ??CrossCallReturnLabel_18
   1198            {
   1199              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000016   0x6941             LDR      R1,[R0, #+20]
   \   00000018   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000001C   0x6141             STR      R1,[R0, #+20]
   1200          
   1201              /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
   1202              if(huart->hdmatx != NULL)
   \   0000001E   0x6B20             LDR      R0,[R4, #+48]
   \   00000020   0xB108             CBZ.N    R0,??CrossCallReturnLabel_18
   1203              {
   1204                /* Set the UART DMA Abort callback to Null. 
   1205                   No call back execution at end of DMA abort procedure */
   1206                huart->hdmatx->XferAbortCallback = NULL;
   \   00000022   0x.... 0x....      BL       ?Subroutine10
   1207          
   1208                HAL_DMA_Abort(huart->hdmatx);
   1209              }
   1210            }
   1211          
   1212            /* Reset Tx transfer counter */
   1213            huart->TxXferCount = 0x00U;
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x84E0             STRH     R0,[R4, #+38]
   1214          
   1215            /* Restore huart->gState to Ready */
   1216            huart->gState = HAL_UART_STATE_READY;
   \   0000002A   0x2020             MOVS     R0,#+32
   \   0000002C                      REQUIRE ?Subroutine1
   \   0000002C                      ;; // Fall through to label ?Subroutine1
   1217          
   1218            return HAL_OK;
   1219          }
   1220          
   1221          /**
   1222            * @brief  Abort ongoing Receive transfer (blocking mode).
   1223            * @param  huart UART handle.
   1224            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. 
   1225            *         This procedure performs following operations :
   1226            *           - Disable PPP Interrupts
   1227            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1228            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1229            *           - Set handle State to READY
   1230            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1231            * @retval HAL status
   1232          */

   \                                 In section .text, align 2, keep-with-next
   1233          HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
   1234          {
   \                     HAL_UART_AbortReceive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1235            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1236            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF421 0x7190      BIC      R1,R1,#0x120
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1237            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x0849             LSRS     R1,R1,#+1
   \   00000014   0x0049             LSLS     R1,R1,#+1
   \   00000016   0x6141             STR      R1,[R0, #+20]
   1238          
   1239            /* Disable the UART DMA Rx request if enabled */
   1240            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6941             LDR      R1,[R0, #+20]
   \   0000001C   0x0649             LSLS     R1,R1,#+25
   \   0000001E   0xD507             BPL.N    ??CrossCallReturnLabel_20
   1241            {
   1242              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000020   0x6941             LDR      R1,[R0, #+20]
   \   00000022   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000026   0x6141             STR      R1,[R0, #+20]
   1243          
   1244              /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
   1245              if(huart->hdmarx != NULL)
   \   00000028   0x6B60             LDR      R0,[R4, #+52]
   \   0000002A   0xB108             CBZ.N    R0,??CrossCallReturnLabel_20
   1246              {
   1247                /* Set the UART DMA Abort callback to Null. 
   1248                   No call back execution at end of DMA abort procedure */
   1249                huart->hdmarx->XferAbortCallback = NULL;
   \   0000002C   0x.... 0x....      BL       ?Subroutine11
   1250          
   1251                HAL_DMA_Abort(huart->hdmarx);
   1252              }
   1253            }
   1254          
   1255            /* Reset Rx transfer counter */
   1256            huart->RxXferCount = 0x00U;
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x85E0             STRH     R0,[R4, #+46]
   1257          
   1258            /* Restore huart->RxState to Ready */
   1259            huart->RxState = HAL_UART_STATE_READY;
   \   00000034   0x2020             MOVS     R0,#+32
   \   00000036   0x....             B.N      ??Subroutine14_0
   1260          
   1261            return HAL_OK;
   1262          }
   1263          
   1264          /**
   1265            * @brief  Abort ongoing transfers (Interrupt mode).
   1266            * @param  huart UART handle.
   1267            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. 
   1268            *         This procedure performs following operations :
   1269            *           - Disable PPP Interrupts
   1270            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1271            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1272            *           - Set handle State to READY
   1273            *           - At abort completion, call user abort complete callback
   1274            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1275            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1276            * @retval HAL status
   1277          */

   \                                 In section .text, align 2, keep-with-next
   1278          HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
   1279          {
   \                     HAL_UART_Abort_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1280            uint32_t AbortCplt = 0x01U;
   \   00000004   0x2501             MOVS     R5,#+1
   1281          
   1282            /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1283            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   \   0000000A   0xF421 0x71F0      BIC      R1,R1,#0x1E0
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
   1284            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6941             LDR      R1,[R0, #+20]
   \   00000014   0x0849             LSRS     R1,R1,#+1
   \   00000016   0x0049             LSLS     R1,R1,#+1
   \   00000018   0x6141             STR      R1,[R0, #+20]
   1285          
   1286            /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
   1287               before any call to DMA Abort functions */
   1288            /* DMA Tx Handle is valid */
   1289            if(huart->hdmatx != NULL)
   \   0000001A   0x6B20             LDR      R0,[R4, #+48]
   \   0000001C   0xB138             CBZ.N    R0,??HAL_UART_Abort_IT_0
   1290            {
   1291              /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
   1292                 Otherwise, set it to NULL */
   1293              if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6949             LDR      R1,[R1, #+20]
   \   00000022   0x0609             LSLS     R1,R1,#+24
   \   00000024   0xBF4C             ITE      MI 
   1294              {
   1295                huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
   \   00000026   0x.... 0x....      ADRMI.W  R1,UART_DMATxAbortCallback
   1296              }
   1297              else
   1298              {
   1299                huart->hdmatx->XferAbortCallback = NULL;
   \   0000002A   0x2100             MOVPL    R1,#+0
   \   0000002C   0x6501             STR      R1,[R0, #+80]
   1300              }
   1301            }
   1302            /* DMA Rx Handle is valid */
   1303            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_Abort_IT_0: (+1)
   \   0000002E   0x6B60             LDR      R0,[R4, #+52]
   \   00000030   0xB138             CBZ.N    R0,??HAL_UART_Abort_IT_1
   1304            {
   1305              /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
   1306                 Otherwise, set it to NULL */
   1307              if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x6949             LDR      R1,[R1, #+20]
   \   00000036   0x0649             LSLS     R1,R1,#+25
   \   00000038   0xBF4C             ITE      MI 
   1308              {
   1309                huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
   \   0000003A   0x.... 0x....      ADRMI.W  R1,UART_DMARxAbortCallback
   1310              }
   1311              else
   1312              {
   1313                huart->hdmarx->XferAbortCallback = NULL;
   \   0000003E   0x2100             MOVPL    R1,#+0
   \   00000040   0x6501             STR      R1,[R0, #+80]
   1314              }
   1315            }
   1316          
   1317            /* Disable the UART DMA Tx request if enabled */
   1318            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \                     ??HAL_UART_Abort_IT_1: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6941             LDR      R1,[R0, #+20]
   \   00000046   0x0609             LSLS     R1,R1,#+24
   \   00000048   0xD50D             BPL.N    ??HAL_UART_Abort_IT_2
   1319            {
   1320              /* Disable DMA Tx at UART level */
   1321              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000004A   0x6941             LDR      R1,[R0, #+20]
   \   0000004C   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000050   0x6141             STR      R1,[R0, #+20]
   1322          
   1323              /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
   1324              if(huart->hdmatx != NULL)
   \   00000052   0x6B20             LDR      R0,[R4, #+48]
   \   00000054   0xB138             CBZ.N    R0,??HAL_UART_Abort_IT_2
   1325              {
   1326                /* UART Tx DMA Abort callback has already been initialised : 
   1327                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1328          
   1329                /* Abort DMA TX */
   1330                if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
   \   00000056   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xBF1D             ITTTE    NE 
   1331                {
   1332                  huart->hdmatx->XferAbortCallback = NULL;
   \   0000005E   0x2000             MOVNE    R0,#+0
   \   00000060   0x6B21             LDRNE    R1,[R4, #+48]
   \   00000062   0x6508             STRNE    R0,[R1, #+80]
   1333                }
   1334                else
   1335                {
   1336                  AbortCplt = 0x00U;
   \   00000064   0x2500             MOVEQ    R5,#+0
   1337                }
   1338              }
   1339            }
   1340          
   1341            /* Disable the UART DMA Rx request if enabled */
   1342            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_UART_Abort_IT_2: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6941             LDR      R1,[R0, #+20]
   \   0000006A   0x0649             LSLS     R1,R1,#+25
   \   0000006C   0xD50C             BPL.N    ??HAL_UART_Abort_IT_3
   1343            {
   1344              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   0000006E   0x6941             LDR      R1,[R0, #+20]
   \   00000070   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000074   0x6141             STR      R1,[R0, #+20]
   1345          
   1346              /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
   1347              if(huart->hdmarx != NULL)
   \   00000076   0x6B60             LDR      R0,[R4, #+52]
   \   00000078   0xB130             CBZ.N    R0,??HAL_UART_Abort_IT_3
   1348              {
   1349                /* UART Rx DMA Abort callback has already been initialised : 
   1350                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1351          
   1352                /* Abort DMA RX */
   1353                if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \   0000007A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   0000007E   0xB180             CBZ.N    R0,??HAL_UART_Abort_IT_4
   1354                {
   1355                  huart->hdmarx->XferAbortCallback = NULL;
   \   00000080   0x6B61             LDR      R1,[R4, #+52]
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x6508             STR      R0,[R1, #+80]
   1356                  AbortCplt = 0x01U;
   \   00000086   0xE000             B.N      ??HAL_UART_Abort_IT_5
   1357                }
   1358                else
   1359                {
   1360                  AbortCplt = 0x00U;
   1361                }
   1362              }
   1363            }
   1364          
   1365            /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
   1366            if(AbortCplt == 0x01U)
   \                     ??HAL_UART_Abort_IT_3: (+1)
   \   00000088   0xB15D             CBZ.N    R5,??HAL_UART_Abort_IT_4
   1367            {
   1368              /* Reset Tx and Rx transfer counters */
   1369              huart->TxXferCount = 0x00U; 
   \                     ??HAL_UART_Abort_IT_5: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x84E0             STRH     R0,[R4, #+38]
   1370              huart->RxXferCount = 0x00U;
   \   0000008E   0x85E0             STRH     R0,[R4, #+46]
   1371          
   1372              /* Reset ErrorCode */
   1373              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000090   0x63E0             STR      R0,[R4, #+60]
   1374          
   1375              /* Restore huart->gState and huart->RxState to Ready */
   1376              huart->gState  = HAL_UART_STATE_READY;
   \   00000092   0x2020             MOVS     R0,#+32
   \   00000094   0xF884 0x0039      STRB     R0,[R4, #+57]
   1377              huart->RxState = HAL_UART_STATE_READY;
   \   00000098   0xF884 0x003A      STRB     R0,[R4, #+58]
   1378          
   1379              /* As no DMA to be aborted, call directly user Abort complete callback */
   1380              HAL_UART_AbortCpltCallback(huart);
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   1381            }
   1382          
   1383            return HAL_OK;
   \                     ??HAL_UART_Abort_IT_4: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1384          }
   1385          
   1386          /**
   1387            * @brief  Abort ongoing Transmit transfer (Interrupt mode).
   1388            * @param  huart UART handle.
   1389            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. 
   1390            *         This procedure performs following operations :
   1391            *           - Disable PPP Interrupts
   1392            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1393            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1394            *           - Set handle State to READY
   1395            *           - At abort completion, call user abort complete callback
   1396            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1397            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1398            * @retval HAL status
   1399          */

   \                                 In section .text, align 2, keep-with-next
   1400          HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
   1401          {
   \                     HAL_UART_AbortTransmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1402            /* Disable TXEIE and TCIE interrupts */
   1403            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF021 0x01C0      BIC      R1,R1,#0xC0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1404          
   1405            /* Disable the UART DMA Tx request if enabled */
   1406            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xD50D             BPL.N    ??HAL_UART_AbortTransmit_IT_0
   1407            {
   1408              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000016   0x.... 0x....      BL       ?Subroutine12
   1409          
   1410              /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
   1411              if(huart->hdmatx != NULL)
   \                     ??CrossCallReturnLabel_23: (+1)
   \   0000001A   0xB150             CBZ.N    R0,??HAL_UART_AbortTransmit_IT_0
   1412              {
   1413                /* Set the UART DMA Abort callback : 
   1414                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1415                huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
   \   0000001C   0x.... 0x....      ADR.W    R1,UART_DMATxOnlyAbortCallback
   \   00000020   0x6501             STR      R1,[R0, #+80]
   1416          
   1417                /* Abort DMA TX */
   1418                if(HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
   \   00000022   0x6B20             LDR      R0,[R4, #+48]
   \   00000024   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   00000028   0xB158             CBZ.N    R0,??HAL_UART_AbortTransmit_IT_1
   1419                {
   1420                  /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
   1421                  huart->hdmatx->XferAbortCallback(huart->hdmatx);
   \   0000002A   0x6B20             LDR      R0,[R4, #+48]
   \   0000002C   0x6D01             LDR      R1,[R0, #+80]
   \   0000002E   0x4788             BLX      R1
   \   00000030   0xE007             B.N      ??HAL_UART_AbortTransmit_IT_1
   1422                }
   1423              }
   1424              else
   1425              {      
   1426                /* Reset Tx transfer counter */
   1427                huart->TxXferCount = 0x00U;
   1428          
   1429                /* Restore huart->gState to Ready */
   1430                huart->gState = HAL_UART_STATE_READY;
   1431          
   1432                /* As no DMA to be aborted, call directly user Abort complete callback */
   1433                HAL_UART_AbortTransmitCpltCallback(huart);
   1434              }
   1435            }
   1436            else
   1437            {
   1438              /* Reset Tx transfer counter */
   1439              huart->TxXferCount = 0x00U;
   \                     ??HAL_UART_AbortTransmit_IT_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x84E0             STRH     R0,[R4, #+38]
   1440          
   1441              /* Restore huart->gState to Ready */
   1442              huart->gState = HAL_UART_STATE_READY;
   \   00000036   0x2020             MOVS     R0,#+32
   \   00000038   0xF884 0x0039      STRB     R0,[R4, #+57]
   1443          
   1444              /* As no DMA to be aborted, call directly user Abort complete callback */
   1445              HAL_UART_AbortTransmitCpltCallback(huart);
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   1446            }
   1447          
   1448            return HAL_OK;
   \                     ??HAL_UART_AbortTransmit_IT_1: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
   1449          }
   1450          
   1451          /**
   1452            * @brief  Abort ongoing Receive transfer (Interrupt mode).
   1453            * @param  huart UART handle.
   1454            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode. 
   1455            *         This procedure performs following operations :
   1456            *           - Disable PPP Interrupts
   1457            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1458            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1459            *           - Set handle State to READY
   1460            *           - At abort completion, call user abort complete callback
   1461            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1462            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1463            * @retval HAL status
   1464          */

   \                                 In section .text, align 2, keep-with-next
   1465          HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
   1466          {
   \                     HAL_UART_AbortReceive_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1467            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1468            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF421 0x7190      BIC      R1,R1,#0x120
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1469            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6941             LDR      R1,[R0, #+20]
   \   00000012   0x0849             LSRS     R1,R1,#+1
   \   00000014   0x0049             LSLS     R1,R1,#+1
   \   00000016   0x6141             STR      R1,[R0, #+20]
   1470          
   1471            /* Disable the UART DMA Rx request if enabled */
   1472            if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x6941             LDR      R1,[R0, #+20]
   \   0000001C   0x0649             LSLS     R1,R1,#+25
   \   0000001E   0xD50D             BPL.N    ??HAL_UART_AbortReceive_IT_0
   1473            {
   1474              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000020   0x.... 0x....      BL       ?Subroutine9
   1475          
   1476              /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
   1477              if(huart->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000024   0xB150             CBZ.N    R0,??HAL_UART_AbortReceive_IT_0
   1478              {
   1479                /* Set the UART DMA Abort callback : 
   1480                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1481                huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
   \   00000026   0x.... 0x....      ADR.W    R1,UART_DMARxOnlyAbortCallback
   \   0000002A   0x6501             STR      R1,[R0, #+80]
   1482          
   1483                /* Abort DMA RX */
   1484                if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \   0000002C   0x6B60             LDR      R0,[R4, #+52]
   \   0000002E   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   00000032   0xB158             CBZ.N    R0,??HAL_UART_AbortReceive_IT_1
   1485                {
   1486                  /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
   1487                  huart->hdmarx->XferAbortCallback(huart->hdmarx);
   \   00000034   0x6B60             LDR      R0,[R4, #+52]
   \   00000036   0x6D01             LDR      R1,[R0, #+80]
   \   00000038   0x4788             BLX      R1
   \   0000003A   0xE007             B.N      ??HAL_UART_AbortReceive_IT_1
   1488                }
   1489              }
   1490              else
   1491              {
   1492                /* Reset Rx transfer counter */
   1493                huart->RxXferCount = 0x00U; 
   1494          
   1495                /* Restore huart->RxState to Ready */
   1496                huart->RxState = HAL_UART_STATE_READY;
   1497          
   1498                /* As no DMA to be aborted, call directly user Abort complete callback */
   1499                HAL_UART_AbortReceiveCpltCallback(huart);
   1500              }
   1501            }
   1502            else
   1503            {
   1504              /* Reset Rx transfer counter */
   1505              huart->RxXferCount = 0x00U; 
   \                     ??HAL_UART_AbortReceive_IT_0: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x85E0             STRH     R0,[R4, #+46]
   1506          
   1507              /* Restore huart->RxState to Ready */
   1508              huart->RxState = HAL_UART_STATE_READY;
   \   00000040   0x2020             MOVS     R0,#+32
   \   00000042   0xF884 0x003A      STRB     R0,[R4, #+58]
   1509          
   1510              /* As no DMA to be aborted, call directly user Abort complete callback */
   1511              HAL_UART_AbortReceiveCpltCallback(huart);
   \   00000046   0x4620             MOV      R0,R4
   \   00000048   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   1512            }
   1513          
   1514            return HAL_OK;
   \                     ??HAL_UART_AbortReceive_IT_1: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   1515          }
   1516          
   1517          /**
   1518            * @brief  This function handles UART interrupt request.
   1519            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1520            *                the configuration information for the specified UART module.
   1521            * @retval None
   1522            */

   \                                 In section .text, align 2, keep-with-next
   1523          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1524          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1525             uint32_t isrflags   = READ_REG(huart->Instance->SR);
   \   00000004   0x6823             LDR      R3,[R4, #+0]
   \   00000006   0x6818             LDR      R0,[R3, #+0]
   1526             uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   \   00000008   0x68D9             LDR      R1,[R3, #+12]
   1527             uint32_t cr3its     = READ_REG(huart->Instance->CR3);
   \   0000000A   0x695A             LDR      R2,[R3, #+20]
   1528             uint32_t errorflags = 0x00U;
   1529             uint32_t dmarequest = 0x00U;
   1530          
   1531            /* If no error occurs */
   1532            errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
   1533            if(errorflags == RESET)
   \   0000000C   0xF010 0x0F0F      TST      R0,#0xF
   \   00000010   0xD107             BNE.N    ??HAL_UART_IRQHandler_0
   1534            {
   1535              /* UART in mode Receiver -------------------------------------------------*/
   1536              if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
   \   00000012   0x0682             LSLS     R2,R0,#+26
   \   00000014   0xD55C             BPL.N    ??HAL_UART_IRQHandler_1
   \   00000016   0x068A             LSLS     R2,R1,#+26
   \   00000018   0xD55A             BPL.N    ??HAL_UART_IRQHandler_1
   1537              {
   1538                UART_Receive_IT(huart);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000020   0x....             B.N      UART_Receive_IT
   1539                return;
   1540              }
   1541            }  
   1542          
   1543            /* If some errors occur */
   1544            if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   00000022   0x07D5             LSLS     R5,R2,#+31
   \   00000024   0xD402             BMI.N    ??HAL_UART_IRQHandler_2
   \   00000026   0xF411 0x7F90      TST      R1,#0x120
   \   0000002A   0xD051             BEQ.N    ??HAL_UART_IRQHandler_1
   1545            {
   1546              /* UART parity error interrupt occurred ----------------------------------*/
   1547              if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   0000002C   0x07C3             LSLS     R3,R0,#+31
   \   0000002E   0xD505             BPL.N    ??HAL_UART_IRQHandler_3
   \   00000030   0x05CB             LSLS     R3,R1,#+23
   \   00000032   0xD503             BPL.N    ??HAL_UART_IRQHandler_3
   1548              {
   1549                huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   00000034   0x6BE3             LDR      R3,[R4, #+60]
   \   00000036   0xF043 0x0301      ORR      R3,R3,#0x1
   \   0000003A   0x63E3             STR      R3,[R4, #+60]
   1550              }
   1551              
   1552              /* UART noise error interrupt occurred -----------------------------------*/
   1553              if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   0000003C   0x0743             LSLS     R3,R0,#+29
   \   0000003E   0xD505             BPL.N    ??HAL_UART_IRQHandler_4
   \   00000040   0x07D3             LSLS     R3,R2,#+31
   \   00000042   0xD503             BPL.N    ??HAL_UART_IRQHandler_4
   1554              {
   1555                huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   00000044   0x6BE3             LDR      R3,[R4, #+60]
   \   00000046   0xF043 0x0302      ORR      R3,R3,#0x2
   \   0000004A   0x63E3             STR      R3,[R4, #+60]
   1556              }
   1557              
   1558              /* UART frame error interrupt occurred -----------------------------------*/
   1559              if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   0000004C   0x0783             LSLS     R3,R0,#+30
   \   0000004E   0xD505             BPL.N    ??HAL_UART_IRQHandler_5
   \   00000050   0x07D3             LSLS     R3,R2,#+31
   \   00000052   0xD503             BPL.N    ??HAL_UART_IRQHandler_5
   1560              {
   1561                huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   00000054   0x6BE3             LDR      R3,[R4, #+60]
   \   00000056   0xF043 0x0304      ORR      R3,R3,#0x4
   \   0000005A   0x63E3             STR      R3,[R4, #+60]
   1562              }
   1563              
   1564              /* UART Over-Run interrupt occurred --------------------------------------*/
   1565              if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   0000005C   0x0703             LSLS     R3,R0,#+28
   \   0000005E   0xD505             BPL.N    ??HAL_UART_IRQHandler_6
   \   00000060   0x07D2             LSLS     R2,R2,#+31
   \   00000062   0xD503             BPL.N    ??HAL_UART_IRQHandler_6
   1566              { 
   1567                huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   00000064   0x6BE2             LDR      R2,[R4, #+60]
   \   00000066   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000006A   0x63E2             STR      R2,[R4, #+60]
   1568              }
   1569          
   1570              /* Call UART Error Call back function if need be --------------------------*/    
   1571              if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   0000006C   0x6BE2             LDR      R2,[R4, #+60]
   \   0000006E   0x2A00             CMP      R2,#+0
   \   00000070   0xD069             BEQ.N    ??HAL_UART_IRQHandler_7
   1572              {
   1573                /* UART in mode Receiver -----------------------------------------------*/
   1574                if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
   \   00000072   0x0680             LSLS     R0,R0,#+26
   \   00000074   0xD504             BPL.N    ??HAL_UART_IRQHandler_8
   \   00000076   0x0688             LSLS     R0,R1,#+26
   \   00000078   0xBF44             ITT      MI 
   1575                {
   1576                  UART_Receive_IT(huart);
   \   0000007A   0x4620             MOVMI    R0,R4
   \   0000007C   0x.... 0x....      BLMI     UART_Receive_IT
   1577                }
   1578          
   1579                /* If Overrun error occurs, or if any error occurs in DMA mode reception,
   1580                   consider error as blocking */
   1581                dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_IRQHandler_8: (+1)
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x6940             LDR      R0,[R0, #+20]
   1582                if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
   \   00000084   0x6BE1             LDR      R1,[R4, #+60]
   \   00000086   0x0709             LSLS     R1,R1,#+28
   \   00000088   0xD401             BMI.N    ??HAL_UART_IRQHandler_9
   \   0000008A   0x0640             LSLS     R0,R0,#+25
   \   0000008C   0xD51A             BPL.N    ??HAL_UART_IRQHandler_10
   1583                {
   1584                  /* Blocking error : transfer is aborted
   1585                     Set the UART state ready to be able to start again the process,
   1586                     Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
   1587                  UART_EndRxTransfer(huart);
   \                     ??HAL_UART_IRQHandler_9: (+1)
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       UART_EndRxTransfer
   1588                  
   1589                  /* Disable the UART DMA Rx request if enabled */
   1590                  if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6941             LDR      R1,[R0, #+20]
   \   00000098   0x0649             LSLS     R1,R1,#+25
   \   0000009A   0xD50F             BPL.N    ??HAL_UART_IRQHandler_11
   1591                  {
   1592                    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   0000009C   0x.... 0x....      BL       ?Subroutine9
   1593                    
   1594                    /* Abort the UART DMA Rx channel */
   1595                    if(huart->hdmarx != NULL)
   \                     ??CrossCallReturnLabel_17: (+1)
   \   000000A0   0xB160             CBZ.N    R0,??HAL_UART_IRQHandler_11
   1596                    {
   1597                      /* Set the UART DMA Abort callback : 
   1598                         will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
   1599                      huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
   \   000000A2   0x.... 0x....      ADR.W    R1,UART_DMAAbortOnError
   \   000000A6   0x6501             STR      R1,[R0, #+80]
   1600                      if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \   000000A8   0x6B60             LDR      R0,[R4, #+52]
   \   000000AA   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD049             BEQ.N    ??HAL_UART_IRQHandler_7
   1601                      {
   1602                        /* Call Directly XferAbortCallback function in case of error */
   1603                        huart->hdmarx->XferAbortCallback(huart->hdmarx);
   \   000000B2   0x6B60             LDR      R0,[R4, #+52]
   \   000000B4   0x6D01             LDR      R1,[R0, #+80]
   \   000000B6   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000BA   0x4708             BX       R1
   1604                      }
   1605                    }
   1606                    else
   1607                    {
   1608                      /* Call user error callback */
   1609                      HAL_UART_ErrorCallback(huart);
   1610                    }
   1611                  }
   1612                  else
   1613                  {
   1614                    /* Call user error callback */
   1615                    HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_11: (+1)
   \   000000BC   0x4620             MOV      R0,R4
   \   000000BE   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \   000000C2   0xBD31             POP      {R0,R4,R5,PC}
   1616                  }
   1617                }
   1618                else
   1619                {
   1620                  /* Non Blocking error : transfer could go on. 
   1621                     Error is notified to user through user error callback */
   1622                  HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_10: (+1)
   \   000000C4   0x4620             MOV      R0,R4
   \   000000C6   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1623                  huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x63E0             STR      R0,[R4, #+60]
   1624                }
   1625              }
   1626              return;
   \   000000CE   0xBD31             POP      {R0,R4,R5,PC}
   1627            } /* End if some error occurs */
   1628          
   1629            /* UART in mode Transmitter ------------------------------------------------*/
   1630            if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   000000D0   0x0602             LSLS     R2,R0,#+24
   \   000000D2   0xD52A             BPL.N    ??HAL_UART_IRQHandler_12
   \   000000D4   0x060A             LSLS     R2,R1,#+24
   \   000000D6   0xD528             BPL.N    ??HAL_UART_IRQHandler_12
   1631            {
   1632              UART_Transmit_IT(huart);
   \   000000D8   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   000000DC   0x2821             CMP      R0,#+33
   \   000000DE   0xD132             BNE.N    ??HAL_UART_IRQHandler_7
   \   000000E0   0x68A0             LDR      R0,[R4, #+8]
   \   000000E2   0xF5B0 0x5F80      CMP      R0,#+4096
   \   000000E6   0x6A20             LDR      R0,[R4, #+32]
   \   000000E8   0xD10B             BNE.N    ??HAL_UART_IRQHandler_13
   \   000000EA   0x8800             LDRH     R0,[R0, #+0]
   \   000000EC   0x05C0             LSLS     R0,R0,#+23
   \   000000EE   0x0DC0             LSRS     R0,R0,#+23
   \   000000F0   0x6058             STR      R0,[R3, #+4]
   \   000000F2   0x6920             LDR      R0,[R4, #+16]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0x6A20             LDR      R0,[R4, #+32]
   \   000000F8   0xBF0C             ITE      EQ 
   \   000000FA   0x1C80             ADDEQ    R0,R0,#+2
   \   000000FC   0x1C40             ADDNE    R0,R0,#+1
   \   000000FE   0x6220             STR      R0,[R4, #+32]
   \   00000100   0xE003             B.N      ??HAL_UART_IRQHandler_14
   \                     ??HAL_UART_IRQHandler_13: (+1)
   \   00000102   0x1C41             ADDS     R1,R0,#+1
   \   00000104   0x6221             STR      R1,[R4, #+32]
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0x6058             STR      R0,[R3, #+4]
   \                     ??HAL_UART_IRQHandler_14: (+1)
   \   0000010A   0x8CE0             LDRH     R0,[R4, #+38]
   \   0000010C   0x1E40             SUBS     R0,R0,#+1
   \   0000010E   0x84E0             STRH     R0,[R4, #+38]
   \   00000110   0xB280             UXTH     R0,R0
   \   00000112   0xB9C0             CBNZ.N   R0,??HAL_UART_IRQHandler_7
   \   00000114   0x6820             LDR      R0,[R4, #+0]
   \   00000116   0x68C1             LDR      R1,[R0, #+12]
   \   00000118   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000011C   0x60C1             STR      R1,[R0, #+12]
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x68C1             LDR      R1,[R0, #+12]
   \   00000122   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000126   0x60C1             STR      R1,[R0, #+12]
   1633              return;
   \   00000128   0xBD31             POP      {R0,R4,R5,PC}
   1634            }
   1635            
   1636            /* UART in mode Transmitter end --------------------------------------------*/
   1637            if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
   \                     ??HAL_UART_IRQHandler_12: (+1)
   \   0000012A   0x0640             LSLS     R0,R0,#+25
   \   0000012C   0xD50B             BPL.N    ??HAL_UART_IRQHandler_7
   \   0000012E   0x0648             LSLS     R0,R1,#+25
   \   00000130   0xD509             BPL.N    ??HAL_UART_IRQHandler_7
   1638            {
   1639              UART_EndTransmit_IT(huart);
   \   00000132   0x68D8             LDR      R0,[R3, #+12]
   \   00000134   0xF020 0x0040      BIC      R0,R0,#0x40
   \   00000138   0x60D8             STR      R0,[R3, #+12]
   \   0000013A   0x2020             MOVS     R0,#+32
   \   0000013C   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000140   0x4620             MOV      R0,R4
   \   00000142   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1640              return;
   1641            }
   1642          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   00000146   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1643          
   1644          /**
   1645            * @brief  Tx Transfer completed callbacks.
   1646            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1647            *                the configuration information for the specified UART module.
   1648            * @retval None
   1649            */

   \                                 In section .text, align 2, keep-with-next
   1650           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1651          {
   1652            /* Prevent unused argument(s) compilation warning */
   1653            UNUSED(huart);
   1654            /* NOTE: This function Should not be modified, when the callback is needed,
   1655                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1656             */ 
   1657          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1658          
   1659          /**
   1660            * @brief  Tx Half Transfer completed callbacks.
   1661            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1662            *                the configuration information for the specified UART module.
   1663            * @retval None
   1664            */

   \                                 In section .text, align 2, keep-with-next
   1665           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1666          {
   1667            /* Prevent unused argument(s) compilation warning */
   1668            UNUSED(huart);
   1669            /* NOTE: This function Should not be modified, when the callback is needed,
   1670                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1671             */ 
   1672          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1673          
   1674          /**
   1675            * @brief  Rx Transfer completed callbacks.
   1676            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1677            *                the configuration information for the specified UART module.
   1678            * @retval None
   1679            */

   \                                 In section .text, align 2, keep-with-next
   1680          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1681          {
   1682            /* Prevent unused argument(s) compilation warning */
   1683            UNUSED(huart);
   1684            /* NOTE: This function Should not be modified, when the callback is needed,
   1685                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1686             */
   1687          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1688          
   1689          /**
   1690            * @brief  Rx Half Transfer completed callbacks.
   1691            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1692            *                the configuration information for the specified UART module.
   1693            * @retval None
   1694            */

   \                                 In section .text, align 2, keep-with-next
   1695          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1696          {
   1697            /* Prevent unused argument(s) compilation warning */
   1698            UNUSED(huart);
   1699            /* NOTE: This function Should not be modified, when the callback is needed,
   1700                     the HAL_UART_TxCpltCallback could be implemented in the user file
   1701             */
   1702          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1703          
   1704          /**
   1705            * @brief  UART error callbacks.
   1706            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1707            *                the configuration information for the specified UART module.
   1708            * @retval None
   1709            */

   \                                 In section .text, align 2, keep-with-next
   1710           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1711          {
   1712            /* Prevent unused argument(s) compilation warning */
   1713            UNUSED(huart); 
   1714            /* NOTE: This function Should not be modified, when the callback is needed,
   1715                     the HAL_UART_ErrorCallback could be implemented in the user file
   1716             */ 
   1717          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1718          
   1719          /**
   1720            * @brief  UART Abort Complete callback.
   1721            * @param  huart UART handle.
   1722            * @retval None
   1723            */

   \                                 In section .text, align 2, keep-with-next
   1724          __weak void HAL_UART_AbortCpltCallback (UART_HandleTypeDef *huart)
   1725          {
   1726            /* Prevent unused argument(s) compilation warning */
   1727            UNUSED(huart);
   1728          
   1729            /* NOTE : This function should not be modified, when the callback is needed,
   1730                      the HAL_UART_AbortCpltCallback can be implemented in the user file.
   1731             */
   1732          }
   \                     HAL_UART_AbortCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1733          /**
   1734            * @brief  UART Abort Complete callback.
   1735            * @param  huart UART handle.
   1736            * @retval None
   1737            */

   \                                 In section .text, align 2, keep-with-next
   1738          __weak void HAL_UART_AbortTransmitCpltCallback (UART_HandleTypeDef *huart)
   1739          {
   1740            /* Prevent unused argument(s) compilation warning */
   1741            UNUSED(huart);
   1742          
   1743            /* NOTE : This function should not be modified, when the callback is needed,
   1744                      the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
   1745             */
   1746          }
   \                     HAL_UART_AbortTransmitCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1747          
   1748          /**
   1749            * @brief  UART Abort Receive Complete callback.
   1750            * @param  huart UART handle.
   1751            * @retval None
   1752            */

   \                                 In section .text, align 2, keep-with-next
   1753          __weak void HAL_UART_AbortReceiveCpltCallback (UART_HandleTypeDef *huart)
   1754          {
   1755            /* Prevent unused argument(s) compilation warning */
   1756            UNUSED(huart);
   1757          
   1758            /* NOTE : This function should not be modified, when the callback is needed,
   1759                      the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
   1760             */
   1761          }
   \                     HAL_UART_AbortReceiveCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1762          
   1763          /**
   1764            * @}
   1765            */
   1766          
   1767          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1768            *  @brief   UART control functions 
   1769            *
   1770          @verbatim   
   1771            ==============================================================================
   1772                                ##### Peripheral Control functions #####
   1773            ==============================================================================  
   1774            [..]
   1775              This subsection provides a set of functions allowing to control the UART:
   1776              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   1777              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode. 
   1778              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   1779              
   1780          @endverbatim
   1781            * @{
   1782            */
   1783          
   1784          /**
   1785            * @brief  Transmits break characters.
   1786            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1787            *                the configuration information for the specified UART module.
   1788            * @retval HAL status
   1789            */

   \                                 In section .text, align 2, keep-with-next
   1790          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1791          {
   1792            /* Check the parameters */
   1793            assert_param(IS_UART_INSTANCE(huart->Instance));
   1794            
   1795            /* Process Locked */
   1796            __HAL_LOCK(huart);
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1797            
   1798            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1799            
   1800            /* Send break characters */
   1801            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000020   0x....             B.N      ?Subroutine2
   1802           
   1803            huart->gState = HAL_UART_STATE_READY;
   1804            
   1805            /* Process Unlocked */
   1806            __HAL_UNLOCK(huart);
   1807            
   1808            return HAL_OK; 
   1809          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x60CA             STR      R2,[R1, #+12]
   \   00000002   0x2120             MOVS     R1,#+32
   \   00000004   0xF880 0x1039      STRB     R1,[R0, #+57]
   \   00000008                      REQUIRE ??Subroutine15_0
   \   00000008                      ;; // Fall through to label ??Subroutine15_0
   1810          
   1811          /**
   1812            * @brief  Enters the UART in mute mode. 
   1813            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1814            *                the configuration information for the specified UART module.
   1815            * @retval HAL status
   1816            */

   \                                 In section .text, align 2, keep-with-next
   1817          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1818          {
   1819            /* Check the parameters */
   1820            assert_param(IS_UART_INSTANCE(huart->Instance));
   1821            
   1822            /* Process Locked */
   1823            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_EnterMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_MultiProcessor_EnterMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1824            
   1825            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1826            
   1827            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   1828            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000020                      REQUIRE ?Subroutine2
   \   00000020                      ;; // Fall through to label ?Subroutine2
   1829            
   1830            huart->gState = HAL_UART_STATE_READY;
   1831            
   1832            /* Process Unlocked */
   1833            __HAL_UNLOCK(huart);
   1834            
   1835            return HAL_OK; 
   1836          }
   1837          
   1838          /**
   1839            * @brief  Exits the UART mute mode: wake up software. 
   1840            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1841            *                the configuration information for the specified UART module.
   1842            * @retval HAL status
   1843            */

   \                                 In section .text, align 2, keep-with-next
   1844          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   1845          {
   1846            /* Check the parameters */
   1847            assert_param(IS_UART_INSTANCE(huart->Instance));
   1848            
   1849            /* Process Locked */
   1850            __HAL_LOCK(huart);
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_MultiProcessor_ExitMuteMode_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_MultiProcessor_ExitMuteMode_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1851            
   1852            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1853            
   1854            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   1855            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   \   0000001C   0xF022 0x0202      BIC      R2,R2,#0x2
   \   00000020   0x....             B.N      ?Subroutine2
   1856            
   1857            huart->gState = HAL_UART_STATE_READY;
   1858            
   1859            /* Process Unlocked */
   1860            __HAL_UNLOCK(huart);
   1861            
   1862            return HAL_OK; 
   1863          }
   1864          
   1865          /**
   1866            * @brief  Enables the UART transmitter and disables the UART receiver.
   1867            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1868            *                the configuration information for the specified UART module.
   1869            * @retval HAL status
   1870            */

   \                                 In section .text, align 2, keep-with-next
   1871          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1872          {
   1873            uint32_t tmpreg = 0x00U;
   1874          
   1875            /* Process Locked */
   1876            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1877            
   1878            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1879          
   1880            /*-------------------------- USART CR1 Configuration -----------------------*/
   1881            tmpreg = huart->Instance->CR1;
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   1882            
   1883            /* Clear TE and RE bits */
   1884            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
   1885            
   1886            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1887            tmpreg |= (uint32_t)USART_CR1_TE;
   1888            
   1889            /* Write to USART CR1 */
   1890            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \   0000001C   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000020   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000024   0x....             B.N      ?Subroutine2
   1891           
   1892            huart->gState = HAL_UART_STATE_READY;
   1893            
   1894            /* Process Unlocked */
   1895            __HAL_UNLOCK(huart);
   1896            
   1897            return HAL_OK; 
   1898          }
   1899          
   1900          /**
   1901            * @brief  Enables the UART receiver and disables the UART transmitter.
   1902            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1903            *                the configuration information for the specified UART module.
   1904            * @retval HAL status
   1905            */

   \                                 In section .text, align 2, keep-with-next
   1906          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1907          {
   1908            uint32_t tmpreg = 0x00U;
   1909          
   1910            /* Process Locked */
   1911            __HAL_LOCK(huart);
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0xF890 0x1038      LDRB     R1,[R0, #+56]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1038      STRB     R1,[R0, #+56]
   1912            
   1913            huart->gState = HAL_UART_STATE_BUSY;
   \   00000012   0x2124             MOVS     R1,#+36
   \   00000014   0xF880 0x1039      STRB     R1,[R0, #+57]
   1914          
   1915            /*-------------------------- USART CR1 Configuration -----------------------*/
   1916            tmpreg = huart->Instance->CR1;
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x68CA             LDR      R2,[R1, #+12]
   1917            
   1918            /* Clear TE and RE bits */
   1919            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
   1920            
   1921            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1922            tmpreg |= (uint32_t)USART_CR1_RE;
   1923            
   1924            /* Write to USART CR1 */
   1925            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \   0000001C   0xF022 0x020C      BIC      R2,R2,#0xC
   \   00000020   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000024   0x....             B.N      ?Subroutine2
   1926            
   1927            huart->gState = HAL_UART_STATE_READY;
   1928            
   1929            /* Process Unlocked */
   1930            __HAL_UNLOCK(huart);
   1931            
   1932            return HAL_OK; 
   1933          }
   1934          
   1935          /**
   1936            * @}
   1937            */
   1938          
   1939          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions 
   1940            *  @brief   UART State and Errors functions 
   1941            *
   1942          @verbatim   
   1943            ==============================================================================
   1944                           ##### Peripheral State and Errors functions #####
   1945            ==============================================================================  
   1946           [..]
   1947             This subsection provides a set of functions allowing to return the State of 
   1948             UART communication process, return Peripheral Errors occurred during communication 
   1949             process
   1950             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   1951             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication. 
   1952          
   1953          @endverbatim
   1954            * @{
   1955            */
   1956            
   1957          /**
   1958            * @brief  Returns the UART state.
   1959            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   1960            *                the configuration information for the specified UART module.
   1961            * @retval HAL state
   1962            */

   \                                 In section .text, align 2, keep-with-next
   1963          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1964          {
   1965            uint32_t temp1= 0x00U, temp2 = 0x00U;
   1966            temp1 = huart->gState;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x1039      LDRB     R1,[R0, #+57]
   1967            temp2 = huart->RxState;
   \   00000004   0xF890 0x003A      LDRB     R0,[R0, #+58]
   1968            
   1969            return (HAL_UART_StateTypeDef)(temp1 | temp2);
   \   00000008   0x4308             ORRS     R0,R0,R1
   \   0000000A   0x4770             BX       LR               ;; return
   1970          }
   1971          
   1972          /**
   1973            * @brief  Return the UART error code
   1974            * @param  huart  pointer to a UART_HandleTypeDef structure that contains
   1975            *              the configuration information for the specified UART.
   1976            * @retval UART Error Code
   1977            */

   \                                 In section .text, align 2, keep-with-next
   1978          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1979          {
   1980            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1981          }
   1982          
   1983          /**
   1984            * @}
   1985            */
   1986          
   1987          /**
   1988            * @brief  DMA UART transmit process complete callback. 
   1989            * @param  hdma DMA handle
   1990            * @retval None
   1991            */

   \                                 In section .text, align 4, keep-with-next
   1992          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   1993          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1994            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B81             LDR      R1,[R0, #+56]
   1995            /* DMA Normal mode*/
   1996            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x05C0             LSLS     R0,R0,#+23
   \   0000000A   0xD40C             BMI.N    ??UART_DMATransmitCplt_0
   1997            {
   1998              huart->TxXferCount = 0U;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x84C8             STRH     R0,[R1, #+38]
   1999          
   2000              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   2001                 in the UART CR3 register */
   2002              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000010   0x6808             LDR      R0,[R1, #+0]
   \   00000012   0x6942             LDR      R2,[R0, #+20]
   \   00000014   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000018   0x6142             STR      R2,[R0, #+20]
   2003          
   2004              /* Enable the UART Transmit Complete Interrupt */
   2005              SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C1             LDR      R1,[R0, #+12]
   \   0000001E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000022   0x60C1             STR      R1,[R0, #+12]
   \   00000024   0xBD01             POP      {R0,PC}
   2006          
   2007            }
   2008            /* DMA Circular mode */
   2009            else
   2010            {
   2011              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   00000026   0x4608             MOV      R0,R1
   \   00000028   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   2012            }
   2013          }
   \   0000002C   0xBD01             POP      {R0,PC}          ;; return
   2014          
   2015          /**
   2016            * @brief DMA UART transmit process half complete callback 
   2017            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2018            *                the configuration information for the specified DMA module.
   2019            * @retval None
   2020            */

   \                                 In section .text, align 4, keep-with-next
   2021          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   2022          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2023            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   2024          
   2025            HAL_UART_TxHalfCpltCallback(huart);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   2026          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2027          
   2028          /**
   2029            * @brief  DMA UART receive process complete callback. 
   2030            * @param  hdma DMA handle
   2031            * @retval None
   2032            */

   \                                 In section .text, align 4, keep-with-next
   2033          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2034          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4601             MOV      R1,R0
   2035            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B88             LDR      R0,[R1, #+56]
   2036            /* DMA Normal mode*/
   2037            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x05C9             LSLS     R1,R1,#+23
   \   0000000C   0xD40F             BMI.N    ??UART_DMAReceiveCplt_0
   2038            {
   2039              huart->RxXferCount = 0U;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x85C1             STRH     R1,[R0, #+46]
   2040            
   2041              /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2042              CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x68CA             LDR      R2,[R1, #+12]
   \   00000016   0xF422 0x7280      BIC      R2,R2,#0x100
   \   0000001A   0x.... 0x....      BL       ?Subroutine13
   2043              CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   2044              
   2045              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   2046                 in the UART CR3 register */
   2047              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??CrossCallReturnLabel_24: (+1)
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x694A             LDR      R2,[R1, #+20]
   \   00000022   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000026   0x614A             STR      R2,[R1, #+20]
   2048          	
   2049              /* At end of Rx process, restore huart->RxState to Ready */
   2050              huart->RxState = HAL_UART_STATE_READY;
   \   00000028   0x2120             MOVS     R1,#+32
   \   0000002A   0xF880 0x103A      STRB     R1,[R0, #+58]
   2051            }
   2052            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   0000002E   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   2053          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0x60CA             STR      R2,[R1, #+12]
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x694A             LDR      R2,[R1, #+20]
   \   00000006   0x0852             LSRS     R2,R2,#+1
   \   00000008   0x0052             LSLS     R2,R2,#+1
   \   0000000A   0x614A             STR      R2,[R1, #+20]
   \   0000000C   0x4770             BX       LR
   2054          
   2055          /**
   2056            * @brief DMA UART receive process half complete callback 
   2057            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2058            *                the configuration information for the specified DMA module.
   2059            * @retval None
   2060            */

   \                                 In section .text, align 4, keep-with-next
   2061          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   2062          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2063            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   2064          
   2065            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   2066          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2067          
   2068          /**
   2069            * @brief  DMA UART communication error callback.
   2070            * @param  hdma DMA handle
   2071            * @retval None
   2072            */

   \                                 In section .text, align 4, keep-with-next
   2073          static void UART_DMAError(DMA_HandleTypeDef *hdma)
   2074          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2075            uint32_t dmarequest = 0x00U;
   2076            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B84             LDR      R4,[R0, #+56]
   2077          
   2078            /* Stop UART DMA Tx request if ongoing */
   2079            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   2080            if((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \   00000008   0xF894 0x1039      LDRB     R1,[R4, #+57]
   \   0000000C   0x2921             CMP      R1,#+33
   \   0000000E   0xD106             BNE.N    ??UART_DMAError_0
   \   00000010   0x0600             LSLS     R0,R0,#+24
   \   00000012   0xD504             BPL.N    ??UART_DMAError_0
   2081            {
   2082              huart->TxXferCount = 0U;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x84E0             STRH     R0,[R4, #+38]
   2083              UART_EndTxTransfer(huart);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       UART_EndTxTransfer
   2084            }
   2085          
   2086            /* Stop UART DMA Rx request if ongoing */
   2087            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR); 
   \                     ??UART_DMAError_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0x6940             LDR      R0,[R0, #+20]
   2088            if((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \   00000022   0xF894 0x103A      LDRB     R1,[R4, #+58]
   \   00000026   0x2922             CMP      R1,#+34
   \   00000028   0xD106             BNE.N    ??UART_DMAError_1
   \   0000002A   0x0640             LSLS     R0,R0,#+25
   \   0000002C   0xD504             BPL.N    ??UART_DMAError_1
   2089            {
   2090              huart->RxXferCount = 0U;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x85E0             STRH     R0,[R4, #+46]
   2091              UART_EndRxTransfer(huart);
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       UART_EndRxTransfer
   2092            }
   2093          
   2094            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \                     ??UART_DMAError_1: (+1)
   \   00000038   0x6BE0             LDR      R0,[R4, #+60]
   \   0000003A   0xF040 0x0010      ORR      R0,R0,#0x10
   \   0000003E   0x63E0             STR      R0,[R4, #+60]
   2095            HAL_UART_ErrorCallback(huart);
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       HAL_UART_ErrorCallback
   2096          }
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
   2097          
   2098          /**
   2099            * @brief  This function handles UART Communication Timeout.
   2100            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   2101            *                the configuration information for the specified UART module.
   2102            * @param  Flag specifies the UART flag to check.
   2103            * @param  Status The new Flag status (SET or RESET).
   2104            * @param  Tickstart Tick start value
   2105            * @param  Timeout Timeout duration
   2106            * @retval HAL status
   2107            */

   \                                 In section .text, align 2, keep-with-next
   2108          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
   2109          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x9E06             LDR      R6,[SP, #+24]
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x461F             MOV      R7,R3
   2110            /* Wait until flag is set */
   2111            while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status) 
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x4028             ANDS     R0,R5,R0
   \   00000014   0x42A8             CMP      R0,R5
   \   00000016   0xBF0C             ITE      EQ 
   \   00000018   0x2001             MOVEQ    R0,#+1
   \   0000001A   0x2000             MOVNE    R0,#+0
   \   0000001C   0x4540             CMP      R0,R8
   \   0000001E   0xD11C             BNE.N    ??UART_WaitOnFlagUntilTimeout_1
   2112            {
   2113              /* Check for the Timeout */
   2114              if(Timeout != HAL_MAX_DELAY)
   \   00000020   0xF116 0x0F01      CMN      R6,#+1
   \   00000024   0xD0F3             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   2115              {
   2116                if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
   \   00000026   0xB126             CBZ.N    R6,??UART_WaitOnFlagUntilTimeout_2
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x1BC0             SUBS     R0,R0,R7
   \   0000002E   0x4286             CMP      R6,R0
   \   00000030   0xD2ED             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   2117                {
   2118                  /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   2119                  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x68C1             LDR      R1,[R0, #+12]
   \   00000036   0xF421 0x71D0      BIC      R1,R1,#0x1A0
   \   0000003A   0x60C1             STR      R1,[R0, #+12]
   2120                  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6941             LDR      R1,[R0, #+20]
   \   00000040   0x0849             LSRS     R1,R1,#+1
   \   00000042   0x0049             LSLS     R1,R1,#+1
   \   00000044   0x6141             STR      R1,[R0, #+20]
   2121                  
   2122                  huart->gState  = HAL_UART_STATE_READY;
   \   00000046   0x2020             MOVS     R0,#+32
   \   00000048   0xF884 0x0039      STRB     R0,[R4, #+57]
   2123                  huart->RxState = HAL_UART_STATE_READY;
   \   0000004C   0xF884 0x003A      STRB     R0,[R4, #+58]
   2124                  
   2125                  /* Process Unlocked */
   2126                  __HAL_UNLOCK(huart);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF884 0x0038      STRB     R0,[R4, #+56]
   2127                  
   2128                  return HAL_TIMEOUT;
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_3
   2129                }
   2130              }
   2131            }
   2132            
   2133            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   0000005C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2134          }
   2135          
   2136          /**
   2137            * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
   2138            * @param  huart UART handle.
   2139            * @retval None
   2140            */

   \                                 In section .text, align 2, keep-with-next
   2141          static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
   2142          {
   2143            /* Disable TXEIE and TCIE interrupts */
   2144            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
   \                     UART_EndTxTransfer: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF022 0x02C0      BIC      R2,R2,#0xC0
   \   00000008   0x60CA             STR      R2,[R1, #+12]
   2145          
   2146            /* At end of Tx process, restore huart->gState to Ready */
   2147            huart->gState = HAL_UART_STATE_READY;
   \   0000000A   0x2120             MOVS     R1,#+32
   \   0000000C   0xF880 0x1039      STRB     R1,[R0, #+57]
   2148          }
   \   00000010   0x4770             BX       LR               ;; return
   2149          
   2150          /**
   2151            * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
   2152            * @param  huart UART handle.
   2153            * @retval None
   2154            */

   \                                 In section .text, align 2, keep-with-next
   2155          static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
   2156          {
   2157            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2158            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \                     UART_EndRxTransfer: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0xF422 0x7290      BIC      R2,R2,#0x120
   \   00000008   0x60CA             STR      R2,[R1, #+12]
   2159            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x694A             LDR      R2,[R1, #+20]
   \   0000000E   0x0852             LSRS     R2,R2,#+1
   \   00000010   0x0052             LSLS     R2,R2,#+1
   \   00000012   0x614A             STR      R2,[R1, #+20]
   2160          
   2161            /* At end of Rx process, restore huart->RxState to Ready */
   2162            huart->RxState = HAL_UART_STATE_READY;
   \   00000014   0x2120             MOVS     R1,#+32
   \   00000016   0xF880 0x103A      STRB     R1,[R0, #+58]
   2163          }
   \   0000001A   0x4770             BX       LR               ;; return
   2164          
   2165          /**
   2166            * @brief  DMA UART communication abort callback, when initiated by HAL services on Error
   2167            *         (To be called at end of DMA Abort procedure following error occurrence).
   2168            * @param  hdma DMA handle.
   2169            * @retval None
   2170            */

   \                                 In section .text, align 4, keep-with-next
   2171          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   2172          {
   \                     UART_DMAAbortOnError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2173            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2174            huart->RxXferCount = 0U;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x85C1             STRH     R1,[R0, #+46]
   2175            huart->TxXferCount = 0U;
   \   00000008   0x84C1             STRH     R1,[R0, #+38]
   2176          
   2177            HAL_UART_ErrorCallback(huart);
   \   0000000A   0x.... 0x....      BL       HAL_UART_ErrorCallback
   2178          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   2179          
   2180          /**
   2181            * @brief  DMA UART Tx communication abort callback, when initiated by user
   2182            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   2183            * @note   When this callback is executed, User Abort complete call back is called only if no
   2184            *         Abort still ongoing for Rx DMA Handle.
   2185            * @param  hdma DMA handle.
   2186            * @retval None
   2187            */

   \                                 In section .text, align 4, keep-with-next
   2188          static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   2189          {
   \                     UART_DMATxAbortCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2190            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2191            
   2192            huart->hdmatx->XferAbortCallback = NULL;
   \   00000004   0x6B02             LDR      R2,[R0, #+48]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6511             STR      R1,[R2, #+80]
   2193          
   2194            /* Check if an Abort process is still ongoing */
   2195            if(huart->hdmarx != NULL)
   \   0000000A   0xF100 0x0130      ADD      R1,R0,#+48
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xBF1C             ITT      NE 
   2196            {
   2197              if(huart->hdmarx->XferAbortCallback != NULL)
   \   00000014   0x6D12             LDRNE    R2,[R2, #+80]
   \   00000016   0x2A00             CMPNE    R2,#+0
   \   00000018   0x....             B.N      ?Subroutine4
   2198              {
   2199                return;
   2200              }
   2201            }
   2202          
   2203            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   2204            huart->TxXferCount = 0x00U;
   2205            huart->RxXferCount = 0x00U;
   2206          
   2207            /* Reset ErrorCode */
   2208            huart->ErrorCode = HAL_UART_ERROR_NONE;
   2209          
   2210            /* Restore huart->gState and huart->RxState to Ready */
   2211            huart->gState  = HAL_UART_STATE_READY;
   2212            huart->RxState = HAL_UART_STATE_READY;
   2213          
   2214            /* Call user Abort complete callback */
   2215            HAL_UART_AbortCpltCallback(huart);
   2216          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0xD108             BNE.N    ??Subroutine4_0
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x84C2             STRH     R2,[R0, #+38]
   \   00000006   0x85C2             STRH     R2,[R0, #+46]
   \   00000008   0x60CA             STR      R2,[R1, #+12]
   \   0000000A   0x2220             MOVS     R2,#+32
   \   0000000C   0x724A             STRB     R2,[R1, #+9]
   \   0000000E   0x728A             STRB     R2,[R1, #+10]
   \   00000010   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   \                     ??Subroutine4_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   2217          
   2218          /**
   2219            * @brief  DMA UART Rx communication abort callback, when initiated by user
   2220            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   2221            * @note   When this callback is executed, User Abort complete call back is called only if no
   2222            *         Abort still ongoing for Tx DMA Handle.
   2223            * @param  hdma DMA handle.
   2224            * @retval None
   2225            */

   \                                 In section .text, align 4, keep-with-next
   2226          static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   2227          {
   \                     UART_DMARxAbortCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2228            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2229            
   2230            huart->hdmarx->XferAbortCallback = NULL;
   \   00000004   0xF100 0x0130      ADD      R1,R0,#+48
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x684B             LDR      R3,[R1, #+4]
   \   0000000C   0x651A             STR      R2,[R3, #+80]
   2231          
   2232            /* Check if an Abort process is still ongoing */
   2233            if(huart->hdmatx != NULL)
   \   0000000E   0x6B02             LDR      R2,[R0, #+48]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xBF1C             ITT      NE 
   2234            {
   2235              if(huart->hdmatx->XferAbortCallback != NULL)
   \   00000014   0x6D12             LDRNE    R2,[R2, #+80]
   \   00000016   0x2A00             CMPNE    R2,#+0
   \   00000018                      REQUIRE ?Subroutine4
   \   00000018                      ;; // Fall through to label ?Subroutine4
   2236              {
   2237                return;
   2238              }
   2239            }
   2240            
   2241            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   2242            huart->TxXferCount = 0x00U;
   2243            huart->RxXferCount = 0x00U;
   2244          
   2245            /* Reset ErrorCode */
   2246            huart->ErrorCode = HAL_UART_ERROR_NONE;
   2247          
   2248            /* Restore huart->gState and huart->RxState to Ready */
   2249            huart->gState  = HAL_UART_STATE_READY;
   2250            huart->RxState = HAL_UART_STATE_READY;
   2251          
   2252            /* Call user Abort complete callback */
   2253            HAL_UART_AbortCpltCallback(huart);
   2254          }
   2255          
   2256          /**
   2257            * @brief  DMA UART Tx communication abort callback, when initiated by user by a call to
   2258            *         HAL_UART_AbortTransmit_IT API (Abort only Tx transfer)
   2259            *         (This callback is executed at end of DMA Tx Abort procedure following user abort request,
   2260            *         and leads to user Tx Abort Complete callback execution).
   2261            * @param  hdma DMA handle.
   2262            * @retval None
   2263            */

   \                                 In section .text, align 4, keep-with-next
   2264          static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
   2265          {
   \                     UART_DMATxOnlyAbortCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2266            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2267          
   2268            huart->TxXferCount = 0x00U;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x84C1             STRH     R1,[R0, #+38]
   2269          
   2270            /* Restore huart->gState to Ready */
   2271            huart->gState = HAL_UART_STATE_READY;
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0xF880 0x1039      STRB     R1,[R0, #+57]
   2272          
   2273            /* Call user Abort complete callback */
   2274            HAL_UART_AbortTransmitCpltCallback(huart);
   \   0000000E   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   2275          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   2276          
   2277          /**
   2278            * @brief  DMA UART Rx communication abort callback, when initiated by user by a call to
   2279            *         HAL_UART_AbortReceive_IT API (Abort only Rx transfer)
   2280            *         (This callback is executed at end of DMA Rx Abort procedure following user abort request,
   2281            *         and leads to user Rx Abort Complete callback execution).
   2282            * @param  hdma DMA handle.
   2283            * @retval None
   2284            */

   \                                 In section .text, align 4, keep-with-next
   2285          static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
   2286          {
   \                     UART_DMARxOnlyAbortCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2287            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2288          
   2289            huart->RxXferCount = 0x00U;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x85C1             STRH     R1,[R0, #+46]
   2290          
   2291            /* Restore huart->RxState to Ready */
   2292            huart->RxState = HAL_UART_STATE_READY;
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0xF880 0x103A      STRB     R1,[R0, #+58]
   2293          
   2294            /* Call user Abort complete callback */
   2295            HAL_UART_AbortReceiveCpltCallback(huart);
   \   0000000E   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   2296          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   2297          
   2298          /**
   2299            * @brief  Sends an amount of data in non blocking mode.
   2300            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   2301            *                the configuration information for the specified UART module.
   2302            * @retval HAL status
   2303            */
   2304          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   2305          {
   2306            uint16_t* tmp;
   2307            
   2308            /* Check that a Tx process is ongoing */
   2309            if(huart->gState == HAL_UART_STATE_BUSY_TX)
   2310            {
   2311              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   2312              {
   2313                tmp = (uint16_t*) huart->pTxBuffPtr;
   2314                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
   2315                if(huart->Init.Parity == UART_PARITY_NONE)
   2316                {
   2317                  huart->pTxBuffPtr += 2U;
   2318                }
   2319                else
   2320                {
   2321                  huart->pTxBuffPtr += 1U;
   2322                }
   2323              } 
   2324              else
   2325              {
   2326                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
   2327              }
   2328          
   2329              if(--huart->TxXferCount == 0U)
   2330              {
   2331                /* Disable the UART Transmit Complete Interrupt */
   2332                CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
   2333          
   2334                /* Enable the UART Transmit Complete Interrupt */    
   2335                SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   2336              }
   2337              return HAL_OK;
   2338            }
   2339            else
   2340            {
   2341              return HAL_BUSY;
   2342            }
   2343          }
   2344          
   2345          /**
   2346            * @brief  Wraps up transmission in non blocking mode.
   2347            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   2348            *                the configuration information for the specified UART module.
   2349            * @retval HAL status
   2350            */
   2351          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   2352          {
   2353            /* Disable the UART Transmit Complete Interrupt */    
   2354            CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   2355            
   2356            /* Tx process is ended, restore huart->gState to Ready */
   2357            huart->gState = HAL_UART_STATE_READY;
   2358              
   2359            HAL_UART_TxCpltCallback(huart);
   2360            
   2361            return HAL_OK;
   2362          }
   2363          
   2364          /**
   2365            * @brief  Receives an amount of data in non blocking mode 
   2366            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   2367            *                the configuration information for the specified UART module.
   2368            * @retval HAL status
   2369            */

   \                                 In section .text, align 2, keep-with-next
   2370          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   2371          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2372            uint16_t* tmp;
   2373            
   2374            /* Check that a Rx process is ongoing */
   2375            if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
   \   00000002   0xF890 0x103A      LDRB     R1,[R0, #+58]
   \   00000006   0x2922             CMP      R1,#+34
   \   00000008   0xD137             BNE.N    ??UART_Receive_IT_0
   2376            {
   2377              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000000A   0x6881             LDR      R1,[R0, #+8]
   \   0000000C   0xF5B1 0x5F80      CMP      R1,#+4096
   \   00000010   0xD111             BNE.N    ??UART_Receive_IT_1
   2378              {
   2379                tmp = (uint16_t*) huart->pRxBuffPtr;
   2380                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000012   0x6902             LDR      R2,[R0, #+16]
   \   00000014   0x6A81             LDR      R1,[R0, #+40]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0x6852             LDR      R2,[R2, #+4]
   \   0000001C   0xD105             BNE.N    ??UART_Receive_IT_2
   2381                {
   2382                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   0000001E   0x05D2             LSLS     R2,R2,#+23
   \   00000020   0x0DD2             LSRS     R2,R2,#+23
   \   00000022   0x800A             STRH     R2,[R1, #+0]
   2383                  huart->pRxBuffPtr += 2U;
   \   00000024   0x6A81             LDR      R1,[R0, #+40]
   \   00000026   0x1C89             ADDS     R1,R1,#+2
   \   00000028   0xE003             B.N      ??UART_Receive_IT_3
   2384                }
   2385                else
   2386                {
   2387                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??UART_Receive_IT_2: (+1)
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x800A             STRH     R2,[R1, #+0]
   2388                  huart->pRxBuffPtr += 1U;
   \   0000002E   0x6A81             LDR      R1,[R0, #+40]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \                     ??UART_Receive_IT_3: (+1)
   \   00000032   0x6281             STR      R1,[R0, #+40]
   \   00000034   0xE00F             B.N      ??UART_Receive_IT_4
   2389                }
   2390              }
   2391              else
   2392              {
   2393                if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_1: (+1)
   \   00000036   0x6901             LDR      R1,[R0, #+16]
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0x6A81             LDR      R1,[R0, #+40]
   \   0000003C   0xD104             BNE.N    ??UART_Receive_IT_5
   2394                {
   2395                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   0000003E   0x1C4A             ADDS     R2,R1,#+1
   \   00000040   0x6282             STR      R2,[R0, #+40]
   \   00000042   0x6802             LDR      R2,[R0, #+0]
   \   00000044   0x6852             LDR      R2,[R2, #+4]
   \   00000046   0xE005             B.N      ??UART_Receive_IT_6
   2396                }
   2397                else
   2398                {
   2399                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??UART_Receive_IT_5: (+1)
   \   00000048   0x1C4A             ADDS     R2,R1,#+1
   \   0000004A   0x6282             STR      R2,[R0, #+40]
   \   0000004C   0x6802             LDR      R2,[R0, #+0]
   \   0000004E   0x6852             LDR      R2,[R2, #+4]
   \   00000050   0xF002 0x027F      AND      R2,R2,#0x7F
   \                     ??UART_Receive_IT_6: (+1)
   \   00000054   0x700A             STRB     R2,[R1, #+0]
   2400                }
   2401              }
   2402          
   2403              if(--huart->RxXferCount == 0U)
   \                     ??UART_Receive_IT_4: (+1)
   \   00000056   0x8DC1             LDRH     R1,[R0, #+46]
   \   00000058   0x1E49             SUBS     R1,R1,#+1
   \   0000005A   0x85C1             STRH     R1,[R0, #+46]
   \   0000005C   0xB289             UXTH     R1,R1
   \   0000005E   0xB951             CBNZ.N   R1,??UART_Receive_IT_7
   2404              {
   2405                /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
   2406                CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x68CA             LDR      R2,[R1, #+12]
   \   00000064   0xF422 0x7290      BIC      R2,R2,#0x120
   \   00000068   0x.... 0x....      BL       ?Subroutine13
   2407          
   2408                /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   2409                CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   2410          
   2411                /* Rx process is completed, restore huart->RxState to Ready */
   2412                huart->RxState = HAL_UART_STATE_READY;
   \                     ??CrossCallReturnLabel_25: (+1)
   \   0000006C   0x2120             MOVS     R1,#+32
   \   0000006E   0xF880 0x103A      STRB     R1,[R0, #+58]
   2413               
   2414                HAL_UART_RxCpltCallback(huart);
   \   00000072   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   2415          
   2416                return HAL_OK;
   2417              }
   2418              return HAL_OK;
   \                     ??UART_Receive_IT_7: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xBD02             POP      {R1,PC}
   2419            }
   2420            else
   2421            {
   2422              return HAL_BUSY;
   \                     ??UART_Receive_IT_0: (+1)
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0xBD02             POP      {R1,PC}          ;; return
   2423            }
   2424          }
   2425          
   2426          /**
   2427            * @brief  Configures the UART peripheral. 
   2428            * @param  huart pointer to a UART_HandleTypeDef structure that contains
   2429            *                the configuration information for the specified UART module.
   2430            * @retval None
   2431            */

   \                                 In section .text, align 2, keep-with-next
   2432          static void UART_SetConfig(UART_HandleTypeDef *huart)
   2433          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x2564             MOVS     R5,#+100
   2434            uint32_t tmpreg = 0x00U;
   2435            
   2436            /* Check the parameters */
   2437            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
   2438            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   2439            assert_param(IS_UART_PARITY(huart->Init.Parity));
   2440            assert_param(IS_UART_MODE(huart->Init.Mode));
   2441          
   2442            /*-------------------------- USART CR2 Configuration -----------------------*/
   2443            tmpreg = huart->Instance->CR2;
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6901             LDR      R1,[R0, #+16]
   2444          
   2445            /* Clear STOP[13:12] bits */
   2446            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
   2447          
   2448            /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
   2449            tmpreg |= (uint32_t)huart->Init.StopBits;
   2450            
   2451            /* Write to USART CR2 */
   2452            WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
   \   0000000C   0x68E2             LDR      R2,[R4, #+12]
   \   0000000E   0xF421 0x5140      BIC      R1,R1,#0x3000
   \   00000012   0x4311             ORRS     R1,R2,R1
   \   00000014   0x6101             STR      R1,[R0, #+16]
   \   00000016   0x2619             MOVS     R6,#+25
   2453          
   2454            /*-------------------------- USART CR1 Configuration -----------------------*/
   2455            tmpreg = huart->Instance->CR1;
   \   00000018   0x68C1             LDR      R1,[R0, #+12]
   2456          
   2457            /* Clear M, PCE, PS, TE and RE bits */
   2458            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
   2459                                             USART_CR1_RE | USART_CR1_OVER8));
   2460          
   2461            /* Configure the UART Word Length, Parity and mode: 
   2462               Set the M bits according to huart->Init.WordLength value 
   2463               Set PCE and PS bits according to huart->Init.Parity value
   2464               Set TE and RE bits according to huart->Init.Mode value
   2465               Set OVER8 bit according to huart->Init.OverSampling value */
   2466            tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
   2467            
   2468            /* Write to USART CR1 */
   2469            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \   0000001A   0x....             LDR.N    R2,??DataTable0  ;; 0xffff69f3
   \   0000001C   0x4011             ANDS     R1,R2,R1
   \   0000001E   0x68A2             LDR      R2,[R4, #+8]
   \   00000020   0x4311             ORRS     R1,R2,R1
   \   00000022   0x6922             LDR      R2,[R4, #+16]
   \   00000024   0x4311             ORRS     R1,R2,R1
   \   00000026   0x6962             LDR      R2,[R4, #+20]
   \   00000028   0x4311             ORRS     R1,R2,R1
   \   0000002A   0x69E2             LDR      R2,[R4, #+28]
   \   0000002C   0x4311             ORRS     R1,R2,R1
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
   2470            
   2471            /*-------------------------- USART CR3 Configuration -----------------------*/  
   2472            tmpreg = huart->Instance->CR3;
   \   00000030   0x6941             LDR      R1,[R0, #+20]
   2473            
   2474            /* Clear CTSE and RTSE bits */
   2475            tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
   2476            
   2477            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   2478            tmpreg |= huart->Init.HwFlowCtl;
   2479            
   2480            /* Write to USART CR3 */
   2481            WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
   \   00000032   0x69A2             LDR      R2,[R4, #+24]
   \   00000034   0xF421 0x7140      BIC      R1,R1,#0x300
   \   00000038   0x4311             ORRS     R1,R2,R1
   \   0000003A   0x6141             STR      R1,[R0, #+20]
   2482            
   2483            /* Check the Over Sampling */
   2484            if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \   0000003C   0x69E3             LDR      R3,[R4, #+28]
   \   0000003E   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40011400
   \   00000040   0x....             LDR.N    R2,??DataTable0_2  ;; 0x40011000
   \   00000042   0xF5B3 0x4F00      CMP      R3,#+32768
   \   00000046   0xD14F             BNE.N    ??UART_SetConfig_0
   2485            {
   2486              /*-------------------------- USART BRR Configuration ---------------------*/
   2487          #if defined(USART6) 
   2488              if((huart->Instance == USART1) || (huart->Instance == USART6))
   \   00000048   0x4290             CMP      R0,R2
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0x4288             CMPNE    R0,R1
   \   0000004E   0xD10E             BNE.N    ??UART_SetConfig_1
   2489              {
   2490                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   00000050   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000054   0x4607             MOV      R7,R0
   \   00000056   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000005A   0x4680             MOV      R8,R0
   \   0000005C   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000060   0x4681             MOV      R9,R0
   \   00000062   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000066   0x4682             MOV      R10,R0
   \   00000068   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000006C   0xE00D             B.N      ??UART_SetConfig_2
   2491              }
   2492          #else
   2493              if(huart->Instance == USART1)
   2494              {
   2495                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   2496              }	
   2497          #endif /* USART6 */
   2498              else
   2499              {
   2500                huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_1: (+1)
   \   0000006E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000072   0x4607             MOV      R7,R0
   \   00000074   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000078   0x4680             MOV      R8,R0
   \   0000007A   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000007E   0x4681             MOV      R9,R0
   \   00000080   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000084   0x4682             MOV      R10,R0
   \   00000086   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \                     ??UART_SetConfig_2: (+1)
   \   0000008A   0x6861             LDR      R1,[R4, #+4]
   \   0000008C   0xFB06 0xF207      MUL      R2,R6,R7
   \   00000090   0x0049             LSLS     R1,R1,#+1
   \   00000092   0xFB06 0xF709      MUL      R7,R6,R9
   \   00000096   0xFB06 0xF308      MUL      R3,R6,R8
   \   0000009A   0xFBB7 0xF7F1      UDIV     R7,R7,R1
   \   0000009E   0xFBB3 0xF3F1      UDIV     R3,R3,R1
   \   000000A2   0xFBB7 0xF7F5      UDIV     R7,R7,R5
   \   000000A6   0xFB05 0x3317      MLS      R3,R5,R7,R3
   \   000000AA   0x00DB             LSLS     R3,R3,#+3
   \   000000AC   0x3332             ADDS     R3,R3,#+50
   \   000000AE   0xFBB3 0xF3F5      UDIV     R3,R3,R5
   \   000000B2   0xFBB2 0xF2F1      UDIV     R2,R2,R1
   \   000000B6   0xF003 0x03F8      AND      R3,R3,#0xF8
   \   000000BA   0xFBB2 0xF2F5      UDIV     R2,R2,R5
   \   000000BE   0x005B             LSLS     R3,R3,#+1
   \   000000C0   0xEB03 0x1202      ADD      R2,R3,R2, LSL #+4
   \   000000C4   0x4370             MULS     R0,R6,R0
   \   000000C6   0xFB06 0xF30A      MUL      R3,R6,R10
   \   000000CA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000CE   0xFBB3 0xF3F1      UDIV     R3,R3,R1
   \   000000D2   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   000000D6   0xFB05 0x3010      MLS      R0,R5,R0,R3
   \   000000DA   0x00C0             LSLS     R0,R0,#+3
   \   000000DC   0x3032             ADDS     R0,R0,#+50
   \   000000DE   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   000000E2   0xF000 0x0007      AND      R0,R0,#0x7
   \   000000E6   0xE04D             B.N      ??UART_SetConfig_3
   2501              }
   2502            }
   2503            else
   2504            {
   2505              /*-------------------------- USART BRR Configuration ---------------------*/
   2506          #if defined(USART6) 
   2507              if((huart->Instance == USART1) || (huart->Instance == USART6))
   \                     ??UART_SetConfig_0: (+1)
   \   000000E8   0x4290             CMP      R0,R2
   \   000000EA   0xBF18             IT       NE 
   \   000000EC   0x4288             CMPNE    R0,R1
   \   000000EE   0xD10E             BNE.N    ??UART_SetConfig_4
   2508              {
   2509                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   000000F0   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000000F4   0x4607             MOV      R7,R0
   \   000000F6   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   000000FA   0x4680             MOV      R8,R0
   \   000000FC   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000100   0x4681             MOV      R9,R0
   \   00000102   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000106   0x4682             MOV      R10,R0
   \   00000108   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000010C   0xE00D             B.N      ??UART_SetConfig_5
   2510              }
   2511          #else
   2512              if(huart->Instance == USART1)
   2513              {
   2514                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   2515              }	
   2516          #endif /* USART6 */
   2517              else
   2518              {
   2519                huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_4: (+1)
   \   0000010E   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000112   0x4607             MOV      R7,R0
   \   00000114   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000118   0x4680             MOV      R8,R0
   \   0000011A   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   0000011E   0x4681             MOV      R9,R0
   \   00000120   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000124   0x4682             MOV      R10,R0
   \   00000126   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \                     ??UART_SetConfig_5: (+1)
   \   0000012A   0x6861             LDR      R1,[R4, #+4]
   \   0000012C   0xFB06 0xF207      MUL      R2,R6,R7
   \   00000130   0x0089             LSLS     R1,R1,#+2
   \   00000132   0xFB06 0xF709      MUL      R7,R6,R9
   \   00000136   0xFB06 0xF308      MUL      R3,R6,R8
   \   0000013A   0xFBB7 0xF7F1      UDIV     R7,R7,R1
   \   0000013E   0xFBB3 0xF3F1      UDIV     R3,R3,R1
   \   00000142   0xFBB7 0xF7F5      UDIV     R7,R7,R5
   \   00000146   0xFB05 0x3317      MLS      R3,R5,R7,R3
   \   0000014A   0x011B             LSLS     R3,R3,#+4
   \   0000014C   0x3332             ADDS     R3,R3,#+50
   \   0000014E   0xFBB2 0xF2F1      UDIV     R2,R2,R1
   \   00000152   0xFBB3 0xF3F5      UDIV     R3,R3,R5
   \   00000156   0xFBB2 0xF2F5      UDIV     R2,R2,R5
   \   0000015A   0xF003 0x03F0      AND      R3,R3,#0xF0
   \   0000015E   0xEB03 0x1202      ADD      R2,R3,R2, LSL #+4
   \   00000162   0x4370             MULS     R0,R6,R0
   \   00000164   0xFB06 0xF30A      MUL      R3,R6,R10
   \   00000168   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000016C   0xFBB3 0xF3F1      UDIV     R3,R3,R1
   \   00000170   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000174   0xFB05 0x3010      MLS      R0,R5,R0,R3
   \   00000178   0x0100             LSLS     R0,R0,#+4
   \   0000017A   0x3032             ADDS     R0,R0,#+50
   \   0000017C   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000180   0xF000 0x000F      AND      R0,R0,#0xF
   \                     ??UART_SetConfig_3: (+1)
   \   00000184   0x6821             LDR      R1,[R4, #+0]
   \   00000186   0x1880             ADDS     R0,R0,R2
   \   00000188   0x6088             STR      R0,[R1, #+8]
   2520              }
   2521            }
   2522          }
   \   0000018A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xFFFF69F3         DC32     0xffff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40011000         DC32     0x40011000
   2523          
   2524          /**
   2525            * @}
   2526            */
   2527          
   2528          #endif /* HAL_UART_MODULE_ENABLED */
   2529          /**
   2530            * @}
   2531            */
   2532          
   2533          /**
   2534            * @}
   2535            */
   2536          
   2537          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       8   HAL_UART_Abort
         8   -> HAL_DMA_Abort
       0   HAL_UART_AbortCpltCallback
       8   HAL_UART_AbortReceive
         8   -> HAL_DMA_Abort
       0   HAL_UART_AbortReceiveCpltCallback
       8   HAL_UART_AbortReceive_IT
         8   -- Indirect call
         8   -> HAL_DMA_Abort_IT
         8   -> HAL_UART_AbortReceiveCpltCallback
       8   HAL_UART_AbortTransmit
         8   -> HAL_DMA_Abort
       0   HAL_UART_AbortTransmitCpltCallback
       8   HAL_UART_AbortTransmit_IT
         8   -- Indirect call
         8   -> HAL_DMA_Abort_IT
         8   -> HAL_UART_AbortTransmitCpltCallback
      16   HAL_UART_Abort_IT
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_UART_AbortCpltCallback
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
         8   -> UART_EndRxTransfer
         8   -> UART_EndTxTransfer
      16   HAL_UART_DeInit
        16   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      16   HAL_UART_IRQHandler
         0   -- Indirect call
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_UART_ErrorCallback
        16   -> HAL_UART_TxCpltCallback
        16   -> UART_EndRxTransfer
         0   -> UART_Receive_IT
        16   -> UART_Receive_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      32   HAL_UART_Receive
        32   -> HAL_GetTick
        32   -> UART_WaitOnFlagUntilTimeout
      16   HAL_UART_Receive_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      32   HAL_UART_Transmit
        32   -> HAL_GetTick
        32   -> UART_WaitOnFlagUntilTimeout
       8   HAL_UART_Transmit_DMA
         8   -> HAL_DMA_Start_IT
       0   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
       8   UART_DMAAbortOnError
         8   -> HAL_UART_ErrorCallback
       8   UART_DMAError
         8   -> HAL_UART_ErrorCallback
         8   -> UART_EndRxTransfer
         8   -> UART_EndTxTransfer
       8   UART_DMAReceiveCplt
         8   -> HAL_UART_RxCpltCallback
       8   UART_DMARxAbortCallback
         8   -> HAL_UART_AbortCpltCallback
       8   UART_DMARxHalfCplt
         8   -> HAL_UART_RxHalfCpltCallback
       8   UART_DMARxOnlyAbortCallback
         8   -> HAL_UART_AbortReceiveCpltCallback
       8   UART_DMATransmitCplt
         8   -> HAL_UART_TxCpltCallback
       8   UART_DMATxAbortCallback
         8   -> HAL_UART_AbortCpltCallback
       8   UART_DMATxHalfCplt
         8   -> HAL_UART_TxHalfCpltCallback
       8   UART_DMATxOnlyAbortCallback
         8   -> HAL_UART_AbortTransmitCpltCallback
       0   UART_EndRxTransfer
       0   UART_EndTxTransfer
       8   UART_Receive_IT
         8   -> HAL_UART_RxCpltCallback
      32   UART_SetConfig
        32   -> HAL_RCC_GetPCLK1Freq
        32   -> HAL_RCC_GetPCLK2Freq
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       8  ??Subroutine14_0
      10  ??Subroutine15_0
      22  ?Subroutine0
       8  ?Subroutine1
      10  ?Subroutine10
      10  ?Subroutine11
      12  ?Subroutine12
      14  ?Subroutine13
       8  ?Subroutine2
       6  ?Subroutine3
      22  ?Subroutine4
      22  ?Subroutine5
      10  ?Subroutine6
       8  ?Subroutine7
      12  ?Subroutine8
      12  ?Subroutine9
      38  HAL_HalfDuplex_EnableReceiver
      38  HAL_HalfDuplex_EnableTransmitter
      56  HAL_HalfDuplex_Init
     106  HAL_LIN_Init
      34  HAL_LIN_SendBreak
      32  HAL_MultiProcessor_EnterMuteMode
      34  HAL_MultiProcessor_ExitMuteMode
     116  HAL_MultiProcessor_Init
      88  HAL_UART_Abort
       2  HAL_UART_AbortCpltCallback
      56  HAL_UART_AbortReceive
       2  HAL_UART_AbortReceiveCpltCallback
      80  HAL_UART_AbortReceive_IT
      44  HAL_UART_AbortTransmit
       2  HAL_UART_AbortTransmitCpltCallback
      70  HAL_UART_AbortTransmit_IT
     166  HAL_UART_Abort_IT
      88  HAL_UART_DMAPause
     102  HAL_UART_DMAResume
      72  HAL_UART_DMAStop
      38  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
      12  HAL_UART_GetState
     328  HAL_UART_IRQHandler
      48  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     176  HAL_UART_Receive
     156  HAL_UART_Receive_DMA
      80  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     168  HAL_UART_Transmit
     128  HAL_UART_Transmit_DMA
      70  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      16  UART_DMAAbortOnError
      72  UART_DMAError
      52  UART_DMAReceiveCplt
      24  UART_DMARxAbortCallback
      10  UART_DMARxHalfCplt
      20  UART_DMARxOnlyAbortCallback
      46  UART_DMATransmitCplt
      26  UART_DMATxAbortCallback
      10  UART_DMATxHalfCplt
      20  UART_DMATxOnlyAbortCallback
      28  UART_EndRxTransfer
      18  UART_EndTxTransfer
     126  UART_Receive_IT
     398  UART_SetConfig
      96  UART_WaitOnFlagUntilTimeout

 
 3 616 bytes in section .text
 
 3 616 bytes of CODE memory

Errors: none
Warnings: none
