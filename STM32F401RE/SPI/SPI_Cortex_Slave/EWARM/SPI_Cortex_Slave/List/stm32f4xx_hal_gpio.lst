###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
#    Command line =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
#        -D USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\stm32f4xx_hal_gpio.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\stm32f4xx_hal_gpio.o
#
###############################################################################

C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                              ##### GPIO Peripheral features #####
     14            ==============================================================================
     15            [..] 
     16            Subject to the specific hardware characteristics of each I/O port listed in the datasheet, each
     17            port bit of the General Purpose IO (GPIO) Ports, can be individually configured by software
     18            in several modes:
     19            (+) Input mode 
     20            (+) Analog mode
     21            (+) Output mode
     22            (+) Alternate function mode
     23            (+) External interrupt/event lines
     24          
     25            [..]  
     26            During and just after reset, the alternate functions and external interrupt  
     27            lines are not active and the I/O ports are configured in input floating mode.
     28            
     29            [..]   
     30            All GPIO pins have weak internal pull-up and pull-down resistors, which can be 
     31            activated or not.
     32          
     33            [..]
     34            In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     35            type and the IO speed can be selected depending on the VDD value.
     36          
     37            [..]  
     38            All ports have external interrupt/event capability. To use external interrupt 
     39            lines, the port must be configured in input mode. All available GPIO pins are 
     40            connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     41            
     42            [..]
     43            The external interrupt/event controller consists of up to 23 edge detectors 
     44            (16 lines are connected to GPIO) for generating event/interrupt requests (each 
     45            input line can be independently configured to select the type (interrupt or event) 
     46            and the corresponding trigger event (rising or falling or both). Each line can 
     47            also be masked independently. 
     48          
     49                               ##### How to use this driver #####
     50            ==============================================================================  
     51            [..]
     52              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE(). 
     53          
     54              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     55                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     56                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef 
     57                       structure.
     58                  (++) In case of Output or alternate function mode selection: the speed is 
     59                       configured through "Speed" member from GPIO_InitTypeDef structure.
     60                  (++) In alternate mode is selection, the alternate function connected to the IO
     61                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     62                  (++) Analog mode is required when a pin is to be used as ADC channel 
     63                       or DAC output.
     64                  (++) In case of external interrupt/event selection the "Mode" member from 
     65                       GPIO_InitTypeDef structure select the type (interrupt or event) and 
     66                       the corresponding trigger event (rising or falling or both).
     67          
     68              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority 
     69                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     70                  HAL_NVIC_EnableIRQ().
     71                   
     72              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     73                      
     74              (#) To set/reset the level of a pin configured in output mode use 
     75                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     76              
     77              (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     78          
     79                           
     80              (#) During and just after reset, the alternate functions are not 
     81                  active and the GPIO pins are configured in input floating mode (except JTAG
     82                  pins).
     83            
     84              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     85                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     86                  priority over the GPIO function.
     87            
     88              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     89                  general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     90                  The HSE has priority over the GPIO function.
     91            
     92            @endverbatim
     93            ******************************************************************************
     94            * @attention
     95            *
     96            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
     97            *
     98            * Redistribution and use in source and binary forms, with or without modification,
     99            * are permitted provided that the following conditions are met:
    100            *   1. Redistributions of source code must retain the above copyright notice,
    101            *      this list of conditions and the following disclaimer.
    102            *   2. Redistributions in binary form must reproduce the above copyright notice,
    103            *      this list of conditions and the following disclaimer in the documentation
    104            *      and/or other materials provided with the distribution.
    105            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    106            *      may be used to endorse or promote products derived from this software
    107            *      without specific prior written permission.
    108            *
    109            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    110            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    111            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    112            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    113            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    114            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    115            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    116            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    117            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    118            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    119            *
    120            ******************************************************************************
    121            */ 
    122          
    123          /* Includes ------------------------------------------------------------------*/
    124          #include "stm32f4xx_hal.h"
    125          
    126          /** @addtogroup STM32F4xx_HAL_Driver
    127            * @{
    128            */
    129          
    130          /** @defgroup GPIO GPIO
    131            * @brief GPIO HAL module driver
    132            * @{
    133            */
    134          
    135          #ifdef HAL_GPIO_MODULE_ENABLED
    136          
    137          /* Private typedef -----------------------------------------------------------*/
    138          /* Private define ------------------------------------------------------------*/
    139          /** @addtogroup GPIO_Private_Constants GPIO Private Constants
    140            * @{
    141            */
    142          #define GPIO_MODE             0x00000003U
    143          #define EXTI_MODE             0x10000000U
    144          #define GPIO_MODE_IT          0x00010000U
    145          #define GPIO_MODE_EVT         0x00020000U
    146          #define RISING_EDGE           0x00100000U
    147          #define FALLING_EDGE          0x00200000U
    148          #define GPIO_OUTPUT_TYPE      0x00000010U
    149          
    150          #define GPIO_NUMBER           16U
    151          /**
    152            * @}
    153            */
    154          /* Private macro -------------------------------------------------------------*/
    155          /* Private variables ---------------------------------------------------------*/
    156          /* Private function prototypes -----------------------------------------------*/
    157          /* Private functions ---------------------------------------------------------*/
    158          /* Exported functions --------------------------------------------------------*/
    159          /** @defgroup GPIO_Exported_Functions GPIO Exported Functions
    160            * @{
    161            */
    162          
    163          /** @defgroup GPIO_Exported_Functions_Group1 Initialization and de-initialization functions
    164            *  @brief    Initialization and Configuration functions
    165            *
    166          @verbatim    
    167           ===============================================================================
    168                        ##### Initialization and de-initialization functions #####
    169           ===============================================================================
    170            [..]
    171              This section provides functions allowing to initialize and de-initialize the GPIOs
    172              to be ready for use.
    173           
    174          @endverbatim
    175            * @{
    176            */
    177          
    178          
    179          /**
    180            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    181            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    182            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    183            * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
    184            *         the configuration information for the specified GPIO peripheral.
    185            * @retval None
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    188          {
   \                     HAL_GPIO_Init: (+1)
   \   00000000   0xE92D 0x47F8      PUSH     {R3-R10,LR}
    189            uint32_t position;
    190            uint32_t ioposition = 0x00U;
    191            uint32_t iocurrent = 0x00U;
    192            uint32_t temp = 0x00U;
    193          
    194            /* Check the parameters */
    195            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    196            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    197            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    198            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    199          
    200            /* Configure the port pins */
    201            for(position = 0U; position < GPIO_NUMBER; position++)
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             LDR.N    R3,??DataTable2  ;; 0x40013c00
   \   00000008   0x.... 0x....      LDR.W    R8,??DataTable2_1  ;; 0x40013808
   \   0000000C   0x.... 0x....      LDR.W    R9,??DataTable2_2  ;; 0x40023844
   \   00000010   0xF04F 0x0A0F      MOV      R10,#+15
    202            {
    203              /* Get the IO position */
    204              ioposition = 0x01U << position;
   \                     ??HAL_GPIO_Init_0: (+1)
   \   00000014   0x2701             MOVS     R7,#+1
   \   00000016   0xFA07 0xFC02      LSL      R12,R7,R2
    205              /* Get the current IO position */
    206              iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
   \   0000001A   0x680F             LDR      R7,[R1, #+0]
   \   0000001C   0xEA0C 0x0707      AND      R7,R12,R7
    207          
    208              if(iocurrent == ioposition)
   \   00000020   0x4567             CMP      R7,R12
   \   00000022   0xF040 0x80A8      BNE.W    ??HAL_GPIO_Init_1
    209              {
    210                /*--------------------- GPIO Mode Configuration ------------------------*/
    211                /* In case of Alternate function mode selection */
    212                if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \   00000026   0x684C             LDR      R4,[R1, #+4]
   \   00000028   0x2C02             CMP      R4,#+2
   \   0000002A   0xBF18             IT       NE 
   \   0000002C   0x2C12             CMPNE    R4,#+18
   \   0000002E   0xD110             BNE.N    ??HAL_GPIO_Init_2
   \   00000030   0x08D4             LSRS     R4,R2,#+3
   \   00000032   0xEB00 0x0E84      ADD      LR,R0,R4, LSL #+2
    213                {
    214                  /* Check the Alternate function parameter */
    215                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    216                  /* Configure Alternate function mapped with the current IO */
    217                  temp = GPIOx->AFR[position >> 3U];
    218                  temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
    219                  temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
    220                  GPIOx->AFR[position >> 3U] = temp;
   \   00000036   0xF002 0x0407      AND      R4,R2,#0x7
   \   0000003A   0xF8DE 0x5020      LDR      R5,[LR, #+32]
   \   0000003E   0x00A4             LSLS     R4,R4,#+2
   \   00000040   0xFA0A 0xF604      LSL      R6,R10,R4
   \   00000044   0x43B5             BICS     R5,R5,R6
   \   00000046   0x690E             LDR      R6,[R1, #+16]
   \   00000048   0xFA06 0xF404      LSL      R4,R6,R4
   \   0000004C   0x432C             ORRS     R4,R4,R5
   \   0000004E   0xF8CE 0x4020      STR      R4,[LR, #+32]
   \                     ??HAL_GPIO_Init_2: (+1)
   \   00000052   0xEA4F 0x0E42      LSL      LR,R2,#+1
    221                }
    222          
    223                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    224                temp = GPIOx->MODER;
   \   00000056   0x6805             LDR      R5,[R0, #+0]
    225                temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
    226                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
    227                GPIOx->MODER = temp;
   \   00000058   0x790E             LDRB     R6,[R1, #+4]
   \   0000005A   0x2403             MOVS     R4,#+3
   \   0000005C   0xFA04 0xF40E      LSL      R4,R4,LR
   \   00000060   0x43E4             MVNS     R4,R4
   \   00000062   0xF006 0x0603      AND      R6,R6,#0x3
   \   00000066   0x4025             ANDS     R5,R4,R5
   \   00000068   0xFA06 0xF60E      LSL      R6,R6,LR
   \   0000006C   0x4335             ORRS     R5,R6,R5
   \   0000006E   0x6005             STR      R5,[R0, #+0]
    228          
    229                /* In case of Output or Alternate function mode selection */
    230                if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    231                   (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \   00000070   0x684D             LDR      R5,[R1, #+4]
   \   00000072   0x2D01             CMP      R5,#+1
   \   00000074   0xBF18             IT       NE 
   \   00000076   0x2D02             CMPNE    R5,#+2
   \   00000078   0xD003             BEQ.N    ??HAL_GPIO_Init_3
   \   0000007A   0x2D11             CMP      R5,#+17
   \   0000007C   0xBF18             IT       NE 
   \   0000007E   0x2D12             CMPNE    R5,#+18
   \   00000080   0xD10F             BNE.N    ??HAL_GPIO_Init_4
    232                {
    233                  /* Check the Speed parameter */
    234                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    235                  /* Configure the IO Speed */
    236                  temp = GPIOx->OSPEEDR; 
   \                     ??HAL_GPIO_Init_3: (+1)
   \   00000082   0x6885             LDR      R5,[R0, #+8]
    237                  temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
    238                  temp |= (GPIO_Init->Speed << (position * 2U));
    239                  GPIOx->OSPEEDR = temp;
   \   00000084   0x68CE             LDR      R6,[R1, #+12]
   \   00000086   0x4025             ANDS     R5,R4,R5
   \   00000088   0xFA06 0xF60E      LSL      R6,R6,LR
   \   0000008C   0x4335             ORRS     R5,R6,R5
   \   0000008E   0x6085             STR      R5,[R0, #+8]
    240          
    241                  /* Configure the IO Output Type */
    242                  temp = GPIOx->OTYPER;
   \   00000090   0x6845             LDR      R5,[R0, #+4]
    243                  temp &= ~(GPIO_OTYPER_OT_0 << position) ;
    244                  temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
    245                  GPIOx->OTYPER = temp;
   \   00000092   0xEA25 0x060C      BIC      R6,R5,R12
   \   00000096   0x684D             LDR      R5,[R1, #+4]
   \   00000098   0xF3C5 0x1500      UBFX     R5,R5,#+4,#+1
   \   0000009C   0x4095             LSLS     R5,R5,R2
   \   0000009E   0x4335             ORRS     R5,R5,R6
   \   000000A0   0x6045             STR      R5,[R0, #+4]
    246                }
    247          
    248                /* Activate the Pull-up or Pull down resistor for the current IO */
    249                temp = GPIOx->PUPDR;
   \                     ??HAL_GPIO_Init_4: (+1)
   \   000000A2   0x68C5             LDR      R5,[R0, #+12]
    250                temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
    251                temp |= ((GPIO_Init->Pull) << (position * 2U));
    252                GPIOx->PUPDR = temp;
   \   000000A4   0x4025             ANDS     R5,R4,R5
   \   000000A6   0x688C             LDR      R4,[R1, #+8]
   \   000000A8   0xFA04 0xFE0E      LSL      LR,R4,LR
   \   000000AC   0xEA4E 0x0405      ORR      R4,LR,R5
   \   000000B0   0x60C4             STR      R4,[R0, #+12]
    253          
    254                /*--------------------- EXTI Mode Configuration ------------------------*/
    255                /* Configure the External Interrupt or event for the current IO */
    256                if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
   \   000000B2   0x684C             LDR      R4,[R1, #+4]
   \   000000B4   0x00E4             LSLS     R4,R4,#+3
   \   000000B6   0xD55E             BPL.N    ??HAL_GPIO_Init_1
    257                {
    258                  /* Enable SYSCFG Clock */
    259                  __HAL_RCC_SYSCFG_CLK_ENABLE();
   \   000000B8   0x2400             MOVS     R4,#+0
   \   000000BA   0x9400             STR      R4,[SP, #+0]
   \   000000BC   0xEA4F 0x0C92      LSR      R12,R2,#+2
   \   000000C0   0xF8D9 0x4000      LDR      R4,[R9, #+0]
   \   000000C4   0xF444 0x4480      ORR      R4,R4,#0x4000
   \   000000C8   0xF8C9 0x4000      STR      R4,[R9, #+0]
   \   000000CC   0xF002 0x0503      AND      R5,R2,#0x3
   \   000000D0   0xF8D9 0x4000      LDR      R4,[R9, #+0]
   \   000000D4   0xF404 0x4480      AND      R4,R4,#0x4000
   \   000000D8   0x9400             STR      R4,[SP, #+0]
   \   000000DA   0x00AE             LSLS     R6,R5,#+2
   \   000000DC   0x9C00             LDR      R4,[SP, #+0]
   \   000000DE   0xF858 0x402C      LDR      R4,[R8, R12, LSL #+2]
    260          
    261                  temp = SYSCFG->EXTICR[position >> 2U];
    262                  temp &= ~(0x0FU << (4U * (position & 0x03U)));
   \   000000E2   0xFA0A 0xF506      LSL      R5,R10,R6
   \   000000E6   0x43AC             BICS     R4,R4,R5
    263                  temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
   \   000000E8   0x....             LDR.N    R5,??DataTable2_3  ;; 0x40020000
   \   000000EA   0x42A8             CMP      R0,R5
   \   000000EC   0xBF08             IT       EQ 
   \   000000EE   0x2500             MOVEQ    R5,#+0
   \   000000F0   0xD013             BEQ.N    ??HAL_GPIO_Init_5
   \   000000F2   0x....             LDR.N    R5,??DataTable2_4  ;; 0x40020400
   \   000000F4   0x42A8             CMP      R0,R5
   \   000000F6   0xBF08             IT       EQ 
   \   000000F8   0x2501             MOVEQ    R5,#+1
   \   000000FA   0xD00E             BEQ.N    ??HAL_GPIO_Init_5
   \   000000FC   0x....             LDR.N    R5,??DataTable2_5  ;; 0x40020800
   \   000000FE   0x42A8             CMP      R0,R5
   \   00000100   0xBF08             IT       EQ 
   \   00000102   0x2502             MOVEQ    R5,#+2
   \   00000104   0xD009             BEQ.N    ??HAL_GPIO_Init_5
   \   00000106   0x....             LDR.N    R5,??DataTable2_6  ;; 0x40020c00
   \   00000108   0x42A8             CMP      R0,R5
   \   0000010A   0xBF08             IT       EQ 
   \   0000010C   0x2503             MOVEQ    R5,#+3
   \   0000010E   0xD004             BEQ.N    ??HAL_GPIO_Init_5
   \   00000110   0x....             LDR.N    R5,??DataTable2_7  ;; 0x40021000
   \   00000112   0x42A8             CMP      R0,R5
   \   00000114   0xBF0C             ITE      EQ 
   \   00000116   0x2504             MOVEQ    R5,#+4
   \   00000118   0x2507             MOVNE    R5,#+7
    264                  SYSCFG->EXTICR[position >> 2U] = temp;
   \                     ??HAL_GPIO_Init_5: (+1)
   \   0000011A   0x40B5             LSLS     R5,R5,R6
   \   0000011C   0x432C             ORRS     R4,R5,R4
   \   0000011E   0xF848 0x402C      STR      R4,[R8, R12, LSL #+2]
   \   00000122   0x43FD             MVNS     R5,R7
    265          
    266                  /* Clear EXTI line configuration */
    267                  temp = EXTI->IMR;
   \   00000124   0x681C             LDR      R4,[R3, #+0]
    268                  temp &= ~((uint32_t)iocurrent);
   \   00000126   0xEA05 0x0E04      AND      LR,R5,R4
    269                  if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \   0000012A   0x684C             LDR      R4,[R1, #+4]
   \   0000012C   0x03E4             LSLS     R4,R4,#+15
   \   0000012E   0xBF48             IT       MI 
    270                  {
    271                    temp |= iocurrent;
   \   00000130   0xEA47 0x0E0E      ORRMI    LR,R7,LR
    272                  }
    273                  EXTI->IMR = temp;
   \   00000134   0xF8C3 0xE000      STR      LR,[R3, #+0]
    274          
    275                  temp = EXTI->EMR;
   \   00000138   0x685C             LDR      R4,[R3, #+4]
    276                  temp &= ~((uint32_t)iocurrent);
   \   0000013A   0xEA05 0x0E04      AND      LR,R5,R4
    277                  if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \   0000013E   0x684C             LDR      R4,[R1, #+4]
   \   00000140   0x03A4             LSLS     R4,R4,#+14
   \   00000142   0xBF48             IT       MI 
    278                  {
    279                    temp |= iocurrent;
   \   00000144   0xEA47 0x0E0E      ORRMI    LR,R7,LR
    280                  }
    281                  EXTI->EMR = temp;
   \   00000148   0xF8C3 0xE004      STR      LR,[R3, #+4]
    282          
    283                  /* Clear Rising Falling edge configuration */
    284                  temp = EXTI->RTSR;
   \   0000014C   0x689C             LDR      R4,[R3, #+8]
    285                  temp &= ~((uint32_t)iocurrent);
   \   0000014E   0xEA05 0x0E04      AND      LR,R5,R4
    286                  if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \   00000152   0x684C             LDR      R4,[R1, #+4]
   \   00000154   0x02E4             LSLS     R4,R4,#+11
   \   00000156   0xBF48             IT       MI 
    287                  {
    288                    temp |= iocurrent;
   \   00000158   0xEA47 0x0E0E      ORRMI    LR,R7,LR
    289                  }
    290                  EXTI->RTSR = temp;
   \   0000015C   0xF8C3 0xE008      STR      LR,[R3, #+8]
    291          
    292                  temp = EXTI->FTSR;
   \   00000160   0x68DC             LDR      R4,[R3, #+12]
    293                  temp &= ~((uint32_t)iocurrent);
   \   00000162   0xEA05 0x0C04      AND      R12,R5,R4
    294                  if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \   00000166   0x684C             LDR      R4,[R1, #+4]
   \   00000168   0xEA5F 0x2E84      LSLS     LR,R4,#+10
   \   0000016C   0xBF48             IT       MI 
    295                  {
    296                    temp |= iocurrent;
   \   0000016E   0xEA47 0x0C0C      ORRMI    R12,R7,R12
    297                  }
    298                  EXTI->FTSR = temp;
   \   00000172   0xF8C3 0xC00C      STR      R12,[R3, #+12]
    299                }
    300              }
    301            }
   \                     ??HAL_GPIO_Init_1: (+1)
   \   00000176   0x1C52             ADDS     R2,R2,#+1
   \   00000178   0x2A10             CMP      R2,#+16
   \   0000017A   0xF4FF 0xAF4B      BCC.W    ??HAL_GPIO_Init_0
    302          }
   \   0000017E   0xE8BD 0x87F1      POP      {R0,R4-R10,PC}   ;; return
    303          
    304          /**
    305            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    306            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    307            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    308            * @param  GPIO_Pin specifies the port bit to be written.
    309            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    310            * @retval None
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    313          {
   \                     HAL_GPIO_DeInit: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
    314            uint32_t position;
    315            uint32_t ioposition = 0x00U;
    316            uint32_t iocurrent = 0x00U;
    317            uint32_t tmp = 0x00U;
    318          
    319            /* Check the parameters */
    320            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    321            
    322            /* Configure the port pins */
    323            for(position = 0U; position < GPIO_NUMBER; position++)
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             LDR.N    R3,??DataTable2  ;; 0x40013c00
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable2_1  ;; 0x40013808
   \   0000000C   0x250F             MOVS     R5,#+15
    324            {
    325              /* Get the IO position */
    326              ioposition = 0x01U << position;
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \   0000000E   0x2601             MOVS     R6,#+1
   \   00000010   0xFA06 0xF702      LSL      R7,R6,R2
    327              /* Get the current IO position */
    328              iocurrent = (GPIO_Pin) & ioposition;
   \   00000014   0xEA07 0x0601      AND      R6,R7,R1
    329          
    330              if(iocurrent == ioposition)
   \   00000018   0x42BE             CMP      R6,R7
   \   0000001A   0xD15F             BNE.N    ??HAL_GPIO_DeInit_1
    331              {
    332                /*------------------------- GPIO Mode Configuration --------------------*/
    333                /* Configure IO Direction in Input Floating Mode */
    334                GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
   \   0000001C   0x2403             MOVS     R4,#+3
   \   0000001E   0xEA4F 0x0E42      LSL      LR,R2,#+1
   \   00000022   0xFA04 0xF40E      LSL      R4,R4,LR
   \   00000026   0xEA6F 0x0C04      MVN      R12,R4
   \   0000002A   0x6804             LDR      R4,[R0, #+0]
   \   0000002C   0xEA0C 0x0404      AND      R4,R12,R4
   \   00000030   0x6004             STR      R4,[R0, #+0]
   \   00000032   0x08D4             LSRS     R4,R2,#+3
   \   00000034   0xEB00 0x0E84      ADD      LR,R0,R4, LSL #+2
   \   00000038   0xF002 0x0407      AND      R4,R2,#0x7
   \   0000003C   0xF8DE 0x8020      LDR      R8,[LR, #+32]
   \   00000040   0x00A4             LSLS     R4,R4,#+2
   \   00000042   0xFA05 0xF404      LSL      R4,R5,R4
   \   00000046   0xEA28 0x0404      BIC      R4,R8,R4
   \   0000004A   0xF8CE 0x4020      STR      R4,[LR, #+32]
    335          
    336                /* Configure the default Alternate Function in current IO */
    337                GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
    338          
    339                /* Configure the default value for IO Speed */
    340                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
   \   0000004E   0x6884             LDR      R4,[R0, #+8]
   \   00000050   0xEA0C 0x0404      AND      R4,R12,R4
   \   00000054   0x6084             STR      R4,[R0, #+8]
    341          
    342                /* Configure the default value IO Output Type */
    343                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
   \   00000056   0x6844             LDR      R4,[R0, #+4]
   \   00000058   0xEA24 0x0707      BIC      R7,R4,R7
   \   0000005C   0x6047             STR      R7,[R0, #+4]
    344          
    345                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    346                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
   \   0000005E   0x68C7             LDR      R7,[R0, #+12]
   \   00000060   0xEA0C 0x0707      AND      R7,R12,R7
   \   00000064   0x60C7             STR      R7,[R0, #+12]
    347          
    348                /*------------------------- EXTI Mode Configuration --------------------*/
    349                tmp = SYSCFG->EXTICR[position >> 2U];
    350                tmp &= (0x0FU << (4U * (position & 0x03U)));
   \   00000066   0xF002 0x0C03      AND      R12,R2,#0x3
   \   0000006A   0x0897             LSRS     R7,R2,#+2
   \   0000006C   0xF859 0x4027      LDR      R4,[R9, R7, LSL #+2]
   \   00000070   0xEA4F 0x0C8C      LSL      R12,R12,#+2
   \   00000074   0xFA05 0xFE0C      LSL      LR,R5,R12
   \   00000078   0xEA0E 0x0804      AND      R8,LR,R4
    351                if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
   \   0000007C   0x....             LDR.N    R4,??DataTable2_3  ;; 0x40020000
   \   0000007E   0x42A0             CMP      R0,R4
   \   00000080   0xBF08             IT       EQ 
   \   00000082   0x2400             MOVEQ    R4,#+0
   \   00000084   0xD013             BEQ.N    ??HAL_GPIO_DeInit_2
   \   00000086   0x....             LDR.N    R4,??DataTable2_4  ;; 0x40020400
   \   00000088   0x42A0             CMP      R0,R4
   \   0000008A   0xBF08             IT       EQ 
   \   0000008C   0x2401             MOVEQ    R4,#+1
   \   0000008E   0xD00E             BEQ.N    ??HAL_GPIO_DeInit_2
   \   00000090   0x....             LDR.N    R4,??DataTable2_5  ;; 0x40020800
   \   00000092   0x42A0             CMP      R0,R4
   \   00000094   0xBF08             IT       EQ 
   \   00000096   0x2402             MOVEQ    R4,#+2
   \   00000098   0xD009             BEQ.N    ??HAL_GPIO_DeInit_2
   \   0000009A   0x....             LDR.N    R4,??DataTable2_6  ;; 0x40020c00
   \   0000009C   0x42A0             CMP      R0,R4
   \   0000009E   0xBF08             IT       EQ 
   \   000000A0   0x2403             MOVEQ    R4,#+3
   \   000000A2   0xD004             BEQ.N    ??HAL_GPIO_DeInit_2
   \   000000A4   0x....             LDR.N    R4,??DataTable2_7  ;; 0x40021000
   \   000000A6   0x42A0             CMP      R0,R4
   \   000000A8   0xBF0C             ITE      EQ 
   \   000000AA   0x2404             MOVEQ    R4,#+4
   \   000000AC   0x2407             MOVNE    R4,#+7
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \   000000AE   0xFA04 0xF40C      LSL      R4,R4,R12
   \   000000B2   0x45A0             CMP      R8,R4
   \   000000B4   0xD112             BNE.N    ??HAL_GPIO_DeInit_1
    352                {
    353                  /* Configure the External Interrupt or event for the current IO */
    354                  tmp = 0x0FU << (4U * (position & 0x03U));
    355                  SYSCFG->EXTICR[position >> 2U] &= ~tmp;
   \   000000B6   0xF859 0x4027      LDR      R4,[R9, R7, LSL #+2]
   \   000000BA   0xEA24 0x040E      BIC      R4,R4,LR
   \   000000BE   0xF849 0x4027      STR      R4,[R9, R7, LSL #+2]
    356          
    357                  /* Clear EXTI line configuration */
    358                  EXTI->IMR &= ~((uint32_t)iocurrent);
   \   000000C2   0x43F6             MVNS     R6,R6
   \   000000C4   0x681F             LDR      R7,[R3, #+0]
   \   000000C6   0x4037             ANDS     R7,R6,R7
   \   000000C8   0x601F             STR      R7,[R3, #+0]
    359                  EXTI->EMR &= ~((uint32_t)iocurrent);
   \   000000CA   0x685F             LDR      R7,[R3, #+4]
   \   000000CC   0x4037             ANDS     R7,R6,R7
   \   000000CE   0x605F             STR      R7,[R3, #+4]
    360                  
    361                  /* Clear Rising Falling edge configuration */
    362                  EXTI->RTSR &= ~((uint32_t)iocurrent);
   \   000000D0   0x689F             LDR      R7,[R3, #+8]
   \   000000D2   0x4037             ANDS     R7,R6,R7
   \   000000D4   0x609F             STR      R7,[R3, #+8]
    363                  EXTI->FTSR &= ~((uint32_t)iocurrent);
   \   000000D6   0x68DF             LDR      R7,[R3, #+12]
   \   000000D8   0x403E             ANDS     R6,R6,R7
   \   000000DA   0x60DE             STR      R6,[R3, #+12]
    364                }
    365              }
    366            }
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \   000000DC   0x1C52             ADDS     R2,R2,#+1
   \   000000DE   0x2A10             CMP      R2,#+16
   \   000000E0   0xD395             BCC.N    ??HAL_GPIO_DeInit_0
    367          }
   \   000000E2   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    368          
    369          /**
    370            * @}
    371            */
    372          
    373          /** @defgroup GPIO_Exported_Functions_Group2 IO operation functions 
    374            *  @brief   GPIO Read and Write
    375            *
    376          @verbatim
    377           ===============================================================================
    378                                 ##### IO operation functions #####
    379           ===============================================================================
    380          
    381          @endverbatim
    382            * @{
    383            */
    384          
    385          /**
    386            * @brief  Reads the specified input port pin.
    387            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    388            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    389            * @param  GPIO_Pin specifies the port bit to read.
    390            *         This parameter can be GPIO_PIN_x where x can be (0..15).
    391            * @retval The input port pin value.
    392            */

   \                                 In section .text, align 2, keep-with-next
    393          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    394          {
    395            GPIO_PinState bitstatus;
    396          
    397            /* Check the parameters */
    398            assert_param(IS_GPIO_PIN(GPIO_Pin));
    399          
    400            if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
   \                     HAL_GPIO_ReadPin: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4008             ANDS     R0,R1,R0
   \   00000004   0xBF18             IT       NE 
   \   00000006   0x2001             MOVNE    R0,#+1
    401            {
    402              bitstatus = GPIO_PIN_SET;
    403            }
    404            else
    405            {
    406              bitstatus = GPIO_PIN_RESET;
    407            }
    408            return bitstatus;
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x4770             BX       LR               ;; return
    409          }
    410          
    411          /**
    412            * @brief  Sets or clears the selected data port bit.
    413            *
    414            * @note   This function uses GPIOx_BSRR register to allow atomic read/modify
    415            *         accesses. In this way, there is no risk of an IRQ occurring between
    416            *         the read and the modify access.
    417            *
    418            * @param  GPIOx where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    419            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    420            * @param  GPIO_Pin specifies the port bit to be written.
    421            *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
    422            * @param  PinState specifies the value to be written to the selected bit.
    423            *          This parameter can be one of the GPIO_PinState enum values:
    424            *            @arg GPIO_PIN_RESET: to clear the port pin
    425            *            @arg GPIO_PIN_SET: to set the port pin
    426            * @retval None
    427            */

   \                                 In section .text, align 2, keep-with-next
    428          void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    429          {
    430            /* Check the parameters */
    431            assert_param(IS_GPIO_PIN(GPIO_Pin));
    432            assert_param(IS_GPIO_PIN_ACTION(PinState));
    433          
    434            if(PinState != GPIO_PIN_RESET)
   \                     HAL_GPIO_WritePin: (+1)
   \   00000000   0xB902             CBNZ.N   R2,??HAL_GPIO_WritePin_0
    435            {
    436              GPIOx->BSRR = GPIO_Pin;
    437            }
    438            else
    439            {
    440              GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
   \   00000002   0x0409             LSLS     R1,R1,#+16
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \   00000004   0x6181             STR      R1,[R0, #+24]
    441            }
    442          }
   \   00000006   0x4770             BX       LR               ;; return
    443          
    444          /**
    445            * @brief  Toggles the specified GPIO pins.
    446            * @param  GPIOx Where x can be (A..K) to select the GPIO peripheral for STM32F429X device or
    447            *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
    448            * @param  GPIO_Pin Specifies the pins to be toggled.
    449            * @retval None
    450            */

   \                                 In section .text, align 2, keep-with-next
    451          void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    452          {
    453            /* Check the parameters */
    454            assert_param(IS_GPIO_PIN(GPIO_Pin));
    455          
    456            GPIOx->ODR ^= GPIO_Pin;
   \                     HAL_GPIO_TogglePin: (+1)
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x4051             EORS     R1,R1,R2
   \   00000004   0x6141             STR      R1,[R0, #+20]
    457          }
   \   00000006   0x4770             BX       LR               ;; return
    458          
    459          /**
    460            * @brief  Locks GPIO Pins configuration registers.
    461            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    462            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    463            * @note   The configuration of the locked GPIO pins can no longer be modified
    464            *         until the next reset.
    465            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32F4 family
    466            * @param  GPIO_Pin specifies the port bit to be locked.
    467            *         This parameter can be any combination of GPIO_PIN_x where x can be (0..15).
    468            * @retval None
    469            */

   \                                 In section .text, align 2, keep-with-next
    470          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    471          {
   \                     HAL_GPIO_LockPin: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    472            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \   00000002   0xF44F 0x3280      MOV      R2,#+65536
   \   00000006   0x9200             STR      R2,[SP, #+0]
    473          
    474            /* Check the parameters */
    475            assert_param(IS_GPIO_PIN(GPIO_Pin));
    476          
    477            /* Apply lock key write sequence */
    478            tmp |= GPIO_Pin;
   \   00000008   0x9A00             LDR      R2,[SP, #+0]
   \   0000000A   0x430A             ORRS     R2,R1,R2
   \   0000000C   0x9200             STR      R2,[SP, #+0]
    479            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    480            GPIOx->LCKR = tmp;
   \   0000000E   0x9A00             LDR      R2,[SP, #+0]
   \   00000010   0x61C2             STR      R2,[R0, #+28]
    481            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    482            GPIOx->LCKR = GPIO_Pin;
   \   00000012   0x61C1             STR      R1,[R0, #+28]
    483            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    484            GPIOx->LCKR = tmp;
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    485            /* Read LCKK bit*/
    486            tmp = GPIOx->LCKR;
   \   00000018   0x69C1             LDR      R1,[R0, #+28]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
    487          
    488           if((GPIOx->LCKR & GPIO_LCKR_LCKK) != RESET)
   \   0000001C   0x69C0             LDR      R0,[R0, #+28]
   \   0000001E   0x03C0             LSLS     R0,R0,#+15
   \   00000020   0xBF4C             ITE      MI 
    489            {
    490              return HAL_OK;
   \   00000022   0x2000             MOVMI    R0,#+0
    491            }
    492            else
    493            {
    494              return HAL_ERROR;
   \   00000024   0x2001             MOVPL    R0,#+1
   \   00000026   0xB001             ADD      SP,SP,#+4
   \   00000028   0x4770             BX       LR               ;; return
    495            }
    496          }
    497          
    498          /**
    499            * @brief  This function handles EXTI interrupt request.
    500            * @param  GPIO_Pin Specifies the pins connected EXTI line
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    504          {
    505            /* EXTI line interrupt detected */
    506            if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable2_8  ;; 0x40013c14
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0x4203             TST      R3,R0
   \   00000006   0xD100             BNE.N    ??HAL_GPIO_EXTI_IRQHandler_0
   \   00000008   0x4770             BX       LR
    507            {
    508              __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x6010             STR      R0,[R2, #+0]
    509              HAL_GPIO_EXTI_Callback(GPIO_Pin);
   \   0000000E   0x.... 0x....      BL       HAL_GPIO_EXTI_Callback
    510            }
    511          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    512          
    513          /**
    514            * @brief  EXTI line detection callbacks.
    515            * @param  GPIO_Pin Specifies the pins connected EXTI line
    516            * @retval None
    517            */

   \                                 In section .text, align 2, keep-with-next
    518          __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    519          {
    520            /* Prevent unused argument(s) compilation warning */
    521            UNUSED(GPIO_Pin);
    522            /* NOTE: This function Should not be modified, when the callback is needed,
    523                     the HAL_GPIO_EXTI_Callback could be implemented in the user file
    524             */
    525          }
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40013C00         DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40013808         DC32     0x40013808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x40013C14         DC32     0x40013c14
    526          
    527          /**
    528            * @}
    529            */
    530          
    531          
    532          /**
    533            * @}
    534            */
    535          
    536          #endif /* HAL_GPIO_MODULE_ENABLED */
    537          /**
    538            * @}
    539            */
    540          
    541          /**
    542            * @}
    543            */
    544          
    545          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      28   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Callback
      36   HAL_GPIO_Init
       4   HAL_GPIO_LockPin
       0   HAL_GPIO_ReadPin
       0   HAL_GPIO_TogglePin
       0   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
     230  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Callback
      20  HAL_GPIO_EXTI_IRQHandler
     386  HAL_GPIO_Init
      42  HAL_GPIO_LockPin
      12  HAL_GPIO_ReadPin
       8  HAL_GPIO_TogglePin
       8  HAL_GPIO_WritePin

 
 744 bytes in section .text
 
 744 bytes of CODE memory

Errors: none
Warnings: none
