###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:34
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_pwr_ex.c
#    Command line =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_pwr_ex.c
#        -D USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\stm32f4xx_hal_pwr_ex.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\stm32f4xx_hal_pwr_ex.o
#
###############################################################################

C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_pwr_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_pwr_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended PWR HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of PWR extension peripheral:           
      8            *           + Peripheral Extended features functions
      9            *         
     10            ******************************************************************************
     11            * @attention
     12            *
     13            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
     14            *
     15            * Redistribution and use in source and binary forms, with or without modification,
     16            * are permitted provided that the following conditions are met:
     17            *   1. Redistributions of source code must retain the above copyright notice,
     18            *      this list of conditions and the following disclaimer.
     19            *   2. Redistributions in binary form must reproduce the above copyright notice,
     20            *      this list of conditions and the following disclaimer in the documentation
     21            *      and/or other materials provided with the distribution.
     22            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     23            *      may be used to endorse or promote products derived from this software
     24            *      without specific prior written permission.
     25            *
     26            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     27            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     28            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     29            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     30            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     31            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     32            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     33            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     34            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     35            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     36            *
     37            ******************************************************************************
     38            */ 
     39          
     40          /* Includes ------------------------------------------------------------------*/
     41          #include "stm32f4xx_hal.h"
     42          
     43          /** @addtogroup STM32F4xx_HAL_Driver
     44            * @{
     45            */
     46          
     47          /** @defgroup PWREx PWREx
     48            * @brief PWR HAL module driver
     49            * @{
     50            */
     51          
     52          #ifdef HAL_PWR_MODULE_ENABLED
     53          
     54          /* Private typedef -----------------------------------------------------------*/
     55          /* Private define ------------------------------------------------------------*/
     56          /** @addtogroup PWREx_Private_Constants
     57            * @{
     58            */    
     59          #define PWR_OVERDRIVE_TIMEOUT_VALUE  1000U
     60          #define PWR_UDERDRIVE_TIMEOUT_VALUE  1000U
     61          #define PWR_BKPREG_TIMEOUT_VALUE     1000U
     62          #define PWR_VOSRDY_TIMEOUT_VALUE     1000U
     63          /**
     64            * @}
     65            */
     66          
     67             
     68          /* Private macro -------------------------------------------------------------*/
     69          /* Private variables ---------------------------------------------------------*/
     70          /* Private function prototypes -----------------------------------------------*/
     71          /* Private functions ---------------------------------------------------------*/
     72          /** @defgroup PWREx_Exported_Functions PWREx Exported Functions
     73            *  @{
     74            */
     75          
     76          /** @defgroup PWREx_Exported_Functions_Group1 Peripheral Extended features functions 
     77            *  @brief Peripheral Extended features functions 
     78            *
     79          @verbatim   
     80          
     81           ===============================================================================
     82                           ##### Peripheral extended features functions #####
     83           ===============================================================================
     84          
     85              *** Main and Backup Regulators configuration ***
     86              ================================================
     87              [..] 
     88                (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
     89                    the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
     90                    retained even in Standby or VBAT mode when the low power backup regulator
     91                    is enabled. It can be considered as an internal EEPROM when VBAT is 
     92                    always present. You can use the HAL_PWREx_EnableBkUpReg() function to 
     93                    enable the low power backup regulator. 
     94          
     95                (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
     96                    the backup SRAM is powered from VDD which replaces the VBAT power supply to 
     97                    save battery life.
     98          
     99                (+) The backup SRAM is not mass erased by a tamper event. It is read 
    100                    protected to prevent confidential data, such as cryptographic private 
    101                    key, from being accessed. The backup SRAM can be erased only through 
    102                    the Flash interface when a protection level change from level 1 to 
    103                    level 0 is requested. 
    104                -@- Refer to the description of Read protection (RDP) in the Flash 
    105                    programming manual.
    106          
    107                (+) The main internal regulator can be configured to have a tradeoff between 
    108                    performance and power consumption when the device does not operate at 
    109                    the maximum frequency. This is done through __HAL_PWR_MAINREGULATORMODE_CONFIG() 
    110                    macro which configure VOS bit in PWR_CR register
    111                    
    112                  Refer to the product datasheets for more details.
    113          
    114              *** FLASH Power Down configuration ****
    115              =======================================
    116              [..] 
    117                (+) By setting the FPDS bit in the PWR_CR register by using the 
    118                    HAL_PWREx_EnableFlashPowerDown() function, the Flash memory also enters power 
    119                    down mode when the device enters Stop mode. When the Flash memory 
    120                    is in power down mode, an additional startup delay is incurred when 
    121                    waking up from Stop mode.
    122                    
    123                     (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, the scale can be modified only when the PLL 
    124                     is OFF and the HSI or HSE clock source is selected as system clock. 
    125                     The new value programmed is active only when the PLL is ON.
    126                     When the PLL is OFF, the voltage scale 3 is automatically selected. 
    127                  Refer to the datasheets for more details.
    128          
    129              *** Over-Drive and Under-Drive configuration ****
    130              =================================================
    131              [..]         
    132                 (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, in Run mode: the main regulator has
    133                     2 operating modes available:
    134                  (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
    135                       voltage scaling (scale 1, scale 2 or scale 3)
    136                  (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
    137                      higher frequency than the normal mode for a given voltage scaling (scale 1,  
    138                      scale 2 or scale 3). This mode is enabled through HAL_PWREx_EnableOverDrive() function and
    139                      disabled by HAL_PWREx_DisableOverDrive() function, to enter or exit from Over-drive mode please follow 
    140                      the sequence described in Reference manual.
    141                       
    142                 (+) For STM32F42xxx/43xxx/446xx/469xx/479xx Devices, in Stop mode: the main regulator or low power regulator 
    143                     supplies a low power voltage to the 1.2V domain, thus preserving the content of registers 
    144                     and internal SRAM. 2 operating modes are available:
    145                   (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
    146                        available when the main regulator or the low power regulator is used in Scale 3 or 
    147                        low voltage mode.
    148                   (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is only
    149                        available when the main regulator or the low power regulator is in low voltage mode.
    150          
    151          @endverbatim
    152            * @{
    153            */
    154          
    155          /**
    156            * @brief Enables the Backup Regulator.
    157            * @retval HAL status
    158            */

   \                                 In section .text, align 2, keep-with-next
    159          HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
    160          {
   \                     HAL_PWREx_EnableBkUpReg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    161            uint32_t tickstart = 0U;
    162          
    163            *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)ENABLE;
   \   00000002   0x....             LDR.N    R1,??DataTable7  ;; 0x420e00a4
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x6008             STR      R0,[R1, #+0]
    164          
    165            /* Get tick */
    166            tickstart = HAL_GetTick();
   \   00000008   0x.... 0x....      BL       HAL_GetTick
   \   0000000C   0x4604             MOV      R4,R0
    167          
    168            /* Wait till Backup regulator ready flag is set */  
    169            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
   \                     ??HAL_PWREx_EnableBkUpReg_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1  ;; 0x40007004
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0700             LSLS     R0,R0,#+28
   \   00000014   0xD407             BMI.N    ??HAL_PWREx_EnableBkUpReg_1
    170            {
    171              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x1B00             SUBS     R0,R0,R4
   \   0000001C   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000020   0xD9F5             BLS.N    ??HAL_PWREx_EnableBkUpReg_0
    172              {
    173                return HAL_TIMEOUT;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xBD10             POP      {R4,PC}
    174              } 
    175            }
    176            return HAL_OK;
   \                     ??HAL_PWREx_EnableBkUpReg_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    177          }
    178          
    179          /**
    180            * @brief Disables the Backup Regulator.
    181            * @retval HAL status
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
    184          {
   \                     HAL_PWREx_DisableBkUpReg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    185            uint32_t tickstart = 0U;
    186          
    187            *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;
   \   00000002   0x....             LDR.N    R1,??DataTable7  ;; 0x420e00a4
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6008             STR      R0,[R1, #+0]
    188          
    189            /* Get tick */
    190            tickstart = HAL_GetTick();
   \   00000008   0x.... 0x....      BL       HAL_GetTick
   \   0000000C   0x4604             MOV      R4,R0
    191          
    192            /* Wait till Backup regulator ready flag is set */  
    193            while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
   \                     ??HAL_PWREx_DisableBkUpReg_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1  ;; 0x40007004
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0700             LSLS     R0,R0,#+28
   \   00000014   0xD507             BPL.N    ??HAL_PWREx_DisableBkUpReg_1
    194            {
    195              if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x1B00             SUBS     R0,R0,R4
   \   0000001C   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000020   0xD9F5             BLS.N    ??HAL_PWREx_DisableBkUpReg_0
    196              {
    197                return HAL_TIMEOUT;
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xBD10             POP      {R4,PC}
    198              } 
    199            }
    200            return HAL_OK;
   \                     ??HAL_PWREx_DisableBkUpReg_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    201          }
    202          
    203          /**
    204            * @brief Enables the Flash Power Down in Stop mode.
    205            * @retval None
    206            */

   \                                 In section .text, align 2, keep-with-next
    207          void HAL_PWREx_EnableFlashPowerDown(void)
    208          {
    209            *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)ENABLE;
   \                     HAL_PWREx_EnableFlashPowerDown: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_2  ;; 0x420e0024
   \   00000002   0x....             B.N      ?Subroutine0
    210          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x6008             STR      R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    211          
    212          /**
    213            * @brief Disables the Flash Power Down in Stop mode.
    214            * @retval None
    215            */

   \                                 In section .text, align 2, keep-with-next
    216          void HAL_PWREx_DisableFlashPowerDown(void)
    217          {
    218            *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)DISABLE;
   \                     HAL_PWREx_DisableFlashPowerDown: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_2  ;; 0x420e0024
   \   00000002   0x....             B.N      ?Subroutine1
    219          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x6008             STR      R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    220          
    221          /**
    222            * @brief Return Voltage Scaling Range.
    223            * @retval The configured scale for the regulator voltage(VOS bit field).
    224            *         The returned value can be one of the following:
    225            *            - @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output Scale 1 mode
    226            *            - @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output Scale 2 mode
    227            *            - @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output Scale 3 mode
    228            */  

   \                                 In section .text, align 2, keep-with-next
    229          uint32_t HAL_PWREx_GetVoltageRange(void)
    230          {
    231            return (PWR->CR & PWR_CR_VOS);
   \                     HAL_PWREx_GetVoltageRange: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_3  ;; 0x40007000
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF400 0x4040      AND      R0,R0,#0xC000
   \   00000008   0x4770             BX       LR               ;; return
    232          }
    233          
    234          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
    235          /**
    236            * @brief Configures the main internal regulator output voltage.
    237            * @param  VoltageScaling specifies the regulator output voltage to achieve
    238            *         a tradeoff between performance and power consumption.
    239            *          This parameter can be one of the following values:
    240            *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
    241            *                                               the maximum value of fHCLK = 168 MHz.
    242            *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
    243            *                                               the maximum value of fHCLK = 144 MHz.
    244            * @note  When moving from Range 1 to Range 2, the system frequency must be decreased to
    245            *        a value below 144 MHz before calling HAL_PWREx_ConfigVoltageScaling() API.
    246            *        When moving from Range 2 to Range 1, the system frequency can be increased to
    247            *        a value up to 168 MHz after calling HAL_PWREx_ConfigVoltageScaling() API.
    248            * @retval HAL Status
    249            */
    250          HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
    251          {
    252            uint32_t tickstart = 0U;
    253            
    254            assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
    255            
    256            /* Enable PWR RCC Clock Peripheral */
    257            __HAL_RCC_PWR_CLK_ENABLE();
    258            
    259            /* Set Range */
    260            __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
    261            
    262            /* Get Start Tick*/
    263            tickstart = HAL_GetTick();
    264            while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
    265            {
    266              if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
    267              {
    268                return HAL_TIMEOUT;
    269              } 
    270            }
    271          
    272            return HAL_OK;
    273          }
    274          
    275          #elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || \
    276                defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || \
    277                defined(STM32F410Rx) || defined(STM32F411xE) || defined(STM32F446xx) || defined(STM32F469xx) || \
    278                defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || \
    279                defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
    280          /**
    281            * @brief Configures the main internal regulator output voltage.
    282            * @param  VoltageScaling specifies the regulator output voltage to achieve
    283            *         a tradeoff between performance and power consumption.
    284            *          This parameter can be one of the following values:
    285            *            @arg PWR_REGULATOR_VOLTAGE_SCALE1: Regulator voltage output range 1 mode,
    286            *                                               the maximum value of fHCLK is 168 MHz. It can be extended to
    287            *                                               180 MHz by activating the over-drive mode.
    288            *            @arg PWR_REGULATOR_VOLTAGE_SCALE2: Regulator voltage output range 2 mode,
    289            *                                               the maximum value of fHCLK is 144 MHz. It can be extended to,                
    290            *                                               168 MHz by activating the over-drive mode.
    291            *            @arg PWR_REGULATOR_VOLTAGE_SCALE3: Regulator voltage output range 3 mode,
    292            *                                               the maximum value of fHCLK is 120 MHz.
    293            * @note To update the system clock frequency(SYSCLK):
    294            *        - Set the HSI or HSE as system clock frequency using the HAL_RCC_ClockConfig().
    295            *        - Call the HAL_RCC_OscConfig() to configure the PLL.
    296            *        - Call HAL_PWREx_ConfigVoltageScaling() API to adjust the voltage scale.
    297            *        - Set the new system clock frequency using the HAL_RCC_ClockConfig().
    298            * @note The scale can be modified only when the HSI or HSE clock source is selected 
    299            *        as system clock source, otherwise the API returns HAL_ERROR.  
    300            * @note When the PLL is OFF, the voltage scale 3 is automatically selected and the VOS bits
    301            *       value in the PWR_CR1 register are not taken in account.
    302            * @note This API forces the PLL state ON to allow the possibility to configure the voltage scale 1 or 2.
    303            * @note The new voltage scale is active only when the PLL is ON.  
    304            * @retval HAL Status
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
    307          {
   \                     HAL_PWREx_ControlVoltageScaling: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
    308            uint32_t tickstart = 0U;
    309            
    310            assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
    311            
    312            /* Enable PWR RCC Clock Peripheral */
    313            __HAL_RCC_PWR_CLK_ENABLE();
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   \   0000000A   0x....             LDR.N    R5,??DataTable7_4  ;; 0x40023800
   \   0000000C   0x6C28             LDR      R0,[R5, #+64]
   \   0000000E   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \   00000012   0x6428             STR      R0,[R5, #+64]
   \   00000014   0x6C28             LDR      R0,[R5, #+64]
   \   00000016   0xF000 0x5080      AND      R0,R0,#0x10000000
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x9800             LDR      R0,[SP, #+0]
    314            
    315            /* Check if the PLL is used as system clock or not */
    316            if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
   \   0000001E   0x68A8             LDR      R0,[R5, #+8]
   \   00000020   0xF000 0x000C      AND      R0,R0,#0xC
   \   00000024   0x2808             CMP      R0,#+8
   \   00000026   0xD039             BEQ.N    ??HAL_PWREx_ControlVoltageScaling_0
    317            {
    318              /* Disable the main PLL */
    319              __HAL_RCC_PLL_DISABLE();
   \   00000028   0x....             LDR.N    R6,??DataTable7_5  ;; 0x42470060
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6030             STR      R0,[R6, #+0]
    320              
    321              /* Get Start Tick */
    322              tickstart = HAL_GetTick();    
   \   0000002E   0x.... 0x....      BL       HAL_GetTick
   \   00000032   0x4607             MOV      R7,R0
    323              /* Wait till PLL is disabled */  
    324              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_PWREx_ControlVoltageScaling_1: (+1)
   \   00000034   0x6828             LDR      R0,[R5, #+0]
   \   00000036   0x0180             LSLS     R0,R0,#+6
   \   00000038   0xD505             BPL.N    ??HAL_PWREx_ControlVoltageScaling_2
    325              {
    326                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   0000003A   0x.... 0x....      BL       HAL_GetTick
   \   0000003E   0x1BC0             SUBS     R0,R0,R7
   \   00000040   0x2803             CMP      R0,#+3
   \   00000042   0xD3F7             BCC.N    ??HAL_PWREx_ControlVoltageScaling_1
   \   00000044   0xE026             B.N      ??HAL_PWREx_ControlVoltageScaling_3
    327                {
    328                  return HAL_TIMEOUT;
    329                }
    330              }
    331              
    332              /* Set Range */
    333              __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
   \                     ??HAL_PWREx_ControlVoltageScaling_2: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x9000             STR      R0,[SP, #+0]
   \   0000004A   0x....             LDR.N    R7,??DataTable7_3  ;; 0x40007000
   \   0000004C   0x6838             LDR      R0,[R7, #+0]
   \   0000004E   0xF420 0x4040      BIC      R0,R0,#0xC000
   \   00000052   0x4320             ORRS     R0,R4,R0
   \   00000054   0x6038             STR      R0,[R7, #+0]
   \   00000056   0x6838             LDR      R0,[R7, #+0]
   \   00000058   0xF400 0x4040      AND      R0,R0,#0xC000
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
    334              
    335              /* Enable the main PLL */
    336              __HAL_RCC_PLL_ENABLE();
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x6030             STR      R0,[R6, #+0]
    337              
    338              /* Get Start Tick */
    339              tickstart = HAL_GetTick();
   \   00000064   0x.... 0x....      BL       HAL_GetTick
   \   00000068   0x4604             MOV      R4,R0
    340              /* Wait till PLL is ready */  
    341              while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \                     ??HAL_PWREx_ControlVoltageScaling_4: (+1)
   \   0000006A   0x6828             LDR      R0,[R5, #+0]
   \   0000006C   0x0180             LSLS     R0,R0,#+6
   \   0000006E   0xD405             BMI.N    ??HAL_PWREx_ControlVoltageScaling_5
    342              {
    343                if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000070   0x.... 0x....      BL       HAL_GetTick
   \   00000074   0x1B00             SUBS     R0,R0,R4
   \   00000076   0x2803             CMP      R0,#+3
   \   00000078   0xD3F7             BCC.N    ??HAL_PWREx_ControlVoltageScaling_4
   \   0000007A   0xE00B             B.N      ??HAL_PWREx_ControlVoltageScaling_3
    344                {
    345                  return HAL_TIMEOUT;
    346                } 
    347              }
    348              
    349              /* Get Start Tick */
    350              tickstart = HAL_GetTick();
   \                     ??HAL_PWREx_ControlVoltageScaling_5: (+1)
   \   0000007C   0x.... 0x....      BL       HAL_GetTick
   \   00000080   0x4604             MOV      R4,R0
    351              while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
   \                     ??HAL_PWREx_ControlVoltageScaling_6: (+1)
   \   00000082   0x6878             LDR      R0,[R7, #+4]
   \   00000084   0x0440             LSLS     R0,R0,#+17
   \   00000086   0xD407             BMI.N    ??HAL_PWREx_ControlVoltageScaling_7
    352              {
    353                if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
   \   00000088   0x.... 0x....      BL       HAL_GetTick
   \   0000008C   0x1B00             SUBS     R0,R0,R4
   \   0000008E   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   00000092   0xD9F6             BLS.N    ??HAL_PWREx_ControlVoltageScaling_6
    354                {
    355                  return HAL_TIMEOUT;
   \                     ??HAL_PWREx_ControlVoltageScaling_3: (+1)
   \   00000094   0x2003             MOVS     R0,#+3
   \   00000096   0xBDFE             POP      {R1-R7,PC}
    356                } 
    357              }
    358            }
    359            else
    360            {
    361              return HAL_ERROR;
    362            }
    363          
    364            return HAL_OK;
   \                     ??HAL_PWREx_ControlVoltageScaling_7: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xBDFE             POP      {R1-R7,PC}
   \                     ??HAL_PWREx_ControlVoltageScaling_0: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xBDFE             POP      {R1-R7,PC}       ;; return
    365          }
    366          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
    367          
    368          #if defined(STM32F469xx) || defined(STM32F479xx)
    369          /**
    370            * @brief Enables Wakeup Pin Detection on high level (rising edge).
    371            * @retval None
    372            */
    373          void HAL_PWREx_EnableWakeUpPinPolarityRisingEdge(void)
    374          {
    375            *(__IO uint32_t *) CSR_WUPP_BB = (uint32_t)DISABLE;
    376          }
    377          
    378          /**
    379            * @brief Enables Wakeup Pin Detection on low level (falling edge).
    380            * @retval None
    381            */
    382          void HAL_PWREx_EnableWakeUpPinPolarityFallingEdge(void)
    383          {
    384            *(__IO uint32_t *) CSR_WUPP_BB = (uint32_t)ENABLE;
    385          }
    386          #endif /* STM32F469xx || STM32F479xx */
    387          
    388          #if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx) ||\
    389              defined(STM32F411xE) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
    390              defined(STM32F413xx) || defined(STM32F423xx)
    391          /**
    392            * @brief Enables Main Regulator low voltage mode.
    393            * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
    394            *        STM32F413xx/STM32F423xx devices.   
    395            * @retval None
    396            */

   \                                 In section .text, align 2, keep-with-next
    397          void HAL_PWREx_EnableMainRegulatorLowVoltage(void)
    398          {
    399            *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;
   \                     HAL_PWREx_EnableMainRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_6  ;; 0x420e002c
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    400          }
    401          
    402          /**
    403            * @brief Disables Main Regulator low voltage mode.
    404            * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
    405            *        STM32F413xx/STM32F423xxdevices. 
    406            * @retval None
    407            */

   \                                 In section .text, align 2, keep-with-next
    408          void HAL_PWREx_DisableMainRegulatorLowVoltage(void)
    409          {
    410            *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;
   \                     HAL_PWREx_DisableMainRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_6  ;; 0x420e002c
   \   00000002                      REQUIRE ?Subroutine1
   \   00000002                      ;; // Fall through to label ?Subroutine1
    411          }
    412          
    413          /**
    414            * @brief Enables Low Power Regulator low voltage mode.
    415            * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
    416            *        STM32F413xx/STM32F423xx devices.   
    417            * @retval None
    418            */

   \                                 In section .text, align 2, keep-with-next
    419          void HAL_PWREx_EnableLowRegulatorLowVoltage(void)
    420          {
    421            *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;
   \                     HAL_PWREx_EnableLowRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_7  ;; 0x420e0028
   \   00000002   0x....             B.N      ?Subroutine0
    422          }
    423          
    424          /**
    425            * @brief Disables Low Power Regulator low voltage mode.
    426            * @note  This mode is only available for STM32F401xx/STM32F410xx/STM32F411xx/STM32F412Zx/STM32F412Rx/STM32F412Vx/STM32F412Cx/
    427            *        STM32F413xx/STM32F423xx  devices.   
    428            * @retval None
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          void HAL_PWREx_DisableLowRegulatorLowVoltage(void)
    431          {
    432            *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;
   \                     HAL_PWREx_DisableLowRegulatorLowVoltage: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_7  ;; 0x420e0028
   \   00000002   0x....             B.N      ?Subroutine1
    433          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x420E00A4         DC32     0x420e00a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x40007004         DC32     0x40007004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x420E0024         DC32     0x420e0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x42470060         DC32     0x42470060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x420E002C         DC32     0x420e002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x420E0028         DC32     0x420e0028
    434          
    435          #endif /* STM32F401xC || STM32F401xE || STM32F410xx || STM32F411xE || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx ||
    436                    STM32F413xx || STM32F423xx */
    437          
    438          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
    439              defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
    440          /**
    441            * @brief  Activates the Over-Drive mode.
    442            * @note   This function can be used only for STM32F42xx/STM32F43xx/STM32F446xx/STM32F469xx/STM32F479xx devices.
    443            *         This mode allows the CPU and the core logic to operate at a higher frequency
    444            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
    445            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    446            *         critical tasks and when the system clock source is either HSI or HSE. 
    447            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    448            *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
    449            * @retval HAL status
    450            */
    451          HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
    452          {
    453            uint32_t tickstart = 0U;
    454          
    455            __HAL_RCC_PWR_CLK_ENABLE();
    456            
    457            /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
    458            __HAL_PWR_OVERDRIVE_ENABLE();
    459          
    460            /* Get tick */
    461            tickstart = HAL_GetTick();
    462          
    463            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
    464            {
    465              if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    466              {
    467                return HAL_TIMEOUT;
    468              }
    469            }
    470            
    471            /* Enable the Over-drive switch */
    472            __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
    473          
    474            /* Get tick */
    475            tickstart = HAL_GetTick();
    476          
    477            while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
    478            {
    479              if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    480              {
    481                return HAL_TIMEOUT;
    482              }
    483            } 
    484            return HAL_OK;
    485          }
    486          
    487          /**
    488            * @brief  Deactivates the Over-Drive mode.
    489            * @note   This function can be used only for STM32F42xx/STM32F43xx/STM32F446xx/STM32F469xx/STM32F479xx devices.
    490            *         This mode allows the CPU and the core logic to operate at a higher frequency
    491            *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).    
    492            * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
    493            *         critical tasks and when the system clock source is either HSI or HSE. 
    494            *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
    495            *         The peripheral clocks must be enabled once the Over-drive mode is activated.
    496            * @retval HAL status
    497            */
    498          HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
    499          {
    500            uint32_t tickstart = 0U;
    501            
    502            __HAL_RCC_PWR_CLK_ENABLE();
    503              
    504            /* Disable the Over-drive switch */
    505            __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
    506            
    507            /* Get tick */
    508            tickstart = HAL_GetTick();
    509           
    510            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
    511            {
    512              if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    513              {
    514                return HAL_TIMEOUT;
    515              }
    516            } 
    517            
    518            /* Disable the Over-drive */
    519            __HAL_PWR_OVERDRIVE_DISABLE();
    520          
    521            /* Get tick */
    522            tickstart = HAL_GetTick();
    523          
    524            while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
    525            {
    526              if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    527              {
    528                return HAL_TIMEOUT;
    529              }
    530            }
    531            
    532            return HAL_OK;
    533          }
    534          
    535          /**
    536            * @brief  Enters in Under-Drive STOP mode.
    537            *  
    538            * @note   This mode is only available for STM32F42xxx/STM32F43xxx/STM32F446xx/STM32F469xx/STM32F479xx devices.
    539            * 
    540            * @note    This mode can be selected only when the Under-Drive is already active 
    541            *   
    542            * @note    This mode is enabled only with STOP low power mode.
    543            *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
    544            *          mode is only available when the main regulator or the low power regulator 
    545            *          is in low voltage mode
    546            *        
    547            * @note   If the Under-drive mode was enabled, it is automatically disabled after 
    548            *         exiting Stop mode. 
    549            *         When the voltage regulator operates in Under-drive mode, an additional  
    550            *         startup delay is induced when waking up from Stop mode.
    551            *                    
    552            * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
    553            *   
    554            * @note   When exiting Stop mode by issuing an interrupt or a wake-up event, 
    555            *         the HSI RC oscillator is selected as system clock.
    556            *           
    557            * @note   When the voltage regulator operates in low power mode, an additional 
    558            *         startup delay is incurred when waking up from Stop mode. 
    559            *         By keeping the internal regulator ON during Stop mode, the consumption 
    560            *         is higher although the startup time is reduced.
    561            *     
    562            * @param  Regulator specifies the regulator state in STOP mode.
    563            *          This parameter can be one of the following values:
    564            *            @arg PWR_MAINREGULATOR_UNDERDRIVE_ON:  Main Regulator in under-drive mode 
    565            *                 and Flash memory in power-down when the device is in Stop under-drive mode
    566            *            @arg PWR_LOWPOWERREGULATOR_UNDERDRIVE_ON:  Low Power Regulator in under-drive mode 
    567            *                and Flash memory in power-down when the device is in Stop under-drive mode
    568            * @param  STOPEntry specifies if STOP mode in entered with WFI or WFE instruction.
    569            *          This parameter can be one of the following values:
    570            *            @arg PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
    571            *            @arg PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
    572            * @retval None
    573            */
    574          HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
    575          {
    576            uint32_t tmpreg1 = 0U;
    577          
    578            /* Check the parameters */
    579            assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
    580            assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
    581            
    582            /* Enable Power ctrl clock */
    583            __HAL_RCC_PWR_CLK_ENABLE();
    584            /* Enable the Under-drive Mode ---------------------------------------------*/
    585            /* Clear Under-drive flag */
    586            __HAL_PWR_CLEAR_ODRUDR_FLAG();
    587            
    588            /* Enable the Under-drive */ 
    589            __HAL_PWR_UNDERDRIVE_ENABLE();
    590          
    591            /* Select the regulator state in STOP mode ---------------------------------*/
    592            tmpreg1 = PWR->CR;
    593            /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
    594            tmpreg1 &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_LPUDS | PWR_CR_MRUDS);
    595            
    596            /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
    597            tmpreg1 |= Regulator;
    598            
    599            /* Store the new value */
    600            PWR->CR = tmpreg1;
    601            
    602            /* Set SLEEPDEEP bit of Cortex System Control Register */
    603            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    604            
    605            /* Select STOP mode entry --------------------------------------------------*/
    606            if(STOPEntry == PWR_SLEEPENTRY_WFI)
    607            {   
    608              /* Request Wait For Interrupt */
    609              __WFI();
    610            }
    611            else
    612            {
    613              /* Request Wait For Event */
    614              __WFE();
    615            }
    616            /* Reset SLEEPDEEP bit of Cortex System Control Register */
    617            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
    618          
    619            return HAL_OK;  
    620          }
    621          
    622          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
    623          /**
    624            * @}
    625            */
    626          
    627          /**
    628            * @}
    629            */
    630          
    631          #endif /* HAL_PWR_MODULE_ENABLED */
    632          /**
    633            * @}
    634            */
    635          
    636          /**
    637            * @}
    638            */
    639          
    640          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   HAL_PWREx_ControlVoltageScaling
        32   -> HAL_GetTick
       8   HAL_PWREx_DisableBkUpReg
         8   -> HAL_GetTick
       0   HAL_PWREx_DisableFlashPowerDown
       0   HAL_PWREx_DisableLowRegulatorLowVoltage
       0   HAL_PWREx_DisableMainRegulatorLowVoltage
       8   HAL_PWREx_EnableBkUpReg
         8   -> HAL_GetTick
       0   HAL_PWREx_EnableFlashPowerDown
       0   HAL_PWREx_EnableLowRegulatorLowVoltage
       0   HAL_PWREx_EnableMainRegulatorLowVoltage
       0   HAL_PWREx_GetVoltageRange


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       6  ?Subroutine0
       6  ?Subroutine1
     160  HAL_PWREx_ControlVoltageScaling
      42  HAL_PWREx_DisableBkUpReg
       4  HAL_PWREx_DisableFlashPowerDown
       4  HAL_PWREx_DisableLowRegulatorLowVoltage
       2  HAL_PWREx_DisableMainRegulatorLowVoltage
      42  HAL_PWREx_EnableBkUpReg
       4  HAL_PWREx_EnableFlashPowerDown
       4  HAL_PWREx_EnableLowRegulatorLowVoltage
       2  HAL_PWREx_EnableMainRegulatorLowVoltage
      10  HAL_PWREx_GetVoltageRange

 
 318 bytes in section .text
 
 318 bytes of CODE memory

Errors: none
Warnings: none
