###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:38
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\CubeMX_Project\SPI_Cortex_Slave\Src\system_stm32f4xx.c
#    Command line =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\Src\system_stm32f4xx.c -D
#        USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\system_stm32f4xx.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\system_stm32f4xx.o
#
###############################################################################

C:\CubeMX_Project\SPI_Cortex_Slave\Src\system_stm32f4xx.c
      1          /**
      2            ******************************************************************************
      3            * @file    system_stm32f4xx.c
      4            * @author  MCD Application Team
      5            * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Source File.
      6            *
      7            *   This file provides two functions and one global variable to be called from 
      8            *   user application:
      9            *      - SystemInit(): This function is called at startup just after reset and 
     10            *                      before branch to main program. This call is made inside
     11            *                      the "startup_stm32f4xx.s" file.
     12            *
     13            *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
     14            *                                  by the user application to setup the SysTick 
     15            *                                  timer or configure other parameters.
     16            *                                     
     17            *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
     18            *                                 be called whenever the core clock is changed
     19            *                                 during program execution.
     20            *
     21            *
     22            ******************************************************************************
     23            * @attention
     24            *
     25            * <h2><center>&copy; COPYRIGHT 2017 STMicroelectronics</center></h2>
     26            *
     27            * Redistribution and use in source and binary forms, with or without modification,
     28            * are permitted provided that the following conditions are met:
     29            *   1. Redistributions of source code must retain the above copyright notice,
     30            *      this list of conditions and the following disclaimer.
     31            *   2. Redistributions in binary form must reproduce the above copyright notice,
     32            *      this list of conditions and the following disclaimer in the documentation
     33            *      and/or other materials provided with the distribution.
     34            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     35            *      may be used to endorse or promote products derived from this software
     36            *      without specific prior written permission.
     37            *
     38            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     39            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     40            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     41            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     42            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     43            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     44            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     45            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     46            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     47            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     48            *
     49            ******************************************************************************
     50            */
     51          
     52          /** @addtogroup CMSIS
     53            * @{
     54            */
     55          
     56          /** @addtogroup stm32f4xx_system
     57            * @{
     58            */  
     59            
     60          /** @addtogroup STM32F4xx_System_Private_Includes
     61            * @{
     62            */
     63          
     64          
     65          #include "stm32f4xx.h"
     66          
     67          #if !defined  (HSE_VALUE) 
     68            #define HSE_VALUE    ((uint32_t)25000000) /*!< Default value of the External oscillator in Hz */
     69          #endif /* HSE_VALUE */
     70          
     71          #if !defined  (HSI_VALUE)
     72            #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/
     73          #endif /* HSI_VALUE */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @addtogroup STM32F4xx_System_Private_TypesDefinitions
     80            * @{
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /** @addtogroup STM32F4xx_System_Private_Defines
     88            * @{
     89            */
     90          
     91          /************************* Miscellaneous Configuration ************************/
     92          /*!< Uncomment the following line if you need to use external SRAM or SDRAM as data memory  */
     93          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\
     94           || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
     95           || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)
     96          /* #define DATA_IN_ExtSRAM */
     97          #endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F469xx || STM32F479xx ||\
     98                    STM32F412Zx || STM32F412Vx */
     99           
    100          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    101           || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
    102          /* #define DATA_IN_ExtSDRAM */
    103          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx ||\
    104                    STM32F479xx */
    105          
    106          /*!< Uncomment the following line if you need to relocate your vector Table in
    107               Internal SRAM. */
    108          /* #define VECT_TAB_SRAM */
    109          #define VECT_TAB_OFFSET  0x00 /*!< Vector Table base offset field. 
    110                                             This value must be a multiple of 0x200. */
    111          /******************************************************************************/
    112          
    113          /**
    114            * @}
    115            */
    116          
    117          /** @addtogroup STM32F4xx_System_Private_Macros
    118            * @{
    119            */
    120          
    121          /**
    122            * @}
    123            */
    124          
    125          /** @addtogroup STM32F4xx_System_Private_Variables
    126            * @{
    127            */
    128            /* This variable is updated in three ways:
    129                1) by calling CMSIS function SystemCoreClockUpdate()
    130                2) by calling HAL API function HAL_RCC_GetHCLKFreq()
    131                3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency 
    132                   Note: If you use this function to configure the system clock; then there
    133                         is no need to call the 2 first functions listed above, since SystemCoreClock
    134                         variable is updated automatically.
    135            */

   \                                 In section .data, align 4
    136          uint32_t SystemCoreClock = 16000000;
   \                     SystemCoreClock:
   \   00000000   0x00F42400         DC32 16000000

   \                                 In section .text, align 4, keep-with-next
    137          const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     AHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    

   \                                 In section .rodata, align 4, keep-with-next
    138          const uint8_t APBPrescTable[8]  = {0, 0, 0, 0, 1, 2, 3, 4};
   \                     APBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
    139          /**
    140            * @}
    141            */
    142          
    143          /** @addtogroup STM32F4xx_System_Private_FunctionPrototypes
    144            * @{
    145            */
    146          
    147          #if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    148            static void SystemInit_ExtMemCtl(void); 
    149          #endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
    150          
    151          /**
    152            * @}
    153            */
    154          
    155          /** @addtogroup STM32F4xx_System_Private_Functions
    156            * @{
    157            */
    158          
    159          /**
    160            * @brief  Setup the microcontroller system
    161            *         Initialize the FPU setting, vector table location and External memory 
    162            *         configuration.
    163            * @param  None
    164            * @retval None
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          void SystemInit(void)
    167          {
    168            /* FPU settings ------------------------------------------------------------*/
    169            #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    170              SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
   \                     SystemInit: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3  ;; 0xe000ed88
   \   00000002   0x....             LDR.N    R2,??DataTable3_1  ;; 0xfef6ffff
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF441 0x0170      ORR      R1,R1,#0xF00000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    171            #endif
    172            /* Reset the RCC clock configuration to the default reset state ------------*/
    173            /* Set HSION bit */
    174            RCC->CR |= (uint32_t)0x00000001;
   \   0000000C   0x....             LDR.N    R0,??DataTable3_2  ;; 0x40023800
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    175          
    176            /* Reset CFGR register */
    177            RCC->CFGR = 0x00000000;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6081             STR      R1,[R0, #+8]
    178          
    179            /* Reset HSEON, CSSON and PLLON bits */
    180            RCC->CR &= (uint32_t)0xFEF6FFFF;
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x4011             ANDS     R1,R2,R1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    181          
    182            /* Reset PLLCFGR register */
    183            RCC->PLLCFGR = 0x24003010;
   \   00000020   0x....             LDR.N    R1,??DataTable3_3  ;; 0x24003010
   \   00000022   0x6041             STR      R1,[R0, #+4]
    184          
    185            /* Reset HSEBYP bit */
    186            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    187          
    188            /* Disable all interrupts */
    189            RCC->CIR = 0x00000000;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
    190          
    191          #if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    192            SystemInit_ExtMemCtl(); 
    193          #endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
    194          
    195            /* Configure the Vector Table location add offset address ------------------*/
    196          #ifdef VECT_TAB_SRAM
    197            SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
    198          #else
    199            SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
   \   00000030   0xF04F 0x6000      MOV      R0,#+134217728
   \   00000034   0x....             LDR.N    R1,??DataTable3_4  ;; 0xe000ed08
   \   00000036   0x6008             STR      R0,[R1, #+0]
    200          #endif
    201          }
   \   00000038   0x4770             BX       LR               ;; return
    202          
    203          /**
    204             * @brief  Update SystemCoreClock variable according to Clock Register Values.
    205            *         The SystemCoreClock variable contains the core clock (HCLK), it can
    206            *         be used by the user application to setup the SysTick timer or configure
    207            *         other parameters.
    208            *           
    209            * @note   Each time the core clock (HCLK) changes, this function must be called
    210            *         to update SystemCoreClock variable value. Otherwise, any configuration
    211            *         based on this variable will be incorrect.         
    212            *     
    213            * @note   - The system frequency computed by this function is not the real 
    214            *           frequency in the chip. It is calculated based on the predefined 
    215            *           constant and the selected clock source:
    216            *             
    217            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
    218            *                                              
    219            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
    220            *                          
    221            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
    222            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
    223            *         
    224            *         (*) HSI_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value
    225            *             16 MHz) but the real value may vary depending on the variations
    226            *             in voltage and temperature.   
    227            *    
    228            *         (**) HSE_VALUE is a constant defined in stm32f4xx_hal_conf.h file (its value
    229            *              depends on the application requirements), user has to ensure that HSE_VALUE
    230            *              is same as the real frequency of the crystal used. Otherwise, this function
    231            *              may have wrong result.
    232            *                
    233            *         - The result of this function could be not correct when using fractional
    234            *           value for HSE crystal.
    235            *     
    236            * @param  None
    237            * @retval None
    238            */

   \                                 In section .text, align 2, keep-with-next
    239          void SystemCoreClockUpdate(void)
    240          {
    241            uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
    242            
    243            /* Get SYSCLK source -------------------------------------------------------*/
    244            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \                     SystemCoreClockUpdate: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable3_5  ;; 0x40023804
   \   00000002   0x6841             LDR      R1,[R0, #+4]
    245          
    246            switch (tmp)
   \   00000004   0xF001 0x010C      AND      R1,R1,#0xC
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD002             BEQ.N    ??SystemCoreClockUpdate_0
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD002             BEQ.N    ??SystemCoreClockUpdate_1
   \   00000010   0xE019             B.N      ??SystemCoreClockUpdate_2
    247            {
    248              case 0x00:  /* HSI used as system clock source */
    249                SystemCoreClock = HSI_VALUE;
    250                break;
    251              case 0x04:  /* HSE used as system clock source */
    252                SystemCoreClock = HSE_VALUE;
   \                     ??SystemCoreClockUpdate_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable3_6  ;; 0x17d7840
    253                break;
   \   00000014   0xE018             B.N      ??SystemCoreClockUpdate_3
    254              case 0x08:  /* PLL used as system clock source */
    255          
    256                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
    257                   SYSCLK = PLL_VCO / PLL_P
    258                   */    
    259                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??SystemCoreClockUpdate_1: (+1)
   \   00000016   0x6801             LDR      R1,[R0, #+0]
    260                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
    261                
    262                if (pllsource != 0)
   \   0000001A   0xF3C1 0x5180      UBFX     R1,R1,#+22,#+1
   \   0000001E   0xF002 0x023F      AND      R2,R2,#0x3F
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xBF14             ITE      NE 
    263                {
    264                  /* HSE used as PLL clock source */
    265                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \   00000026   0x....             LDRNE.N  R1,??DataTable3_6  ;; 0x17d7840
    266                }
    267                else
    268                {
    269                  /* HSI used as PLL clock source */
    270                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \   00000028   0x....             LDREQ.N  R1,??DataTable3_7  ;; 0xf42400
   \   0000002A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000002E   0x6802             LDR      R2,[R0, #+0]
   \   00000030   0xF3C2 0x1288      UBFX     R2,R2,#+6,#+9
   \   00000034   0x4351             MULS     R1,R2,R1
    271                }
    272          
    273                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \   00000036   0x6802             LDR      R2,[R0, #+0]
    274                SystemCoreClock = pllvco/pllp;
   \   00000038   0xF3C2 0x4201      UBFX     R2,R2,#+16,#+2
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   \   0000003E   0x0052             LSLS     R2,R2,#+1
   \   00000040   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    275                break;
   \   00000044   0xE000             B.N      ??SystemCoreClockUpdate_3
    276              default:
    277                SystemCoreClock = HSI_VALUE;
   \                     ??SystemCoreClockUpdate_2: (+1)
   \   00000046   0x....             LDR.N    R1,??DataTable3_7  ;; 0xf42400
    278                break;
   \                     ??SystemCoreClockUpdate_3: (+1)
   \   00000048   0x....             LDR.N    R2,??DataTable3_8
   \   0000004A   0x.... 0x....      ADR.W    R3,AHBPrescTable
   \   0000004E   0x6011             STR      R1,[R2, #+0]
    279            }
    280            /* Compute HCLK frequency --------------------------------------------------*/
    281            /* Get HCLK prescaler */
    282            tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
   \   00000050   0x6840             LDR      R0,[R0, #+4]
    283            /* HCLK frequency */
    284            SystemCoreClock >>= tmp;
   \   00000052   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   00000056   0x5CC0             LDRB     R0,[R0, R3]
   \   00000058   0xFA21 0xF000      LSR      R0,R1,R0
   \   0000005C   0x6010             STR      R0,[R2, #+0]
    285          }
   \   0000005E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0xE000ED88         DC32     0xe000ed88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xFEF6FFFF         DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x24003010         DC32     0x24003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     SystemCoreClock
    286          
    287          #if defined (DATA_IN_ExtSRAM) && defined (DATA_IN_ExtSDRAM)
    288          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    289           || defined(STM32F469xx) || defined(STM32F479xx)
    290          /**
    291            * @brief  Setup the external memory controller.
    292            *         Called in startup_stm32f4xx.s before jump to main.
    293            *         This function configures the external memories (SRAM/SDRAM)
    294            *         This SRAM/SDRAM will be used as program data memory (including heap and stack).
    295            * @param  None
    296            * @retval None
    297            */
    298          void SystemInit_ExtMemCtl(void)
    299          {
    300            __IO uint32_t tmp = 0x00;
    301          
    302            register uint32_t tmpreg = 0, timeout = 0xFFFF;
    303            register __IO uint32_t index;
    304          
    305            /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface clock */
    306            RCC->AHB1ENR |= 0x000001F8;
    307          
    308            /* Delay after an RCC peripheral clock enabling */
    309            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);
    310            
    311            /* Connect PDx pins to FMC Alternate function */
    312            GPIOD->AFR[0]  = 0x00CCC0CC;
    313            GPIOD->AFR[1]  = 0xCCCCCCCC;
    314            /* Configure PDx pins in Alternate function mode */  
    315            GPIOD->MODER   = 0xAAAA0A8A;
    316            /* Configure PDx pins speed to 100 MHz */  
    317            GPIOD->OSPEEDR = 0xFFFF0FCF;
    318            /* Configure PDx pins Output type to push-pull */  
    319            GPIOD->OTYPER  = 0x00000000;
    320            /* No pull-up, pull-down for PDx pins */ 
    321            GPIOD->PUPDR   = 0x00000000;
    322          
    323            /* Connect PEx pins to FMC Alternate function */
    324            GPIOE->AFR[0]  = 0xC00CC0CC;
    325            GPIOE->AFR[1]  = 0xCCCCCCCC;
    326            /* Configure PEx pins in Alternate function mode */ 
    327            GPIOE->MODER   = 0xAAAA828A;
    328            /* Configure PEx pins speed to 100 MHz */ 
    329            GPIOE->OSPEEDR = 0xFFFFC3CF;
    330            /* Configure PEx pins Output type to push-pull */  
    331            GPIOE->OTYPER  = 0x00000000;
    332            /* No pull-up, pull-down for PEx pins */ 
    333            GPIOE->PUPDR   = 0x00000000;
    334            
    335            /* Connect PFx pins to FMC Alternate function */
    336            GPIOF->AFR[0]  = 0xCCCCCCCC;
    337            GPIOF->AFR[1]  = 0xCCCCCCCC;
    338            /* Configure PFx pins in Alternate function mode */   
    339            GPIOF->MODER   = 0xAA800AAA;
    340            /* Configure PFx pins speed to 50 MHz */ 
    341            GPIOF->OSPEEDR = 0xAA800AAA;
    342            /* Configure PFx pins Output type to push-pull */  
    343            GPIOF->OTYPER  = 0x00000000;
    344            /* No pull-up, pull-down for PFx pins */ 
    345            GPIOF->PUPDR   = 0x00000000;
    346          
    347            /* Connect PGx pins to FMC Alternate function */
    348            GPIOG->AFR[0]  = 0xCCCCCCCC;
    349            GPIOG->AFR[1]  = 0xCCCCCCCC;
    350            /* Configure PGx pins in Alternate function mode */ 
    351            GPIOG->MODER   = 0xAAAAAAAA;
    352            /* Configure PGx pins speed to 50 MHz */ 
    353            GPIOG->OSPEEDR = 0xAAAAAAAA;
    354            /* Configure PGx pins Output type to push-pull */  
    355            GPIOG->OTYPER  = 0x00000000;
    356            /* No pull-up, pull-down for PGx pins */ 
    357            GPIOG->PUPDR   = 0x00000000;
    358            
    359            /* Connect PHx pins to FMC Alternate function */
    360            GPIOH->AFR[0]  = 0x00C0CC00;
    361            GPIOH->AFR[1]  = 0xCCCCCCCC;
    362            /* Configure PHx pins in Alternate function mode */ 
    363            GPIOH->MODER   = 0xAAAA08A0;
    364            /* Configure PHx pins speed to 50 MHz */ 
    365            GPIOH->OSPEEDR = 0xAAAA08A0;
    366            /* Configure PHx pins Output type to push-pull */  
    367            GPIOH->OTYPER  = 0x00000000;
    368            /* No pull-up, pull-down for PHx pins */ 
    369            GPIOH->PUPDR   = 0x00000000;
    370            
    371            /* Connect PIx pins to FMC Alternate function */
    372            GPIOI->AFR[0]  = 0xCCCCCCCC;
    373            GPIOI->AFR[1]  = 0x00000CC0;
    374            /* Configure PIx pins in Alternate function mode */ 
    375            GPIOI->MODER   = 0x0028AAAA;
    376            /* Configure PIx pins speed to 50 MHz */ 
    377            GPIOI->OSPEEDR = 0x0028AAAA;
    378            /* Configure PIx pins Output type to push-pull */  
    379            GPIOI->OTYPER  = 0x00000000;
    380            /* No pull-up, pull-down for PIx pins */ 
    381            GPIOI->PUPDR   = 0x00000000;
    382            
    383          /*-- FMC Configuration -------------------------------------------------------*/
    384            /* Enable the FMC interface clock */
    385            RCC->AHB3ENR |= 0x00000001;
    386            /* Delay after an RCC peripheral clock enabling */
    387            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    388          
    389            FMC_Bank5_6->SDCR[0] = 0x000019E4;
    390            FMC_Bank5_6->SDTR[0] = 0x01115351;      
    391            
    392            /* SDRAM initialization sequence */
    393            /* Clock enable command */
    394            FMC_Bank5_6->SDCMR = 0x00000011; 
    395            tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    396            while((tmpreg != 0) && (timeout-- > 0))
    397            {
    398              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    399            }
    400          
    401            /* Delay */
    402            for (index = 0; index<1000; index++);
    403            
    404            /* PALL command */
    405            FMC_Bank5_6->SDCMR = 0x00000012;           
    406            timeout = 0xFFFF;
    407            while((tmpreg != 0) && (timeout-- > 0))
    408            {
    409              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    410            }
    411            
    412            /* Auto refresh command */
    413            FMC_Bank5_6->SDCMR = 0x00000073;
    414            timeout = 0xFFFF;
    415            while((tmpreg != 0) && (timeout-- > 0))
    416            {
    417              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    418            }
    419           
    420            /* MRD register program */
    421            FMC_Bank5_6->SDCMR = 0x00046014;
    422            timeout = 0xFFFF;
    423            while((tmpreg != 0) && (timeout-- > 0))
    424            {
    425              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    426            } 
    427            
    428            /* Set refresh count */
    429            tmpreg = FMC_Bank5_6->SDRTR;
    430            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));
    431            
    432            /* Disable write protection */
    433            tmpreg = FMC_Bank5_6->SDCR[0]; 
    434            FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);
    435          
    436          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
    437            /* Configure and enable Bank1_SRAM2 */
    438            FMC_Bank1->BTCR[2]  = 0x00001011;
    439            FMC_Bank1->BTCR[3]  = 0x00000201;
    440            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    441          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 
    442          #if defined(STM32F469xx) || defined(STM32F479xx)
    443            /* Configure and enable Bank1_SRAM2 */
    444            FMC_Bank1->BTCR[2]  = 0x00001091;
    445            FMC_Bank1->BTCR[3]  = 0x00110212;
    446            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    447          #endif /* STM32F469xx || STM32F479xx */
    448          
    449            (void)(tmp); 
    450          }
    451          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    452          #elif defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    453          /**
    454            * @brief  Setup the external memory controller.
    455            *         Called in startup_stm32f4xx.s before jump to main.
    456            *         This function configures the external memories (SRAM/SDRAM)
    457            *         This SRAM/SDRAM will be used as program data memory (including heap and stack).
    458            * @param  None
    459            * @retval None
    460            */
    461          void SystemInit_ExtMemCtl(void)
    462          {
    463            __IO uint32_t tmp = 0x00;
    464          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    465           || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
    466          #if defined (DATA_IN_ExtSDRAM)
    467            register uint32_t tmpreg = 0, timeout = 0xFFFF;
    468            register __IO uint32_t index;
    469          
    470          #if defined(STM32F446xx)
    471            /* Enable GPIOA, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG interface
    472                clock */
    473            RCC->AHB1ENR |= 0x0000007D;
    474          #else
    475            /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface 
    476                clock */
    477            RCC->AHB1ENR |= 0x000001F8;
    478          #endif /* STM32F446xx */  
    479            /* Delay after an RCC peripheral clock enabling */
    480            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);
    481            
    482          #if defined(STM32F446xx)
    483            /* Connect PAx pins to FMC Alternate function */
    484            GPIOA->AFR[0]  |= 0xC0000000;
    485            GPIOA->AFR[1]  |= 0x00000000;
    486            /* Configure PDx pins in Alternate function mode */
    487            GPIOA->MODER   |= 0x00008000;
    488            /* Configure PDx pins speed to 50 MHz */
    489            GPIOA->OSPEEDR |= 0x00008000;
    490            /* Configure PDx pins Output type to push-pull */
    491            GPIOA->OTYPER  |= 0x00000000;
    492            /* No pull-up, pull-down for PDx pins */
    493            GPIOA->PUPDR   |= 0x00000000;
    494          
    495            /* Connect PCx pins to FMC Alternate function */
    496            GPIOC->AFR[0]  |= 0x00CC0000;
    497            GPIOC->AFR[1]  |= 0x00000000;
    498            /* Configure PDx pins in Alternate function mode */
    499            GPIOC->MODER   |= 0x00000A00;
    500            /* Configure PDx pins speed to 50 MHz */
    501            GPIOC->OSPEEDR |= 0x00000A00;
    502            /* Configure PDx pins Output type to push-pull */
    503            GPIOC->OTYPER  |= 0x00000000;
    504            /* No pull-up, pull-down for PDx pins */
    505            GPIOC->PUPDR   |= 0x00000000;
    506          #endif /* STM32F446xx */
    507          
    508            /* Connect PDx pins to FMC Alternate function */
    509            GPIOD->AFR[0]  = 0x000000CC;
    510            GPIOD->AFR[1]  = 0xCC000CCC;
    511            /* Configure PDx pins in Alternate function mode */  
    512            GPIOD->MODER   = 0xA02A000A;
    513            /* Configure PDx pins speed to 50 MHz */  
    514            GPIOD->OSPEEDR = 0xA02A000A;
    515            /* Configure PDx pins Output type to push-pull */  
    516            GPIOD->OTYPER  = 0x00000000;
    517            /* No pull-up, pull-down for PDx pins */ 
    518            GPIOD->PUPDR   = 0x00000000;
    519          
    520            /* Connect PEx pins to FMC Alternate function */
    521            GPIOE->AFR[0]  = 0xC00000CC;
    522            GPIOE->AFR[1]  = 0xCCCCCCCC;
    523            /* Configure PEx pins in Alternate function mode */ 
    524            GPIOE->MODER   = 0xAAAA800A;
    525            /* Configure PEx pins speed to 50 MHz */ 
    526            GPIOE->OSPEEDR = 0xAAAA800A;
    527            /* Configure PEx pins Output type to push-pull */  
    528            GPIOE->OTYPER  = 0x00000000;
    529            /* No pull-up, pull-down for PEx pins */ 
    530            GPIOE->PUPDR   = 0x00000000;
    531          
    532            /* Connect PFx pins to FMC Alternate function */
    533            GPIOF->AFR[0]  = 0xCCCCCCCC;
    534            GPIOF->AFR[1]  = 0xCCCCCCCC;
    535            /* Configure PFx pins in Alternate function mode */   
    536            GPIOF->MODER   = 0xAA800AAA;
    537            /* Configure PFx pins speed to 50 MHz */ 
    538            GPIOF->OSPEEDR = 0xAA800AAA;
    539            /* Configure PFx pins Output type to push-pull */  
    540            GPIOF->OTYPER  = 0x00000000;
    541            /* No pull-up, pull-down for PFx pins */ 
    542            GPIOF->PUPDR   = 0x00000000;
    543          
    544            /* Connect PGx pins to FMC Alternate function */
    545            GPIOG->AFR[0]  = 0xCCCCCCCC;
    546            GPIOG->AFR[1]  = 0xCCCCCCCC;
    547            /* Configure PGx pins in Alternate function mode */ 
    548            GPIOG->MODER   = 0xAAAAAAAA;
    549            /* Configure PGx pins speed to 50 MHz */ 
    550            GPIOG->OSPEEDR = 0xAAAAAAAA;
    551            /* Configure PGx pins Output type to push-pull */  
    552            GPIOG->OTYPER  = 0x00000000;
    553            /* No pull-up, pull-down for PGx pins */ 
    554            GPIOG->PUPDR   = 0x00000000;
    555          
    556          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    557           || defined(STM32F469xx) || defined(STM32F479xx)  
    558            /* Connect PHx pins to FMC Alternate function */
    559            GPIOH->AFR[0]  = 0x00C0CC00;
    560            GPIOH->AFR[1]  = 0xCCCCCCCC;
    561            /* Configure PHx pins in Alternate function mode */ 
    562            GPIOH->MODER   = 0xAAAA08A0;
    563            /* Configure PHx pins speed to 50 MHz */ 
    564            GPIOH->OSPEEDR = 0xAAAA08A0;
    565            /* Configure PHx pins Output type to push-pull */  
    566            GPIOH->OTYPER  = 0x00000000;
    567            /* No pull-up, pull-down for PHx pins */ 
    568            GPIOH->PUPDR   = 0x00000000;
    569            
    570            /* Connect PIx pins to FMC Alternate function */
    571            GPIOI->AFR[0]  = 0xCCCCCCCC;
    572            GPIOI->AFR[1]  = 0x00000CC0;
    573            /* Configure PIx pins in Alternate function mode */ 
    574            GPIOI->MODER   = 0x0028AAAA;
    575            /* Configure PIx pins speed to 50 MHz */ 
    576            GPIOI->OSPEEDR = 0x0028AAAA;
    577            /* Configure PIx pins Output type to push-pull */  
    578            GPIOI->OTYPER  = 0x00000000;
    579            /* No pull-up, pull-down for PIx pins */ 
    580            GPIOI->PUPDR   = 0x00000000;
    581          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    582            
    583          /*-- FMC Configuration -------------------------------------------------------*/
    584            /* Enable the FMC interface clock */
    585            RCC->AHB3ENR |= 0x00000001;
    586            /* Delay after an RCC peripheral clock enabling */
    587            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    588          
    589            /* Configure and enable SDRAM bank1 */
    590          #if defined(STM32F446xx)
    591            FMC_Bank5_6->SDCR[0] = 0x00001954;
    592          #else  
    593            FMC_Bank5_6->SDCR[0] = 0x000019E4;
    594          #endif /* STM32F446xx */
    595            FMC_Bank5_6->SDTR[0] = 0x01115351;      
    596            
    597            /* SDRAM initialization sequence */
    598            /* Clock enable command */
    599            FMC_Bank5_6->SDCMR = 0x00000011; 
    600            tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    601            while((tmpreg != 0) && (timeout-- > 0))
    602            {
    603              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    604            }
    605          
    606            /* Delay */
    607            for (index = 0; index<1000; index++);
    608            
    609            /* PALL command */
    610            FMC_Bank5_6->SDCMR = 0x00000012;           
    611            timeout = 0xFFFF;
    612            while((tmpreg != 0) && (timeout-- > 0))
    613            {
    614              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    615            }
    616            
    617            /* Auto refresh command */
    618          #if defined(STM32F446xx)
    619            FMC_Bank5_6->SDCMR = 0x000000F3;
    620          #else  
    621            FMC_Bank5_6->SDCMR = 0x00000073;
    622          #endif /* STM32F446xx */
    623            timeout = 0xFFFF;
    624            while((tmpreg != 0) && (timeout-- > 0))
    625            {
    626              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    627            }
    628           
    629            /* MRD register program */
    630          #if defined(STM32F446xx)
    631            FMC_Bank5_6->SDCMR = 0x00044014;
    632          #else  
    633            FMC_Bank5_6->SDCMR = 0x00046014;
    634          #endif /* STM32F446xx */
    635            timeout = 0xFFFF;
    636            while((tmpreg != 0) && (timeout-- > 0))
    637            {
    638              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    639            } 
    640            
    641            /* Set refresh count */
    642            tmpreg = FMC_Bank5_6->SDRTR;
    643          #if defined(STM32F446xx)
    644            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000050C<<1));
    645          #else    
    646            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));
    647          #endif /* STM32F446xx */
    648            
    649            /* Disable write protection */
    650            tmpreg = FMC_Bank5_6->SDCR[0]; 
    651            FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);
    652          #endif /* DATA_IN_ExtSDRAM */
    653          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
    654          
    655          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\
    656           || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    657           || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)
    658          
    659          #if defined(DATA_IN_ExtSRAM)
    660          /*-- GPIOs Configuration -----------------------------------------------------*/
    661             /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
    662            RCC->AHB1ENR   |= 0x00000078;
    663            /* Delay after an RCC peripheral clock enabling */
    664            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);
    665            
    666            /* Connect PDx pins to FMC Alternate function */
    667            GPIOD->AFR[0]  = 0x00CCC0CC;
    668            GPIOD->AFR[1]  = 0xCCCCCCCC;
    669            /* Configure PDx pins in Alternate function mode */  
    670            GPIOD->MODER   = 0xAAAA0A8A;
    671            /* Configure PDx pins speed to 100 MHz */  
    672            GPIOD->OSPEEDR = 0xFFFF0FCF;
    673            /* Configure PDx pins Output type to push-pull */  
    674            GPIOD->OTYPER  = 0x00000000;
    675            /* No pull-up, pull-down for PDx pins */ 
    676            GPIOD->PUPDR   = 0x00000000;
    677          
    678            /* Connect PEx pins to FMC Alternate function */
    679            GPIOE->AFR[0]  = 0xC00CC0CC;
    680            GPIOE->AFR[1]  = 0xCCCCCCCC;
    681            /* Configure PEx pins in Alternate function mode */ 
    682            GPIOE->MODER   = 0xAAAA828A;
    683            /* Configure PEx pins speed to 100 MHz */ 
    684            GPIOE->OSPEEDR = 0xFFFFC3CF;
    685            /* Configure PEx pins Output type to push-pull */  
    686            GPIOE->OTYPER  = 0x00000000;
    687            /* No pull-up, pull-down for PEx pins */ 
    688            GPIOE->PUPDR   = 0x00000000;
    689          
    690            /* Connect PFx pins to FMC Alternate function */
    691            GPIOF->AFR[0]  = 0x00CCCCCC;
    692            GPIOF->AFR[1]  = 0xCCCC0000;
    693            /* Configure PFx pins in Alternate function mode */   
    694            GPIOF->MODER   = 0xAA000AAA;
    695            /* Configure PFx pins speed to 100 MHz */ 
    696            GPIOF->OSPEEDR = 0xFF000FFF;
    697            /* Configure PFx pins Output type to push-pull */  
    698            GPIOF->OTYPER  = 0x00000000;
    699            /* No pull-up, pull-down for PFx pins */ 
    700            GPIOF->PUPDR   = 0x00000000;
    701          
    702            /* Connect PGx pins to FMC Alternate function */
    703            GPIOG->AFR[0]  = 0x00CCCCCC;
    704            GPIOG->AFR[1]  = 0x000000C0;
    705            /* Configure PGx pins in Alternate function mode */ 
    706            GPIOG->MODER   = 0x00085AAA;
    707            /* Configure PGx pins speed to 100 MHz */ 
    708            GPIOG->OSPEEDR = 0x000CAFFF;
    709            /* Configure PGx pins Output type to push-pull */  
    710            GPIOG->OTYPER  = 0x00000000;
    711            /* No pull-up, pull-down for PGx pins */ 
    712            GPIOG->PUPDR   = 0x00000000;
    713            
    714          /*-- FMC/FSMC Configuration --------------------------------------------------*/
    715            /* Enable the FMC/FSMC interface clock */
    716            RCC->AHB3ENR         |= 0x00000001;
    717          
    718          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
    719            /* Delay after an RCC peripheral clock enabling */
    720            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    721            /* Configure and enable Bank1_SRAM2 */
    722            FMC_Bank1->BTCR[2]  = 0x00001011;
    723            FMC_Bank1->BTCR[3]  = 0x00000201;
    724            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    725          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 
    726          #if defined(STM32F469xx) || defined(STM32F479xx)
    727            /* Delay after an RCC peripheral clock enabling */
    728            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    729            /* Configure and enable Bank1_SRAM2 */
    730            FMC_Bank1->BTCR[2]  = 0x00001091;
    731            FMC_Bank1->BTCR[3]  = 0x00110212;
    732            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    733          #endif /* STM32F469xx || STM32F479xx */
    734          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)\
    735             || defined(STM32F412Zx) || defined(STM32F412Vx)
    736            /* Delay after an RCC peripheral clock enabling */
    737            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);
    738            /* Configure and enable Bank1_SRAM2 */
    739            FSMC_Bank1->BTCR[2]  = 0x00001011;
    740            FSMC_Bank1->BTCR[3]  = 0x00000201;
    741            FSMC_Bank1E->BWTR[2] = 0x0FFFFFFF;
    742          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx */
    743          
    744          #endif /* DATA_IN_ExtSRAM */
    745          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx ||\
    746                    STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx  */ 
    747            (void)(tmp); 
    748          }
    749          #endif /* DATA_IN_ExtSRAM && DATA_IN_ExtSDRAM */
    750          /**
    751            * @}
    752            */
    753          
    754          /**
    755            * @}
    756            */
    757          
    758          /**
    759            * @}
    760            */
    761          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SystemCoreClockUpdate
       0   SystemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
      16  AHBPrescTable
       8  APBPrescTable
       4  SystemCoreClock
      96  SystemCoreClockUpdate
      58  SystemInit

 
   4 bytes in section .data
   8 bytes in section .rodata
 206 bytes in section .text
 
 206 bytes of CODE  memory
   8 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none
