###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#    Command line =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\stm32f4xx_hal_tim.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\stm32f4xx_hal_tim.o
#
###############################################################################

C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + Time Base Initialization
      9            *           + Time Base Start
     10            *           + Time Base Start Interruption
     11            *           + Time Base Start DMA
     12            *           + Time Output Compare/PWM Initialization
     13            *           + Time Output Compare/PWM Channel Configuration
     14            *           + Time Output Compare/PWM  Start
     15            *           + Time Output Compare/PWM  Start Interruption
     16            *           + Time Output Compare/PWM Start DMA
     17            *           + Time Input Capture Initialization
     18            *           + Time Input Capture Channel Configuration
     19            *           + Time Input Capture Start
     20            *           + Time Input Capture Start Interruption 
     21            *           + Time Input Capture Start DMA
     22            *           + Time One Pulse Initialization
     23            *           + Time One Pulse Channel Configuration
     24            *           + Time One Pulse Start 
     25            *           + Time Encoder Interface Initialization
     26            *           + Time Encoder Interface Start
     27            *           + Time Encoder Interface Start Interruption
     28            *           + Time Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + Time OCRef clear configuration
     31            *           + Time External Clock configuration
     32            @verbatim 
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include: 
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output               
     45             
     46                                  ##### How to use this driver #####
     47            ==============================================================================
     48              [..]
     49               (#) Initialize the TIM low level resources by implementing the following functions 
     50                   depending from feature used :
     51                     (++) Time Base : HAL_TIM_Base_MspInit() 
     52                     (++) Input Capture : HAL_TIM_IC_MspInit()
     53                     (++) Output Compare : HAL_TIM_OC_MspInit()
     54                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     55                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     56                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     57                     
     58               (#) Initialize the TIM low level resources :
     59                  (##) Enable the TIM interface clock using __TIMx_CLK_ENABLE(); 
     60                  (##) TIM pins configuration
     61                      (+++) Enable the clock for the TIM GPIOs using the following function:
     62                           __GPIOx_CLK_ENABLE();   
     63                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();  
     64          
     65               (#) The external Clock can be configured, if needed (the default clock is the 
     66                   internal clock from the APBx), using the following function:
     67                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     68                   any start function.
     69            
     70               (#) Configure the TIM in the desired functioning mode using one of the 
     71                   initialization function of this driver:
     72                   (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     73                   (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     74                        Output Compare signal.
     75                   (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     76                        PWM signal.
     77                   (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     78                        external signal.
     79                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     80                        in One Pulse Mode.
     81                   (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     82                   
     83               (#) Activate the TIM peripheral using one of the start functions depending from the feature used: 
     84                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     85                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     86                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     87                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     88                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     89                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     90          
     91               (#) The DMA Burst is managed with the two following functions:
     92                   HAL_TIM_DMABurst_WriteStart()
     93                   HAL_TIM_DMABurst_ReadStart()
     94            
     95            @endverbatim
     96            ******************************************************************************
     97            * @attention
     98            *
     99            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
    100            *
    101            * Redistribution and use in source and binary forms, with or without modification,
    102            * are permitted provided that the following conditions are met:
    103            *   1. Redistributions of source code must retain the above copyright notice,
    104            *      this list of conditions and the following disclaimer.
    105            *   2. Redistributions in binary form must reproduce the above copyright notice,
    106            *      this list of conditions and the following disclaimer in the documentation
    107            *      and/or other materials provided with the distribution.
    108            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    109            *      may be used to endorse or promote products derived from this software
    110            *      without specific prior written permission.
    111            *
    112            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    113            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    114            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    115            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    116            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    117            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    118            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    119            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    120            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    121            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    122            *
    123            ******************************************************************************
    124            */ 
    125          
    126          /* Includes ------------------------------------------------------------------*/
    127          #include "stm32f4xx_hal.h"
    128          
    129          /** @addtogroup STM32F4xx_HAL_Driver
    130            * @{
    131            */
    132          
    133          /** @defgroup TIM TIM
    134            * @brief TIM HAL module driver
    135            * @{
    136            */
    137          
    138          #ifdef HAL_TIM_MODULE_ENABLED
    139          
    140          /* Private typedef -----------------------------------------------------------*/
    141          /* Private define ------------------------------------------------------------*/
    142          /* Private macro -------------------------------------------------------------*/
    143          /* Private variables ---------------------------------------------------------*/
    144          /** @addtogroup TIM_Private_Functions
    145            * @{
    146            */
    147          /* Private function prototypes -----------------------------------------------*/
    148          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    149          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    150          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    151          
    152          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    153          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    154                                 uint32_t TIM_ICFilter);
    155          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    156          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    157                                 uint32_t TIM_ICFilter);
    158          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    159                                 uint32_t TIM_ICFilter);
    160          
    161          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
    162                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    163          
    164          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t TIM_ITRx);
    165          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    166          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    167          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    168                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    169          /**
    170            * @}
    171            */
    172            
    173          /* Exported functions --------------------------------------------------------*/
    174          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    175            * @{
    176            */
    177          
    178          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    179           *  @brief    Time Base functions 
    180           *
    181          @verbatim    
    182            ==============================================================================
    183                        ##### Time Base functions #####
    184            ==============================================================================
    185            [..]  
    186              This section provides functions allowing to:
    187              (+) Initialize and configure the TIM base. 
    188              (+) De-initialize the TIM base.
    189              (+) Start the Time Base.
    190              (+) Stop the Time Base.
    191              (+) Start the Time Base and enable interrupt.
    192              (+) Stop the Time Base and disable interrupt.
    193              (+) Start the Time Base and enable DMA transfer.
    194              (+) Stop the Time Base and disable DMA transfer.
    195           
    196          @endverbatim
    197            * @{
    198            */
    199          /**
    200            * @brief  Initializes the TIM Time base Unit according to the specified
    201            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    202            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    203            *                the configuration information for TIM module.
    204            * @retval HAL status
    205            */
    206          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    207          { 
    208            /* Check the TIM handle allocation */
    209            if(htim == NULL)
    210            {
    211              return HAL_ERROR;
    212            }
    213            
    214            /* Check the parameters */
    215            assert_param(IS_TIM_INSTANCE(htim->Instance)); 
    216            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    217            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    218            
    219            if(htim->State == HAL_TIM_STATE_RESET)
    220            {  
    221              /* Allocate lock resource and initialize it */
    222              htim->Lock = HAL_UNLOCKED;
    223              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    224              HAL_TIM_Base_MspInit(htim);
    225            }
    226            
    227            /* Set the TIM state */
    228            htim->State= HAL_TIM_STATE_BUSY;
    229            
    230            /* Set the Time Base configuration */
    231            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
    232            
    233            /* Initialize the TIM state*/
    234            htim->State= HAL_TIM_STATE_READY;
    235            
    236            return HAL_OK;
    237          }
    238          
    239          /**
    240            * @brief  DeInitializes the TIM Base peripheral 
    241            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    242            *                the configuration information for TIM module.
    243            * @retval HAL status
    244            */
    245          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    246          {  
    247            /* Check the parameters */
    248            assert_param(IS_TIM_INSTANCE(htim->Instance));
    249          
    250            htim->State = HAL_TIM_STATE_BUSY;
    251             
    252            /* Disable the TIM Peripheral Clock */
    253            __HAL_TIM_DISABLE(htim);
    254              
    255            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    256            HAL_TIM_Base_MspDeInit(htim);
    257            
    258            /* Change TIM state */  
    259            htim->State = HAL_TIM_STATE_RESET; 
    260            
    261            /* Release Lock */
    262            __HAL_UNLOCK(htim);
    263          
    264            return HAL_OK;
    265          }
    266          
    267          /**
    268            * @brief  Initializes the TIM Base MSP.
    269            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    270            *                the configuration information for TIM module.
    271            * @retval None
    272            */
    273          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    274          {
    275            /* Prevent unused argument(s) compilation warning */
    276            UNUSED(htim);
    277            /* NOTE : This function Should not be modified, when the callback is needed,
    278                      the HAL_TIM_Base_MspInit could be implemented in the user file
    279             */
    280          }
    281          
    282          /**
    283            * @brief  DeInitializes TIM Base MSP.
    284            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    285            *                the configuration information for TIM module.
    286            * @retval None
    287            */
    288          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    289          {
    290            /* Prevent unused argument(s) compilation warning */
    291            UNUSED(htim);
    292            /* NOTE : This function Should not be modified, when the callback is needed,
    293                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    294             */
    295          }
    296          
    297          /**
    298            * @brief  Starts the TIM Base generation.
    299            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    300            *                the configuration information for TIM module.
    301            * @retval HAL status
    302            */
    303          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    304          {
    305            /* Check the parameters */
    306            assert_param(IS_TIM_INSTANCE(htim->Instance));
    307            
    308            /* Set the TIM state */
    309            htim->State= HAL_TIM_STATE_BUSY;
    310            
    311            /* Enable the Peripheral */
    312            __HAL_TIM_ENABLE(htim);
    313            
    314            /* Change the TIM state*/
    315            htim->State= HAL_TIM_STATE_READY;
    316            
    317            /* Return function status */
    318            return HAL_OK;
    319          }
    320          
    321          /**
    322            * @brief  Stops the TIM Base generation.
    323            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    324            *                the configuration information for TIM module.
    325            * @retval HAL status
    326            */
    327          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    328          {
    329            /* Check the parameters */
    330            assert_param(IS_TIM_INSTANCE(htim->Instance));
    331            
    332            /* Set the TIM state */
    333            htim->State= HAL_TIM_STATE_BUSY;
    334            
    335            /* Disable the Peripheral */
    336            __HAL_TIM_DISABLE(htim);
    337            
    338            /* Change the TIM state*/
    339            htim->State= HAL_TIM_STATE_READY;
    340            
    341            /* Return function status */
    342            return HAL_OK;
    343          }
    344          
    345          /**
    346            * @brief  Starts the TIM Base generation in interrupt mode.
    347            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    348            *                the configuration information for TIM module.
    349            * @retval HAL status
    350            */
    351          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    352          {
    353            /* Check the parameters */
    354            assert_param(IS_TIM_INSTANCE(htim->Instance));
    355            
    356            /* Enable the TIM Update interrupt */
    357            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
    358                
    359            /* Enable the Peripheral */
    360            __HAL_TIM_ENABLE(htim);
    361                
    362            /* Return function status */
    363            return HAL_OK;
    364          }
    365          
    366          /**
    367            * @brief  Stops the TIM Base generation in interrupt mode.
    368            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    369            *                the configuration information for TIM module.
    370            * @retval HAL status
    371            */
    372          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    373          {
    374            /* Check the parameters */
    375            assert_param(IS_TIM_INSTANCE(htim->Instance));
    376            /* Disable the TIM Update interrupt */
    377            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
    378                
    379            /* Disable the Peripheral */
    380            __HAL_TIM_DISABLE(htim);
    381              
    382            /* Return function status */
    383            return HAL_OK;
    384          }
    385          
    386          /**
    387            * @brief  Starts the TIM Base generation in DMA mode.
    388            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    389            *                the configuration information for TIM module.
    390            * @param  pData The source Buffer address.
    391            * @param  Length The length of data to be transferred from memory to peripheral.
    392            * @retval HAL status
    393            */
    394          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    395          {
    396            /* Check the parameters */
    397            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance)); 
    398            
    399            if((htim->State == HAL_TIM_STATE_BUSY))
    400            {
    401               return HAL_BUSY;
    402            }
    403            else if((htim->State == HAL_TIM_STATE_READY))
    404            {
    405              if((pData == 0U) && (Length > 0)) 
    406              {
    407                return HAL_ERROR;                                    
    408              }
    409              else
    410              {
    411                htim->State = HAL_TIM_STATE_BUSY;
    412              }
    413            }  
    414            /* Set the DMA Period elapsed callback */
    415            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
    416               
    417            /* Set the DMA error callback */
    418            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
    419            
    420            /* Enable the DMA Stream */
    421            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
    422            
    423            /* Enable the TIM Update DMA request */
    424            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
    425          
    426            /* Enable the Peripheral */
    427            __HAL_TIM_ENABLE(htim);  
    428            
    429            /* Return function status */
    430            return HAL_OK;
    431          }
    432          
    433          /**
    434            * @brief  Stops the TIM Base generation in DMA mode.
    435            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    436            *                the configuration information for TIM module.
    437            * @retval HAL status
    438            */
    439          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    443            
    444            /* Disable the TIM Update DMA request */
    445            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
    446                
    447            /* Disable the Peripheral */
    448            __HAL_TIM_DISABLE(htim);
    449              
    450            /* Change the htim state */
    451            htim->State = HAL_TIM_STATE_READY;
    452                
    453            /* Return function status */
    454            return HAL_OK;
    455          }
    456          /**
    457            * @}
    458            */
    459            
    460          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    461           *  @brief    Time Output Compare functions 
    462           *
    463          @verbatim    
    464            ==============================================================================
    465                            ##### Time Output Compare functions #####
    466            ==============================================================================
    467            [..]
    468              This section provides functions allowing to:
    469              (+) Initialize and configure the TIM Output Compare. 
    470              (+) De-initialize the TIM Output Compare.
    471              (+) Start the Time Output Compare.
    472              (+) Stop the Time Output Compare.
    473              (+) Start the Time Output Compare and enable interrupt.
    474              (+) Stop the Time Output Compare and disable interrupt.
    475              (+) Start the Time Output Compare and enable DMA transfer.
    476              (+) Stop the Time Output Compare and disable DMA transfer.
    477           
    478          @endverbatim
    479            * @{
    480            */
    481          /**
    482            * @brief  Initializes the TIM Output Compare according to the specified
    483            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    484            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    485            *                the configuration information for TIM module.
    486            * @retval HAL status
    487            */
    488          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    489          {
    490            /* Check the TIM handle allocation */
    491            if(htim == NULL)
    492            {
    493              return HAL_ERROR;
    494            }
    495          
    496            /* Check the parameters */
    497            assert_param(IS_TIM_INSTANCE(htim->Instance));
    498            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    499            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    500           
    501            if(htim->State == HAL_TIM_STATE_RESET)
    502            { 
    503              /* Allocate lock resource and initialize it */
    504              htim->Lock = HAL_UNLOCKED;
    505              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    506              HAL_TIM_OC_MspInit(htim);
    507            }
    508            
    509            /* Set the TIM state */
    510            htim->State= HAL_TIM_STATE_BUSY;
    511            
    512            /* Init the base time for the Output Compare */  
    513            TIM_Base_SetConfig(htim->Instance,  &htim->Init); 
    514            
    515            /* Initialize the TIM state*/
    516            htim->State= HAL_TIM_STATE_READY;
    517            
    518            return HAL_OK;
    519          }
    520          
    521          /**
    522            * @brief  DeInitializes the TIM peripheral 
    523            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    524            *                the configuration information for TIM module.
    525            * @retval HAL status
    526            */
    527          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    528          {
    529            /* Check the parameters */
    530            assert_param(IS_TIM_INSTANCE(htim->Instance));
    531            
    532             htim->State = HAL_TIM_STATE_BUSY;
    533             
    534            /* Disable the TIM Peripheral Clock */
    535            __HAL_TIM_DISABLE(htim);
    536            
    537            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    538            HAL_TIM_OC_MspDeInit(htim);
    539              
    540            /* Change TIM state */  
    541            htim->State = HAL_TIM_STATE_RESET; 
    542          
    543            /* Release Lock */
    544            __HAL_UNLOCK(htim);
    545          
    546            return HAL_OK;
    547          }
    548          
    549          /**
    550            * @brief  Initializes the TIM Output Compare MSP.
    551            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    552            *                the configuration information for TIM module.
    553            * @retval None
    554            */
    555          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    556          {
    557            /* Prevent unused argument(s) compilation warning */
    558            UNUSED(htim);
    559            /* NOTE : This function Should not be modified, when the callback is needed,
    560                      the HAL_TIM_OC_MspInit could be implemented in the user file
    561             */
    562          }
    563          
    564          /**
    565            * @brief  DeInitializes TIM Output Compare MSP.
    566            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    567            *                the configuration information for TIM module.
    568            * @retval None
    569            */
    570          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    571          {
    572            /* Prevent unused argument(s) compilation warning */
    573            UNUSED(htim);
    574            /* NOTE : This function Should not be modified, when the callback is needed,
    575                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    576             */
    577          }
    578          
    579          /**
    580            * @brief  Starts the TIM Output Compare signal generation.
    581            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    582            *                the configuration information for TIM module.  
    583            * @param  Channel TIM Channel to be enabled.
    584            *          This parameter can be one of the following values:
    585            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    586            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    587            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    588            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected   
    589            * @retval HAL status
    590            */
    591          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    592          {
    593            /* Check the parameters */
    594            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    595            
    596            /* Enable the Output compare channel */
    597            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    598            
    599            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
    600            {
    601              /* Enable the main output */
    602              __HAL_TIM_MOE_ENABLE(htim);
    603            }
    604            
    605            /* Enable the Peripheral */
    606            __HAL_TIM_ENABLE(htim); 
    607            
    608            /* Return function status */
    609            return HAL_OK;
    610          }
    611          
    612          /**
    613            * @brief  Stops the TIM Output Compare signal generation.
    614            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    615            *                the configuration information for TIM module.
    616            * @param  Channel TIM Channel to be disabled.
    617            *          This parameter can be one of the following values:
    618            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    619            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    620            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    621            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    622            * @retval HAL status
    623            */
    624          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    625          {
    626            /* Check the parameters */
    627            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    628            
    629            /* Disable the Output compare channel */
    630            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    631            
    632            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
    633            {
    634              /* Disable the Main Output */
    635              __HAL_TIM_MOE_DISABLE(htim);
    636            }  
    637            
    638            /* Disable the Peripheral */
    639            __HAL_TIM_DISABLE(htim);  
    640            
    641            /* Return function status */
    642            return HAL_OK;
    643          }  
    644          
    645          /**
    646            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    647            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    648            *                the configuration information for TIM module.
    649            * @param  Channel TIM Channel to be enabled.
    650            *          This parameter can be one of the following values:
    651            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    652            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    653            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    654            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    655            * @retval HAL status
    656            */
    657          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    658          {
    659            /* Check the parameters */
    660            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    661            
    662            switch (Channel)
    663            {
    664              case TIM_CHANNEL_1:
    665              {       
    666                /* Enable the TIM Capture/Compare 1 interrupt */
    667                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    668              }
    669              break;
    670              
    671              case TIM_CHANNEL_2:
    672              {
    673                /* Enable the TIM Capture/Compare 2 interrupt */
    674                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    675              }
    676              break;
    677              
    678              case TIM_CHANNEL_3:
    679              {
    680                /* Enable the TIM Capture/Compare 3 interrupt */
    681                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    682              }
    683              break;
    684              
    685              case TIM_CHANNEL_4:
    686              {
    687                /* Enable the TIM Capture/Compare 4 interrupt */
    688                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
    689              }
    690              break;
    691              
    692              default:
    693              break;
    694            } 
    695          
    696            /* Enable the Output compare channel */
    697            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    698            
    699            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
    700            {
    701              /* Enable the main output */
    702              __HAL_TIM_MOE_ENABLE(htim);
    703            }
    704          
    705            /* Enable the Peripheral */
    706            __HAL_TIM_ENABLE(htim);
    707            
    708            /* Return function status */
    709            return HAL_OK;
    710          }
    711          
    712          /**
    713            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    714            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    715            *                the configuration information for TIM module.
    716            * @param  Channel TIM Channel to be disabled.
    717            *          This parameter can be one of the following values:
    718            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    719            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    720            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    721            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    722            * @retval HAL status
    723            */
    724          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    725          {
    726            /* Check the parameters */
    727            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    728            
    729            switch (Channel)
    730            {
    731              case TIM_CHANNEL_1:
    732              {       
    733                /* Disable the TIM Capture/Compare 1 interrupt */
    734                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    735              }
    736              break;
    737              
    738              case TIM_CHANNEL_2:
    739              {
    740                /* Disable the TIM Capture/Compare 2 interrupt */
    741                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    742              }
    743              break;
    744              
    745              case TIM_CHANNEL_3:
    746              {
    747                /* Disable the TIM Capture/Compare 3 interrupt */
    748                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    749              }
    750              break;
    751              
    752              case TIM_CHANNEL_4:
    753              {
    754                /* Disable the TIM Capture/Compare 4 interrupt */
    755                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
    756              }
    757              break;
    758              
    759              default:
    760              break; 
    761            } 
    762            
    763            /* Disable the Output compare channel */
    764            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
    765            
    766            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
    767            {
    768              /* Disable the Main Output */
    769              __HAL_TIM_MOE_DISABLE(htim);
    770            }
    771            
    772            /* Disable the Peripheral */
    773            __HAL_TIM_DISABLE(htim);  
    774            
    775            /* Return function status */
    776            return HAL_OK;
    777          }
    778          
    779          /**
    780            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    781            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    782            *                the configuration information for TIM module.
    783            * @param  Channel TIM Channel to be enabled.
    784            *          This parameter can be one of the following values:
    785            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    786            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    787            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    788            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    789            * @param  pData The source Buffer address.
    790            * @param  Length The length of data to be transferred from memory to TIM peripheral
    791            * @retval HAL status
    792            */
    793          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    794          {
    795            /* Check the parameters */
    796            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    797            
    798            if((htim->State == HAL_TIM_STATE_BUSY))
    799            {
    800               return HAL_BUSY;
    801            }
    802            else if((htim->State == HAL_TIM_STATE_READY))
    803            {
    804              if(((uint32_t)pData == 0U) && (Length > 0)) 
    805              {
    806                return HAL_ERROR;                                    
    807              }
    808              else
    809              {
    810                htim->State = HAL_TIM_STATE_BUSY;
    811              }
    812            }    
    813            switch (Channel)
    814            {
    815              case TIM_CHANNEL_1:
    816              {      
    817                /* Set the DMA Period elapsed callback */
    818                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
    819               
    820                /* Set the DMA error callback */
    821                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
    822                
    823                /* Enable the DMA Stream */
    824                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
    825                
    826                /* Enable the TIM Capture/Compare 1 DMA request */
    827                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
    828              }
    829              break;
    830              
    831              case TIM_CHANNEL_2:
    832              {
    833                /* Set the DMA Period elapsed callback */
    834                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
    835               
    836                /* Set the DMA error callback */
    837                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
    838                
    839                /* Enable the DMA Stream */
    840                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
    841                
    842                /* Enable the TIM Capture/Compare 2 DMA request */
    843                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
    844              }
    845              break;
    846              
    847              case TIM_CHANNEL_3:
    848              {
    849                /* Set the DMA Period elapsed callback */
    850                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
    851               
    852                /* Set the DMA error callback */
    853                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
    854                
    855                /* Enable the DMA Stream */
    856                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
    857                
    858                /* Enable the TIM Capture/Compare 3 DMA request */
    859                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
    860              }
    861              break;
    862              
    863              case TIM_CHANNEL_4:
    864              {
    865               /* Set the DMA Period elapsed callback */
    866                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
    867               
    868                /* Set the DMA error callback */
    869                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
    870                
    871                /* Enable the DMA Stream */
    872                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
    873                
    874                /* Enable the TIM Capture/Compare 4 DMA request */
    875                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
    876              }
    877              break;
    878              
    879              default:
    880              break;
    881            }
    882          
    883            /* Enable the Output compare channel */
    884            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    885            
    886            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
    887            {
    888              /* Enable the main output */
    889              __HAL_TIM_MOE_ENABLE(htim);
    890            }  
    891            
    892            /* Enable the Peripheral */
    893            __HAL_TIM_ENABLE(htim); 
    894            
    895            /* Return function status */
    896            return HAL_OK;
    897          }
    898          
    899          /**
    900            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    901            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    902            *                the configuration information for TIM module.
    903            * @param  Channel TIM Channel to be disabled.
    904            *          This parameter can be one of the following values:
    905            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    906            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    907            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    908            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    909            * @retval HAL status
    910            */
    911          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    912          {
    913            /* Check the parameters */
    914            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    915            
    916            switch (Channel)
    917            {
    918              case TIM_CHANNEL_1:
    919              {       
    920                /* Disable the TIM Capture/Compare 1 DMA request */
    921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
    922              }
    923              break;
    924              
    925              case TIM_CHANNEL_2:
    926              {
    927                /* Disable the TIM Capture/Compare 2 DMA request */
    928                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
    929              }
    930              break;
    931              
    932              case TIM_CHANNEL_3:
    933              {
    934                /* Disable the TIM Capture/Compare 3 DMA request */
    935                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
    936              }
    937              break;
    938              
    939              case TIM_CHANNEL_4:
    940              {
    941                /* Disable the TIM Capture/Compare 4 interrupt */
    942                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
    943              }
    944              break;
    945              
    946              default:
    947              break;
    948            } 
    949            
    950            /* Disable the Output compare channel */
    951            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    952            
    953            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
    954            {
    955              /* Disable the Main Output */
    956              __HAL_TIM_MOE_DISABLE(htim);
    957            }
    958            
    959            /* Disable the Peripheral */
    960            __HAL_TIM_DISABLE(htim);
    961            
    962            /* Change the htim state */
    963            htim->State = HAL_TIM_STATE_READY;
    964            
    965            /* Return function status */
    966            return HAL_OK;
    967          }
    968          /**
    969            * @}
    970            */
    971          
    972          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    973           *  @brief    Time PWM functions 
    974           *
    975          @verbatim    
    976            ==============================================================================
    977                                    ##### Time PWM functions #####
    978            ==============================================================================
    979            [..]  
    980              This section provides functions allowing to:
    981              (+) Initialize and configure the TIM OPWM. 
    982              (+) De-initialize the TIM PWM.
    983              (+) Start the Time PWM.
    984              (+) Stop the Time PWM.
    985              (+) Start the Time PWM and enable interrupt.
    986              (+) Stop the Time PWM and disable interrupt.
    987              (+) Start the Time PWM and enable DMA transfer.
    988              (+) Stop the Time PWM and disable DMA transfer.
    989           
    990          @endverbatim
    991            * @{
    992            */
    993          /**
    994            * @brief  Initializes the TIM PWM Time Base according to the specified
    995            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    996            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
    997            *                the configuration information for TIM module.
    998            * @retval HAL status
    999            */
   1000          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1001          {
   1002            /* Check the TIM handle allocation */
   1003            if(htim == NULL)
   1004            {
   1005              return HAL_ERROR;
   1006            }
   1007          
   1008            /* Check the parameters */
   1009            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1010            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1011            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1012          
   1013            if(htim->State == HAL_TIM_STATE_RESET)
   1014            {
   1015              /* Allocate lock resource and initialize it */
   1016              htim->Lock = HAL_UNLOCKED;
   1017              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1018              HAL_TIM_PWM_MspInit(htim);
   1019            }
   1020          
   1021            /* Set the TIM state */
   1022            htim->State= HAL_TIM_STATE_BUSY;  
   1023            
   1024            /* Init the base time for the PWM */  
   1025            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   1026             
   1027            /* Initialize the TIM state*/
   1028            htim->State= HAL_TIM_STATE_READY;
   1029            
   1030            return HAL_OK;
   1031          }  
   1032          
   1033          /**
   1034            * @brief  DeInitializes the TIM peripheral 
   1035            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1036            *                the configuration information for TIM module.
   1037            * @retval HAL status
   1038            */
   1039          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1040          {
   1041            /* Check the parameters */
   1042            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1043            
   1044            htim->State = HAL_TIM_STATE_BUSY;
   1045            
   1046            /* Disable the TIM Peripheral Clock */
   1047            __HAL_TIM_DISABLE(htim);
   1048              
   1049            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1050            HAL_TIM_PWM_MspDeInit(htim);
   1051              
   1052            /* Change TIM state */  
   1053            htim->State = HAL_TIM_STATE_RESET; 
   1054          
   1055            /* Release Lock */
   1056            __HAL_UNLOCK(htim);
   1057          
   1058            return HAL_OK;
   1059          }
   1060          
   1061          /**
   1062            * @brief  Initializes the TIM PWM MSP.
   1063            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1064            *                the configuration information for TIM module.
   1065            * @retval None
   1066            */
   1067          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1068          {
   1069            /* Prevent unused argument(s) compilation warning */
   1070            UNUSED(htim);
   1071            /* NOTE : This function Should not be modified, when the callback is needed,
   1072                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1073             */
   1074          }
   1075          
   1076          /**
   1077            * @brief  DeInitializes TIM PWM MSP.
   1078            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1079            *                the configuration information for TIM module.
   1080            * @retval None
   1081            */
   1082          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1083          {
   1084            /* Prevent unused argument(s) compilation warning */
   1085            UNUSED(htim);
   1086            /* NOTE : This function Should not be modified, when the callback is needed,
   1087                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1088             */
   1089          }
   1090          
   1091          /**
   1092            * @brief  Starts the PWM signal generation.
   1093            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1094            *                the configuration information for TIM module.
   1095            * @param  Channel TIM Channels to be enabled.
   1096            *          This parameter can be one of the following values:
   1097            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1098            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1099            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1100            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1101            * @retval HAL status
   1102            */
   1103          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1104          {
   1105            /* Check the parameters */
   1106            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1107          
   1108            /* Enable the Capture compare channel */
   1109            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1110            
   1111            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   1112            {
   1113              /* Enable the main output */
   1114              __HAL_TIM_MOE_ENABLE(htim);
   1115            }
   1116              
   1117            /* Enable the Peripheral */
   1118            __HAL_TIM_ENABLE(htim);
   1119            
   1120            /* Return function status */
   1121            return HAL_OK;
   1122          } 
   1123          
   1124          /**
   1125            * @brief  Stops the PWM signal generation.
   1126            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1127            *                the configuration information for TIM module.
   1128            * @param  Channel TIM Channels to be disabled.
   1129            *          This parameter can be one of the following values:
   1130            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1131            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1132            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1133            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1134            * @retval HAL status
   1135            */
   1136          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1137          { 
   1138            /* Check the parameters */
   1139            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1140              
   1141            /* Disable the Capture compare channel */
   1142            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1143            
   1144            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   1145            {
   1146              /* Disable the Main Output */
   1147              __HAL_TIM_MOE_DISABLE(htim);
   1148            }
   1149            
   1150            /* Disable the Peripheral */
   1151            __HAL_TIM_DISABLE(htim);
   1152            
   1153            /* Change the htim state */
   1154            htim->State = HAL_TIM_STATE_READY;
   1155            
   1156            /* Return function status */
   1157            return HAL_OK;
   1158          } 
   1159          
   1160          /**
   1161            * @brief  Starts the PWM signal generation in interrupt mode.
   1162            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1163            *                the configuration information for TIM module.
   1164            * @param  Channel TIM Channel to be enabled.
   1165            *          This parameter can be one of the following values:
   1166            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1167            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1168            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1169            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1170            * @retval HAL status
   1171            */
   1172          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1173          {
   1174            /* Check the parameters */
   1175            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1176            
   1177            switch (Channel)
   1178            {
   1179              case TIM_CHANNEL_1:
   1180              {       
   1181                /* Enable the TIM Capture/Compare 1 interrupt */
   1182                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1183              }
   1184              break;
   1185              
   1186              case TIM_CHANNEL_2:
   1187              {
   1188                /* Enable the TIM Capture/Compare 2 interrupt */
   1189                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1190              }
   1191              break;
   1192              
   1193              case TIM_CHANNEL_3:
   1194              {
   1195                /* Enable the TIM Capture/Compare 3 interrupt */
   1196                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1197              }
   1198              break;
   1199              
   1200              case TIM_CHANNEL_4:
   1201              {
   1202                /* Enable the TIM Capture/Compare 4 interrupt */
   1203                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1204              }
   1205              break;
   1206              
   1207              default:
   1208              break;
   1209            } 
   1210            
   1211            /* Enable the Capture compare channel */
   1212            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1213            
   1214            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   1215            {
   1216              /* Enable the main output */
   1217              __HAL_TIM_MOE_ENABLE(htim);
   1218            }
   1219          
   1220            /* Enable the Peripheral */
   1221            __HAL_TIM_ENABLE(htim);
   1222            
   1223            /* Return function status */
   1224            return HAL_OK;
   1225          } 
   1226          
   1227          /**
   1228            * @brief  Stops the PWM signal generation in interrupt mode.
   1229            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1230            *                the configuration information for TIM module.
   1231            * @param  Channel TIM Channels to be disabled.
   1232            *          This parameter can be one of the following values:
   1233            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1234            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1235            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1236            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1237            * @retval HAL status
   1238            */
   1239          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1240          {
   1241            /* Check the parameters */
   1242            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1243            
   1244            switch (Channel)
   1245            {
   1246              case TIM_CHANNEL_1:
   1247              {       
   1248                /* Disable the TIM Capture/Compare 1 interrupt */
   1249                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1250              }
   1251              break;
   1252              
   1253              case TIM_CHANNEL_2:
   1254              {
   1255                /* Disable the TIM Capture/Compare 2 interrupt */
   1256                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1257              }
   1258              break;
   1259              
   1260              case TIM_CHANNEL_3:
   1261              {
   1262                /* Disable the TIM Capture/Compare 3 interrupt */
   1263                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1264              }
   1265              break;
   1266              
   1267              case TIM_CHANNEL_4:
   1268              {
   1269                /* Disable the TIM Capture/Compare 4 interrupt */
   1270                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1271              }
   1272              break;
   1273              
   1274              default:
   1275              break; 
   1276            }
   1277            
   1278            /* Disable the Capture compare channel */
   1279            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1280            
   1281            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   1282            {
   1283              /* Disable the Main Output */
   1284              __HAL_TIM_MOE_DISABLE(htim);
   1285            }
   1286            
   1287            /* Disable the Peripheral */
   1288            __HAL_TIM_DISABLE(htim);
   1289            
   1290            /* Return function status */
   1291            return HAL_OK;
   1292          } 
   1293          
   1294          /**
   1295            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1296            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1297            *                the configuration information for TIM module.
   1298            * @param  Channel TIM Channels to be enabled.
   1299            *          This parameter can be one of the following values:
   1300            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1301            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1302            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1303            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1304            * @param  pData The source Buffer address.
   1305            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1306            * @retval HAL status
   1307            */
   1308          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1309          {
   1310            /* Check the parameters */
   1311            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1312            
   1313            if((htim->State == HAL_TIM_STATE_BUSY))
   1314            {
   1315               return HAL_BUSY;
   1316            }
   1317            else if((htim->State == HAL_TIM_STATE_READY))
   1318            {
   1319              if(((uint32_t)pData == 0U) && (Length > 0)) 
   1320              {
   1321                return HAL_ERROR;                                    
   1322              }
   1323              else
   1324              {
   1325                htim->State = HAL_TIM_STATE_BUSY;
   1326              }
   1327            }    
   1328            switch (Channel)
   1329            {
   1330              case TIM_CHANNEL_1:
   1331              {      
   1332                /* Set the DMA Period elapsed callback */
   1333                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1334               
   1335                /* Set the DMA error callback */
   1336                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1337                
   1338                /* Enable the DMA Stream */
   1339                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   1340                
   1341                /* Enable the TIM Capture/Compare 1 DMA request */
   1342                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1343              }
   1344              break;
   1345              
   1346              case TIM_CHANNEL_2:
   1347              {
   1348                /* Set the DMA Period elapsed callback */
   1349                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1350               
   1351                /* Set the DMA error callback */
   1352                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1353                
   1354                /* Enable the DMA Stream */
   1355                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   1356                
   1357                /* Enable the TIM Capture/Compare 2 DMA request */
   1358                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1359              }
   1360              break;
   1361              
   1362              case TIM_CHANNEL_3:
   1363              {
   1364                /* Set the DMA Period elapsed callback */
   1365                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1366               
   1367                /* Set the DMA error callback */
   1368                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1369                
   1370                /* Enable the DMA Stream */
   1371                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   1372                
   1373                /* Enable the TIM Output Capture/Compare 3 request */
   1374                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1375              }
   1376              break;
   1377              
   1378              case TIM_CHANNEL_4:
   1379              {
   1380               /* Set the DMA Period elapsed callback */
   1381                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1382               
   1383                /* Set the DMA error callback */
   1384                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1385                
   1386                /* Enable the DMA Stream */
   1387                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   1388                
   1389                /* Enable the TIM Capture/Compare 4 DMA request */
   1390                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1391              }
   1392              break;
   1393              
   1394              default:
   1395              break;
   1396            }
   1397          
   1398            /* Enable the Capture compare channel */
   1399            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1400              
   1401            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   1402            {
   1403              /* Enable the main output */
   1404              __HAL_TIM_MOE_ENABLE(htim);
   1405            }
   1406            
   1407            /* Enable the Peripheral */
   1408            __HAL_TIM_ENABLE(htim); 
   1409            
   1410            /* Return function status */
   1411            return HAL_OK;
   1412          }
   1413          
   1414          /**
   1415            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1416            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1417            *                the configuration information for TIM module.
   1418            * @param  Channel TIM Channels to be disabled.
   1419            *          This parameter can be one of the following values:
   1420            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1421            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1422            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1423            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1424            * @retval HAL status
   1425            */
   1426          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1427          {
   1428            /* Check the parameters */
   1429            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1430            
   1431            switch (Channel)
   1432            {
   1433              case TIM_CHANNEL_1:
   1434              {       
   1435                /* Disable the TIM Capture/Compare 1 DMA request */
   1436                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1437              }
   1438              break;
   1439              
   1440              case TIM_CHANNEL_2:
   1441              {
   1442                /* Disable the TIM Capture/Compare 2 DMA request */
   1443                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1444              }
   1445              break;
   1446              
   1447              case TIM_CHANNEL_3:
   1448              {
   1449                /* Disable the TIM Capture/Compare 3 DMA request */
   1450                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1451              }
   1452              break;
   1453              
   1454              case TIM_CHANNEL_4:
   1455              {
   1456                /* Disable the TIM Capture/Compare 4 interrupt */
   1457                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1458              }
   1459              break;
   1460              
   1461              default:
   1462              break;
   1463            } 
   1464            
   1465            /* Disable the Capture compare channel */
   1466            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1467            
   1468            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   1469            {
   1470              /* Disable the Main Output */
   1471              __HAL_TIM_MOE_DISABLE(htim);
   1472            }
   1473            
   1474            /* Disable the Peripheral */
   1475            __HAL_TIM_DISABLE(htim);
   1476            
   1477            /* Change the htim state */
   1478            htim->State = HAL_TIM_STATE_READY;
   1479            
   1480            /* Return function status */
   1481            return HAL_OK;
   1482          }
   1483          /**
   1484            * @}
   1485            */
   1486          
   1487          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1488           *  @brief    Time Input Capture functions 
   1489           *
   1490          @verbatim    
   1491            ==============================================================================
   1492                        ##### Time Input Capture functions #####
   1493            ==============================================================================
   1494           [..]  
   1495             This section provides functions allowing to:
   1496             (+) Initialize and configure the TIM Input Capture. 
   1497             (+) De-initialize the TIM Input Capture.
   1498             (+) Start the Time Input Capture.
   1499             (+) Stop the Time Input Capture.
   1500             (+) Start the Time Input Capture and enable interrupt.
   1501             (+) Stop the Time Input Capture and disable interrupt.
   1502             (+) Start the Time Input Capture and enable DMA transfer.
   1503             (+) Stop the Time Input Capture and disable DMA transfer.
   1504           
   1505          @endverbatim
   1506            * @{
   1507            */
   1508          /**
   1509            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1510            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1511            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1512            *                the configuration information for TIM module.
   1513            * @retval HAL status
   1514            */
   1515          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1516          {
   1517            /* Check the TIM handle allocation */
   1518            if(htim == NULL)
   1519            {
   1520              return HAL_ERROR;
   1521            }
   1522          
   1523            /* Check the parameters */
   1524            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1525            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1526            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision)); 
   1527          
   1528            if(htim->State == HAL_TIM_STATE_RESET)
   1529            { 
   1530              /* Allocate lock resource and initialize it */
   1531              htim->Lock = HAL_UNLOCKED;
   1532              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1533              HAL_TIM_IC_MspInit(htim);
   1534            }
   1535            
   1536            /* Set the TIM state */
   1537            htim->State= HAL_TIM_STATE_BUSY;   
   1538            
   1539            /* Init the base time for the input capture */  
   1540            TIM_Base_SetConfig(htim->Instance, &htim->Init); 
   1541             
   1542            /* Initialize the TIM state*/
   1543            htim->State= HAL_TIM_STATE_READY;
   1544            
   1545            return HAL_OK;
   1546          }
   1547          
   1548          /**
   1549            * @brief  DeInitializes the TIM peripheral 
   1550            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1551            *                the configuration information for TIM module.
   1552            * @retval HAL status
   1553            */
   1554          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1555          {
   1556            /* Check the parameters */
   1557            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1558          
   1559            htim->State = HAL_TIM_STATE_BUSY;
   1560            
   1561            /* Disable the TIM Peripheral Clock */
   1562            __HAL_TIM_DISABLE(htim);
   1563              
   1564            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1565            HAL_TIM_IC_MspDeInit(htim);
   1566              
   1567            /* Change TIM state */  
   1568            htim->State = HAL_TIM_STATE_RESET;
   1569          
   1570            /* Release Lock */
   1571            __HAL_UNLOCK(htim);
   1572          
   1573            return HAL_OK;
   1574          }
   1575          
   1576          /**
   1577            * @brief  Initializes the TIM INput Capture MSP.
   1578            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1579            *                the configuration information for TIM module.
   1580            * @retval None
   1581            */
   1582          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1583          {
   1584            /* Prevent unused argument(s) compilation warning */
   1585            UNUSED(htim);
   1586            /* NOTE : This function Should not be modified, when the callback is needed,
   1587                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1588             */
   1589          }
   1590          
   1591          /**
   1592            * @brief  DeInitializes TIM Input Capture MSP.
   1593            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1594            *                the configuration information for TIM module.
   1595            * @retval None
   1596            */
   1597          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1598          {
   1599            /* Prevent unused argument(s) compilation warning */
   1600            UNUSED(htim);
   1601            /* NOTE : This function Should not be modified, when the callback is needed,
   1602                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1603             */
   1604          }
   1605          
   1606          /**
   1607            * @brief  Starts the TIM Input Capture measurement.
   1608            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1609            *                the configuration information for TIM module.
   1610            * @param  Channel TIM Channels to be enabled.
   1611            *          This parameter can be one of the following values:
   1612            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1613            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1614            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1615            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1616            * @retval HAL status
   1617            */
   1618          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1619          {
   1620            /* Check the parameters */
   1621            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1622            
   1623            /* Enable the Input Capture channel */
   1624            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1625              
   1626            /* Enable the Peripheral */
   1627            __HAL_TIM_ENABLE(htim);  
   1628          
   1629            /* Return function status */
   1630            return HAL_OK;  
   1631          } 
   1632          
   1633          /**
   1634            * @brief  Stops the TIM Input Capture measurement.
   1635            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1636            *                the configuration information for TIM module.
   1637            * @param  Channel TIM Channels to be disabled.
   1638            *          This parameter can be one of the following values:
   1639            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1640            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1641            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1642            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1643            * @retval HAL status
   1644            */
   1645          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1646          { 
   1647            /* Check the parameters */
   1648            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1649            
   1650            /* Disable the Input Capture channel */
   1651            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1652            
   1653            /* Disable the Peripheral */
   1654            __HAL_TIM_DISABLE(htim); 
   1655            
   1656            /* Return function status */
   1657            return HAL_OK;
   1658          }
   1659          
   1660          /**
   1661            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1662            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1663            *                the configuration information for TIM module.
   1664            * @param  Channel TIM Channels to be enabled.
   1665            *          This parameter can be one of the following values:
   1666            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1667            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1668            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1669            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1670            * @retval HAL status
   1671            */
   1672          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1673          {
   1674            /* Check the parameters */
   1675            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1676            
   1677            switch (Channel)
   1678            {
   1679              case TIM_CHANNEL_1:
   1680              {       
   1681                /* Enable the TIM Capture/Compare 1 interrupt */
   1682                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1683              }
   1684              break;
   1685              
   1686              case TIM_CHANNEL_2:
   1687              {
   1688                /* Enable the TIM Capture/Compare 2 interrupt */
   1689                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1690              }
   1691              break;
   1692              
   1693              case TIM_CHANNEL_3:
   1694              {
   1695                /* Enable the TIM Capture/Compare 3 interrupt */
   1696                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1697              }
   1698              break;
   1699              
   1700              case TIM_CHANNEL_4:
   1701              {
   1702                /* Enable the TIM Capture/Compare 4 interrupt */
   1703                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1704              }
   1705              break;
   1706              
   1707              default:
   1708              break;
   1709            }  
   1710            /* Enable the Input Capture channel */
   1711            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1712              
   1713            /* Enable the Peripheral */
   1714            __HAL_TIM_ENABLE(htim);  
   1715          
   1716            /* Return function status */
   1717            return HAL_OK;  
   1718          } 
   1719          
   1720          /**
   1721            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1722            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1723            *                the configuration information for TIM module.
   1724            * @param  Channel TIM Channels to be disabled.
   1725            *          This parameter can be one of the following values:
   1726            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1727            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1728            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1729            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1730            * @retval HAL status
   1731            */
   1732          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1733          {
   1734            /* Check the parameters */
   1735            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1736            
   1737            switch (Channel)
   1738            {
   1739              case TIM_CHANNEL_1:
   1740              {       
   1741                /* Disable the TIM Capture/Compare 1 interrupt */
   1742                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1743              }
   1744              break;
   1745              
   1746              case TIM_CHANNEL_2:
   1747              {
   1748                /* Disable the TIM Capture/Compare 2 interrupt */
   1749                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1750              }
   1751              break;
   1752              
   1753              case TIM_CHANNEL_3:
   1754              {
   1755                /* Disable the TIM Capture/Compare 3 interrupt */
   1756                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1757              }
   1758              break;
   1759              
   1760              case TIM_CHANNEL_4:
   1761              {
   1762                /* Disable the TIM Capture/Compare 4 interrupt */
   1763                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1764              }
   1765              break;
   1766              
   1767              default:
   1768              break; 
   1769            } 
   1770            
   1771            /* Disable the Input Capture channel */
   1772            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE); 
   1773            
   1774            /* Disable the Peripheral */
   1775            __HAL_TIM_DISABLE(htim); 
   1776            
   1777            /* Return function status */
   1778            return HAL_OK;
   1779          }
   1780          
   1781          /**
   1782            * @brief  Starts the TIM Input Capture measurement on in DMA mode.
   1783            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1784            *                the configuration information for TIM module.
   1785            * @param  Channel TIM Channels to be enabled.
   1786            *          This parameter can be one of the following values:
   1787            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1788            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1789            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1790            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1791            * @param  pData The destination Buffer address.
   1792            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   1793            * @retval HAL status
   1794            */
   1795          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1796          {
   1797            /* Check the parameters */
   1798            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1799            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1800            
   1801            if((htim->State == HAL_TIM_STATE_BUSY))
   1802            {
   1803               return HAL_BUSY;
   1804            }
   1805            else if((htim->State == HAL_TIM_STATE_READY))
   1806            {
   1807              if((pData == 0U) && (Length > 0)) 
   1808              {
   1809                return HAL_ERROR;                                    
   1810              }
   1811              else
   1812              {
   1813                htim->State = HAL_TIM_STATE_BUSY;
   1814              }
   1815            }  
   1816             
   1817            switch (Channel)
   1818            {
   1819              case TIM_CHANNEL_1:
   1820              {
   1821                /* Set the DMA Period elapsed callback */
   1822                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   1823               
   1824                /* Set the DMA error callback */
   1825                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1826                
   1827                /* Enable the DMA Stream */
   1828                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length); 
   1829                
   1830                /* Enable the TIM Capture/Compare 1 DMA request */      
   1831                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1832              }
   1833              break;
   1834              
   1835              case TIM_CHANNEL_2:
   1836              {
   1837                /* Set the DMA Period elapsed callback */
   1838                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   1839               
   1840                /* Set the DMA error callback */
   1841                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1842                
   1843                /* Enable the DMA Stream */
   1844                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   1845                
   1846                /* Enable the TIM Capture/Compare 2  DMA request */
   1847                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1848              }
   1849              break;
   1850              
   1851              case TIM_CHANNEL_3:
   1852              {
   1853                /* Set the DMA Period elapsed callback */
   1854                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   1855               
   1856                /* Set the DMA error callback */
   1857                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1858                
   1859                /* Enable the DMA Stream */
   1860                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   1861                
   1862                /* Enable the TIM Capture/Compare 3  DMA request */
   1863                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1864              }
   1865              break;
   1866              
   1867              case TIM_CHANNEL_4:
   1868              {
   1869                /* Set the DMA Period elapsed callback */
   1870                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   1871               
   1872                /* Set the DMA error callback */
   1873                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1874                
   1875                /* Enable the DMA Stream */
   1876                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   1877                
   1878                /* Enable the TIM Capture/Compare 4  DMA request */
   1879                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1880              }
   1881              break;
   1882              
   1883              default:
   1884              break;
   1885            }
   1886          
   1887            /* Enable the Input Capture channel */
   1888            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1889             
   1890            /* Enable the Peripheral */
   1891            __HAL_TIM_ENABLE(htim); 
   1892            
   1893            /* Return function status */
   1894            return HAL_OK;
   1895          }
   1896          
   1897          /**
   1898            * @brief  Stops the TIM Input Capture measurement on in DMA mode.
   1899            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1900            *                the configuration information for TIM module.
   1901            * @param  Channel TIM Channels to be disabled.
   1902            *          This parameter can be one of the following values:
   1903            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1904            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1905            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1906            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1907            * @retval HAL status
   1908            */
   1909          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1910          {
   1911            /* Check the parameters */
   1912            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1913            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1914            
   1915            switch (Channel)
   1916            {
   1917              case TIM_CHANNEL_1:
   1918              {       
   1919                /* Disable the TIM Capture/Compare 1 DMA request */
   1920                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1921              }
   1922              break;
   1923              
   1924              case TIM_CHANNEL_2:
   1925              {
   1926                /* Disable the TIM Capture/Compare 2 DMA request */
   1927                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1928              }
   1929              break;
   1930              
   1931              case TIM_CHANNEL_3:
   1932              {
   1933                /* Disable the TIM Capture/Compare 3  DMA request */
   1934                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1935              }
   1936              break;
   1937              
   1938              case TIM_CHANNEL_4:
   1939              {
   1940                /* Disable the TIM Capture/Compare 4  DMA request */
   1941                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1942              }
   1943              break;
   1944              
   1945              default:
   1946              break;
   1947            }
   1948          
   1949            /* Disable the Input Capture channel */
   1950            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1951            
   1952            /* Disable the Peripheral */
   1953            __HAL_TIM_DISABLE(htim); 
   1954            
   1955            /* Change the htim state */
   1956            htim->State = HAL_TIM_STATE_READY;
   1957            
   1958            /* Return function status */
   1959            return HAL_OK;
   1960          }  
   1961          /**
   1962            * @}
   1963            */
   1964            
   1965          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1966           *  @brief    Time One Pulse functions 
   1967           *
   1968          @verbatim    
   1969            ==============================================================================
   1970                                  ##### Time One Pulse functions #####
   1971            ==============================================================================
   1972            [..]  
   1973              This section provides functions allowing to:
   1974              (+) Initialize and configure the TIM One Pulse. 
   1975              (+) De-initialize the TIM One Pulse.
   1976              (+) Start the Time One Pulse.
   1977              (+) Stop the Time One Pulse.
   1978              (+) Start the Time One Pulse and enable interrupt.
   1979              (+) Stop the Time One Pulse and disable interrupt.
   1980              (+) Start the Time One Pulse and enable DMA transfer.
   1981              (+) Stop the Time One Pulse and disable DMA transfer.
   1982           
   1983          @endverbatim
   1984            * @{
   1985            */
   1986          /**
   1987            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1988            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1989            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   1990            *                the configuration information for TIM module.
   1991            * @param  OnePulseMode Select the One pulse mode.
   1992            *         This parameter can be one of the following values:
   1993            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1994            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   1995            * @retval HAL status
   1996            */
   1997          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1998          {
   1999            /* Check the TIM handle allocation */
   2000            if(htim == NULL)
   2001            {
   2002              return HAL_ERROR;
   2003            }
   2004          
   2005            /* Check the parameters */
   2006            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2007            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2008            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2009            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2010            
   2011            if(htim->State == HAL_TIM_STATE_RESET)
   2012            { 
   2013              /* Allocate lock resource and initialize it */
   2014              htim->Lock = HAL_UNLOCKED;
   2015              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2016              HAL_TIM_OnePulse_MspInit(htim);
   2017            }
   2018            
   2019            /* Set the TIM state */
   2020            htim->State= HAL_TIM_STATE_BUSY;  
   2021            
   2022            /* Configure the Time base in the One Pulse Mode */
   2023            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2024            
   2025            /* Reset the OPM Bit */
   2026            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   2027          
   2028            /* Configure the OPM Mode */
   2029            htim->Instance->CR1 |= OnePulseMode;
   2030             
   2031            /* Initialize the TIM state*/
   2032            htim->State= HAL_TIM_STATE_READY;
   2033            
   2034            return HAL_OK;
   2035          }
   2036          
   2037          /**
   2038            * @brief  DeInitializes the TIM One Pulse  
   2039            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2040            *                the configuration information for TIM module.
   2041            * @retval HAL status
   2042            */
   2043          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2044          {
   2045            /* Check the parameters */
   2046            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2047            
   2048            htim->State = HAL_TIM_STATE_BUSY;
   2049            
   2050            /* Disable the TIM Peripheral Clock */
   2051            __HAL_TIM_DISABLE(htim);
   2052            
   2053            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2054            HAL_TIM_OnePulse_MspDeInit(htim);
   2055              
   2056            /* Change TIM state */  
   2057            htim->State = HAL_TIM_STATE_RESET;
   2058          
   2059            /* Release Lock */
   2060            __HAL_UNLOCK(htim);
   2061          
   2062            return HAL_OK;
   2063          }
   2064          
   2065          /**
   2066            * @brief  Initializes the TIM One Pulse MSP.
   2067            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2068            *                the configuration information for TIM module.
   2069            * @retval None
   2070            */
   2071          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2072          {
   2073            /* Prevent unused argument(s) compilation warning */
   2074            UNUSED(htim);
   2075            /* NOTE : This function Should not be modified, when the callback is needed,
   2076                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2077             */
   2078          }
   2079          
   2080          /**
   2081            * @brief  DeInitializes TIM One Pulse MSP.
   2082            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2083            *                the configuration information for TIM module.
   2084            * @retval None
   2085            */
   2086          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2087          {
   2088            /* Prevent unused argument(s) compilation warning */
   2089            UNUSED(htim);
   2090            /* NOTE : This function Should not be modified, when the callback is needed,
   2091                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2092             */
   2093          }
   2094          
   2095          /**
   2096            * @brief  Starts the TIM One Pulse signal generation.
   2097            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2098            *                the configuration information for TIM module.
   2099            * @param  OutputChannel  TIM Channels to be enabled.
   2100            *          This parameter can be one of the following values:
   2101            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2102            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2103            * @retval HAL status
   2104            */
   2105          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2106          {
   2107            /* Prevent unused argument(s) compilation warning */
   2108            UNUSED(OutputChannel);
   2109          
   2110            /* Enable the Capture compare and the Input Capture channels 
   2111              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2112              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2113              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2114              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2115              
   2116              No need to enable the counter, it's enabled automatically by hardware 
   2117              (the counter starts in response to a stimulus and generate a pulse */
   2118            
   2119            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   2120            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   2121            
   2122            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   2123            {
   2124              /* Enable the main output */
   2125              __HAL_TIM_MOE_ENABLE(htim);
   2126            }
   2127            
   2128            /* Return function status */
   2129            return HAL_OK;
   2130          }
   2131          
   2132          /**
   2133            * @brief  Stops the TIM One Pulse signal generation.
   2134            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2135            *                the configuration information for TIM module.
   2136            * @param  OutputChannel  TIM Channels to be disable.
   2137            *          This parameter can be one of the following values:
   2138            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2139            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2140            * @retval HAL status
   2141            */
   2142          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2143          {
   2144            /* Prevent unused argument(s) compilation warning */
   2145            UNUSED(OutputChannel);
   2146          
   2147            /* Disable the Capture compare and the Input Capture channels 
   2148            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2149            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2150            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2151            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2152            
   2153            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2154            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2155              
   2156            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   2157            {
   2158              /* Disable the Main Output */
   2159              __HAL_TIM_MOE_DISABLE(htim);
   2160            }
   2161              
   2162            /* Disable the Peripheral */
   2163            __HAL_TIM_DISABLE(htim); 
   2164            
   2165            /* Return function status */
   2166            return HAL_OK;
   2167          }
   2168          
   2169          /**
   2170            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2171            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2172            *                the configuration information for TIM module.
   2173            * @param  OutputChannel  TIM Channels to be enabled.
   2174            *          This parameter can be one of the following values:
   2175            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2176            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2177            * @retval HAL status
   2178            */
   2179          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2180          {
   2181            /* Enable the Capture compare and the Input Capture channels 
   2182              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2183              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2184              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2185              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2186              
   2187              No need to enable the counter, it's enabled automatically by hardware 
   2188              (the counter starts in response to a stimulus and generate a pulse */
   2189          
   2190            /* Prevent unused argument(s) compilation warning */
   2191            UNUSED(OutputChannel);
   2192          
   2193            /* Enable the TIM Capture/Compare 1 interrupt */
   2194            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2195            
   2196            /* Enable the TIM Capture/Compare 2 interrupt */
   2197            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2198            
   2199            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE); 
   2200            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   2201            
   2202            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   2203            {
   2204              /* Enable the main output */
   2205              __HAL_TIM_MOE_ENABLE(htim);
   2206            }
   2207            
   2208            /* Return function status */
   2209            return HAL_OK;
   2210          }
   2211          
   2212          /**
   2213            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2214            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2215            *                the configuration information for TIM module.
   2216            * @param  OutputChannel  TIM Channels to be enabled.
   2217            *          This parameter can be one of the following values:
   2218            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2219            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2220            * @retval HAL status
   2221            */
   2222          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2223          {
   2224            /* Prevent unused argument(s) compilation warning */
   2225            UNUSED(OutputChannel);
   2226          
   2227            /* Disable the TIM Capture/Compare 1 interrupt */
   2228            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);  
   2229            
   2230            /* Disable the TIM Capture/Compare 2 interrupt */
   2231            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2232            
   2233            /* Disable the Capture compare and the Input Capture channels 
   2234            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2235            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2236            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2237            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */  
   2238            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2239            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2240              
   2241            if(IS_TIM_ADVANCED_INSTANCE(htim->Instance) != RESET)  
   2242            {
   2243              /* Disable the Main Output */
   2244              __HAL_TIM_MOE_DISABLE(htim);
   2245            }
   2246              
   2247            /* Disable the Peripheral */
   2248             __HAL_TIM_DISABLE(htim);  
   2249            
   2250            /* Return function status */
   2251            return HAL_OK;
   2252          }
   2253          /**
   2254            * @}
   2255            */
   2256          
   2257          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2258           *  @brief    Time Encoder functions 
   2259           *
   2260          @verbatim    
   2261            ==============================================================================
   2262                                    ##### Time Encoder functions #####
   2263            ==============================================================================
   2264            [..]
   2265              This section provides functions allowing to:
   2266              (+) Initialize and configure the TIM Encoder. 
   2267              (+) De-initialize the TIM Encoder.
   2268              (+) Start the Time Encoder.
   2269              (+) Stop the Time Encoder.
   2270              (+) Start the Time Encoder and enable interrupt.
   2271              (+) Stop the Time Encoder and disable interrupt.
   2272              (+) Start the Time Encoder and enable DMA transfer.
   2273              (+) Stop the Time Encoder and disable DMA transfer.
   2274           
   2275          @endverbatim
   2276            * @{
   2277            */
   2278          /**
   2279            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2280            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2281            *                the configuration information for TIM module.
   2282            * @param  sConfig TIM Encoder Interface configuration structure
   2283            * @retval HAL status
   2284            */
   2285          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2286          {
   2287            uint32_t tmpsmcr = 0U;
   2288            uint32_t tmpccmr1 = 0U;
   2289            uint32_t tmpccer = 0U;
   2290            
   2291            /* Check the TIM handle allocation */
   2292            if(htim == NULL)
   2293            {
   2294              return HAL_ERROR;
   2295            }
   2296             
   2297            /* Check the parameters */
   2298            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2299            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2300            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2301            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2302            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2303            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2304            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2305            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2306            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2307            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2308          
   2309            if(htim->State == HAL_TIM_STATE_RESET)
   2310            { 
   2311              /* Allocate lock resource and initialize it */
   2312              htim->Lock = HAL_UNLOCKED;
   2313              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2314              HAL_TIM_Encoder_MspInit(htim);
   2315            }
   2316            
   2317            /* Set the TIM state */
   2318            htim->State= HAL_TIM_STATE_BUSY;   
   2319              
   2320            /* Reset the SMS bits */
   2321            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   2322            
   2323            /* Configure the Time base in the Encoder Mode */
   2324            TIM_Base_SetConfig(htim->Instance, &htim->Init);  
   2325            
   2326            /* Get the TIMx SMCR register value */
   2327            tmpsmcr = htim->Instance->SMCR;
   2328          
   2329            /* Get the TIMx CCMR1 register value */
   2330            tmpccmr1 = htim->Instance->CCMR1;
   2331          
   2332            /* Get the TIMx CCER register value */
   2333            tmpccer = htim->Instance->CCER;
   2334          
   2335            /* Set the encoder Mode */
   2336            tmpsmcr |= sConfig->EncoderMode;
   2337          
   2338            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2339            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2340            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   2341            
   2342            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2343            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2344            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2345            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   2346            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   2347          
   2348            /* Set the TI1 and the TI2 Polarities */
   2349            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2350            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2351            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   2352            
   2353            /* Write to TIMx SMCR */
   2354            htim->Instance->SMCR = tmpsmcr;
   2355          
   2356            /* Write to TIMx CCMR1 */
   2357            htim->Instance->CCMR1 = tmpccmr1;
   2358          
   2359            /* Write to TIMx CCER */
   2360            htim->Instance->CCER = tmpccer;
   2361            
   2362            /* Initialize the TIM state*/
   2363            htim->State= HAL_TIM_STATE_READY;
   2364            
   2365            return HAL_OK;
   2366          }
   2367          
   2368          /**
   2369            * @brief  DeInitializes the TIM Encoder interface  
   2370            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2371            *                the configuration information for TIM module.
   2372            * @retval HAL status
   2373            */
   2374          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2375          {
   2376            /* Check the parameters */
   2377            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2378            
   2379            htim->State = HAL_TIM_STATE_BUSY;
   2380            
   2381            /* Disable the TIM Peripheral Clock */
   2382            __HAL_TIM_DISABLE(htim);
   2383            
   2384            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2385            HAL_TIM_Encoder_MspDeInit(htim);
   2386              
   2387            /* Change TIM state */  
   2388            htim->State = HAL_TIM_STATE_RESET;
   2389           
   2390            /* Release Lock */
   2391            __HAL_UNLOCK(htim);
   2392          
   2393            return HAL_OK;
   2394          }
   2395          
   2396          /**
   2397            * @brief  Initializes the TIM Encoder Interface MSP.
   2398            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2399            *                the configuration information for TIM module.
   2400            * @retval None
   2401            */
   2402          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2403          {
   2404            /* Prevent unused argument(s) compilation warning */
   2405            UNUSED(htim);
   2406            /* NOTE : This function Should not be modified, when the callback is needed,
   2407                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2408             */
   2409          }
   2410          
   2411          /**
   2412            * @brief  DeInitializes TIM Encoder Interface MSP.
   2413            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2414            *                the configuration information for TIM module.
   2415            * @retval None
   2416            */
   2417          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2418          {
   2419            /* Prevent unused argument(s) compilation warning */
   2420            UNUSED(htim);
   2421            /* NOTE : This function Should not be modified, when the callback is needed,
   2422                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2423             */
   2424          }
   2425          
   2426          /**
   2427            * @brief  Starts the TIM Encoder Interface.
   2428            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2429            *                the configuration information for TIM module.
   2430            * @param  Channel TIM Channels to be enabled.
   2431            *          This parameter can be one of the following values:
   2432            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2433            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2434            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2435            * @retval HAL status
   2436            */
   2437          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2438          {
   2439            /* Check the parameters */
   2440            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2441            
   2442            /* Enable the encoder interface channels */
   2443            switch (Channel)
   2444            {
   2445              case TIM_CHANNEL_1:
   2446              {
   2447                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2448                break; 
   2449              }
   2450              case TIM_CHANNEL_2:
   2451              { 
   2452                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE); 
   2453                break;
   2454              }  
   2455              default :
   2456              {
   2457               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2458               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2459               break; 
   2460              }
   2461            }  
   2462            /* Enable the Peripheral */
   2463            __HAL_TIM_ENABLE(htim);
   2464            
   2465            /* Return function status */
   2466            return HAL_OK;
   2467          }
   2468          
   2469          /**
   2470            * @brief  Stops the TIM Encoder Interface.
   2471            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2472            *                the configuration information for TIM module.
   2473            * @param  Channel TIM Channels to be disabled.
   2474            *          This parameter can be one of the following values:
   2475            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2476            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2477            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2478            * @retval HAL status
   2479            */
   2480          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2481          {
   2482            /* Check the parameters */
   2483              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2484              
   2485             /* Disable the Input Capture channels 1 and 2
   2486              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2487            switch (Channel)
   2488            {
   2489              case TIM_CHANNEL_1:
   2490              {
   2491                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2492                break; 
   2493              }
   2494              case TIM_CHANNEL_2:
   2495              { 
   2496                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2497                break;
   2498              }  
   2499              default :
   2500              {
   2501               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2502               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2503               break; 
   2504              }
   2505            }  
   2506            /* Disable the Peripheral */
   2507            __HAL_TIM_DISABLE(htim);
   2508            
   2509            /* Return function status */
   2510            return HAL_OK;
   2511          }
   2512          
   2513          /**
   2514            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2515            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2516            *                the configuration information for TIM module.
   2517            * @param  Channel TIM Channels to be enabled.
   2518            *          This parameter can be one of the following values:
   2519            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2520            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2521            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2522            * @retval HAL status
   2523            */
   2524          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2525          {
   2526            /* Check the parameters */
   2527            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2528            
   2529            /* Enable the encoder interface channels */
   2530            /* Enable the capture compare Interrupts 1 and/or 2 */
   2531            switch (Channel)
   2532            {
   2533              case TIM_CHANNEL_1:
   2534              {
   2535                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2536                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2537                break; 
   2538              }
   2539              case TIM_CHANNEL_2:
   2540              { 
   2541                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2542                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2); 
   2543                break;
   2544              }  
   2545              default :
   2546              {
   2547               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2548               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2549               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2550               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2551               break; 
   2552              }
   2553            }
   2554            
   2555            /* Enable the Peripheral */
   2556            __HAL_TIM_ENABLE(htim);
   2557            
   2558            /* Return function status */
   2559            return HAL_OK;
   2560          }
   2561          
   2562          /**
   2563            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2564            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2565            *                the configuration information for TIM module.
   2566            * @param  Channel TIM Channels to be disabled.
   2567            *          This parameter can be one of the following values:
   2568            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2569            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2570            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2571            * @retval HAL status
   2572            */
   2573          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2574          {
   2575            /* Check the parameters */
   2576            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2577              
   2578            /* Disable the Input Capture channels 1 and 2
   2579              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2580            if(Channel == TIM_CHANNEL_1)
   2581            {
   2582              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2583              
   2584              /* Disable the capture compare Interrupts 1 */
   2585            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2586            }  
   2587            else if(Channel == TIM_CHANNEL_2)
   2588            {  
   2589              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2590              
   2591              /* Disable the capture compare Interrupts 2 */
   2592            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2593            }  
   2594            else
   2595            {
   2596              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2597              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2598              
   2599              /* Disable the capture compare Interrupts 1 and 2 */
   2600              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2601              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2602            }
   2603              
   2604            /* Disable the Peripheral */
   2605            __HAL_TIM_DISABLE(htim);
   2606            
   2607            /* Change the htim state */
   2608            htim->State = HAL_TIM_STATE_READY;
   2609            
   2610            /* Return function status */
   2611            return HAL_OK;
   2612          }
   2613          
   2614          /**
   2615            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2616            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2617            *                the configuration information for TIM module.
   2618            * @param  Channel TIM Channels to be enabled.
   2619            *          This parameter can be one of the following values:
   2620            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2621            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2622            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2623            * @param  pData1 The destination Buffer address for IC1.
   2624            * @param  pData2 The destination Buffer address for IC2.
   2625            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2626            * @retval HAL status
   2627            */
   2628          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2629          {
   2630            /* Check the parameters */
   2631            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2632            
   2633            if((htim->State == HAL_TIM_STATE_BUSY))
   2634            {
   2635               return HAL_BUSY;
   2636            }
   2637            else if((htim->State == HAL_TIM_STATE_READY))
   2638            {
   2639              if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0)) 
   2640              {
   2641                return HAL_ERROR;                                    
   2642              }
   2643              else
   2644              {
   2645                htim->State = HAL_TIM_STATE_BUSY;
   2646              }
   2647            }  
   2648             
   2649            switch (Channel)
   2650            {
   2651              case TIM_CHANNEL_1:
   2652              {
   2653                /* Set the DMA Period elapsed callback */
   2654                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2655               
   2656                /* Set the DMA error callback */
   2657                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   2658                
   2659                /* Enable the DMA Stream */
   2660                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length); 
   2661                
   2662                /* Enable the TIM Input Capture DMA request */      
   2663                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2664                      
   2665                /* Enable the Peripheral */
   2666                __HAL_TIM_ENABLE(htim);
   2667                
   2668                /* Enable the Capture compare channel */
   2669                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2670              }
   2671              break;
   2672              
   2673              case TIM_CHANNEL_2:
   2674              {
   2675                /* Set the DMA Period elapsed callback */
   2676                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   2677               
   2678                /* Set the DMA error callback */
   2679                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   2680                /* Enable the DMA Stream */
   2681                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2682                
   2683                /* Enable the TIM Input Capture  DMA request */
   2684                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2685               
   2686                /* Enable the Peripheral */
   2687                __HAL_TIM_ENABLE(htim);
   2688                
   2689                /* Enable the Capture compare channel */
   2690                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2691              }
   2692              break;
   2693              
   2694              case TIM_CHANNEL_ALL:
   2695              {
   2696                /* Set the DMA Period elapsed callback */
   2697                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2698               
   2699                /* Set the DMA error callback */
   2700                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   2701                
   2702                /* Enable the DMA Stream */
   2703                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   2704                
   2705                /* Set the DMA Period elapsed callback */
   2706                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   2707               
   2708                /* Set the DMA error callback */
   2709                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   2710                
   2711                /* Enable the DMA Stream */
   2712                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2713                    
   2714               /* Enable the Peripheral */
   2715                __HAL_TIM_ENABLE(htim);
   2716                
   2717                /* Enable the Capture compare channel */
   2718                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2719                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2720                
   2721                /* Enable the TIM Input Capture  DMA request */
   2722                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2723                /* Enable the TIM Input Capture  DMA request */
   2724                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2725              }
   2726              break;
   2727              
   2728              default:
   2729              break;
   2730            }  
   2731            /* Return function status */
   2732            return HAL_OK;
   2733          }
   2734          
   2735          /**
   2736            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2737            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2738            *                the configuration information for TIM module.
   2739            * @param  Channel TIM Channels to be enabled.
   2740            *          This parameter can be one of the following values:
   2741            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2742            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2743            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2744            * @retval HAL status
   2745            */
   2746          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2747          {
   2748            /* Check the parameters */
   2749            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2750            
   2751            /* Disable the Input Capture channels 1 and 2
   2752              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */ 
   2753            if(Channel == TIM_CHANNEL_1)
   2754            {
   2755              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2756              
   2757              /* Disable the capture compare DMA Request 1 */
   2758              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2759            }  
   2760            else if(Channel == TIM_CHANNEL_2)
   2761            {  
   2762              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2763              
   2764              /* Disable the capture compare DMA Request 2 */
   2765              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2766            }  
   2767            else
   2768            {
   2769              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE); 
   2770              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE); 
   2771              
   2772              /* Disable the capture compare DMA Request 1 and 2 */
   2773              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2774              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2775            }
   2776            
   2777            /* Disable the Peripheral */
   2778            __HAL_TIM_DISABLE(htim);
   2779            
   2780            /* Change the htim state */
   2781            htim->State = HAL_TIM_STATE_READY;
   2782            
   2783            /* Return function status */
   2784            return HAL_OK;
   2785          }
   2786          /**
   2787            * @}
   2788            */
   2789            
   2790          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2791           *  @brief    IRQ handler management 
   2792           *
   2793          @verbatim   
   2794            ==============================================================================
   2795                                  ##### IRQ handler management #####
   2796            ==============================================================================  
   2797            [..]  
   2798              This section provides Timer IRQ handler function.
   2799                         
   2800          @endverbatim
   2801            * @{
   2802            */
   2803          /**
   2804            * @brief  This function handles TIM interrupts requests.
   2805            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2806            *                the configuration information for TIM module.
   2807            * @retval None
   2808            */
   2809          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2810          {
   2811            /* Capture compare 1 event */
   2812            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   2813            {
   2814              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   2815              {
   2816                {
   2817                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   2818                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   2819                  
   2820                  /* Input capture event */
   2821                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   2822                  {
   2823                    HAL_TIM_IC_CaptureCallback(htim);
   2824                  }
   2825                  /* Output compare event */
   2826                  else
   2827                  {
   2828                    HAL_TIM_OC_DelayElapsedCallback(htim);
   2829                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   2830                  }
   2831                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2832                }
   2833              }
   2834            }
   2835            /* Capture compare 2 event */
   2836            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   2837            {
   2838              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   2839              {
   2840                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   2841                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   2842                /* Input capture event */
   2843                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   2844                {          
   2845                  HAL_TIM_IC_CaptureCallback(htim);
   2846                }
   2847                /* Output compare event */
   2848                else
   2849                {
   2850                  HAL_TIM_OC_DelayElapsedCallback(htim);
   2851                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   2852                }
   2853                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2854              }
   2855            }
   2856            /* Capture compare 3 event */
   2857            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   2858            {
   2859              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   2860              {
   2861                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   2862                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   2863                /* Input capture event */
   2864                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   2865                {          
   2866                  HAL_TIM_IC_CaptureCallback(htim);
   2867                }
   2868                /* Output compare event */
   2869                else
   2870                {
   2871                  HAL_TIM_OC_DelayElapsedCallback(htim);
   2872                  HAL_TIM_PWM_PulseFinishedCallback(htim); 
   2873                }
   2874                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2875              }
   2876            }
   2877            /* Capture compare 4 event */
   2878            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   2879            {
   2880              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   2881              {
   2882                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   2883                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   2884                /* Input capture event */
   2885                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   2886                {          
   2887                  HAL_TIM_IC_CaptureCallback(htim);
   2888                }
   2889                /* Output compare event */
   2890                else
   2891                {
   2892                  HAL_TIM_OC_DelayElapsedCallback(htim);
   2893                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   2894                }
   2895                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2896              }
   2897            }
   2898            /* TIM Update event */
   2899            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   2900            {
   2901              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   2902              {
   2903                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   2904                HAL_TIM_PeriodElapsedCallback(htim);
   2905              }
   2906            }
   2907            /* TIM Break input event */
   2908            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   2909            {
   2910              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   2911              {
   2912                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   2913                HAL_TIMEx_BreakCallback(htim);
   2914              }
   2915            }
   2916            /* TIM Trigger detection event */
   2917            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   2918            {
   2919              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   2920              {
   2921                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   2922                HAL_TIM_TriggerCallback(htim);
   2923              }
   2924            }
   2925            /* TIM commutation event */
   2926            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   2927            {
   2928              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   2929              {
   2930                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   2931                HAL_TIMEx_CommutationCallback(htim);
   2932              }
   2933            }
   2934          }
   2935          /**
   2936            * @}
   2937            */
   2938            
   2939          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2940           *  @brief   	Peripheral Control functions 
   2941           *
   2942          @verbatim   
   2943            ==============================================================================
   2944                             ##### Peripheral Control functions #####
   2945            ==============================================================================  
   2946           [..] 
   2947             This section provides functions allowing to:
   2948             (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode. 
   2949             (+) Configure External Clock source.
   2950             (+) Configure Complementary channels, break features and dead time.
   2951             (+) Configure Master and the Slave synchronization.
   2952             (+) Configure the DMA Burst Mode.
   2953                
   2954          @endverbatim
   2955            * @{
   2956            */
   2957            
   2958          /**
   2959            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2960            *         parameters in the TIM_OC_InitTypeDef.
   2961            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   2962            *                the configuration information for TIM module.
   2963            * @param  sConfig TIM Output Compare configuration structure
   2964            * @param  Channel TIM Channels to be enabled.
   2965            *          This parameter can be one of the following values:
   2966            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2967            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2968            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2969            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2970            * @retval HAL status
   2971            */
   2972          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2973          {
   2974            /* Check the parameters */ 
   2975            assert_param(IS_TIM_CHANNELS(Channel)); 
   2976            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2977            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2978            
   2979            /* Check input state */
   2980            __HAL_LOCK(htim); 
   2981            
   2982            htim->State = HAL_TIM_STATE_BUSY;
   2983            
   2984            switch (Channel)
   2985            {
   2986              case TIM_CHANNEL_1:
   2987              {
   2988                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2989                /* Configure the TIM Channel 1 in Output Compare */
   2990                TIM_OC1_SetConfig(htim->Instance, sConfig);
   2991              }
   2992              break;
   2993              
   2994              case TIM_CHANNEL_2:
   2995              {
   2996                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2997                /* Configure the TIM Channel 2 in Output Compare */
   2998                TIM_OC2_SetConfig(htim->Instance, sConfig);
   2999              }
   3000              break;
   3001              
   3002              case TIM_CHANNEL_3:
   3003              {
   3004                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3005                /* Configure the TIM Channel 3 in Output Compare */
   3006                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3007              }
   3008              break;
   3009              
   3010              case TIM_CHANNEL_4:
   3011              {
   3012                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3013                /* Configure the TIM Channel 4 in Output Compare */
   3014                TIM_OC4_SetConfig(htim->Instance, sConfig);
   3015              }
   3016              break;
   3017              
   3018              default:
   3019              break;    
   3020            }
   3021            htim->State = HAL_TIM_STATE_READY;
   3022            
   3023            __HAL_UNLOCK(htim); 
   3024            
   3025            return HAL_OK;
   3026          }
   3027          
   3028          /**
   3029            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3030            *         parameters in the TIM_IC_InitTypeDef.
   3031            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3032            *                the configuration information for TIM module.
   3033            * @param  sConfig TIM Input Capture configuration structure
   3034            * @param  Channel TIM Channels to be enabled.
   3035            *          This parameter can be one of the following values:
   3036            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3037            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3038            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3039            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3040            * @retval HAL status
   3041            */
   3042          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3043          {
   3044            /* Check the parameters */
   3045            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3046            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3047            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3048            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3049            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3050            
   3051            __HAL_LOCK(htim);
   3052            
   3053            htim->State = HAL_TIM_STATE_BUSY;
   3054            
   3055            if (Channel == TIM_CHANNEL_1)
   3056            {
   3057              /* TI1 Configuration */
   3058              TIM_TI1_SetConfig(htim->Instance,
   3059                         sConfig->ICPolarity,
   3060                         sConfig->ICSelection,
   3061                         sConfig->ICFilter);
   3062                         
   3063              /* Reset the IC1PSC Bits */
   3064              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3065          
   3066              /* Set the IC1PSC value */
   3067              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   3068            }
   3069            else if (Channel == TIM_CHANNEL_2)
   3070            {
   3071              /* TI2 Configuration */
   3072              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3073              
   3074              TIM_TI2_SetConfig(htim->Instance, 
   3075                                sConfig->ICPolarity,
   3076                                sConfig->ICSelection,
   3077                                sConfig->ICFilter);
   3078                         
   3079              /* Reset the IC2PSC Bits */
   3080              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3081          
   3082              /* Set the IC2PSC value */
   3083              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   3084            }
   3085            else if (Channel == TIM_CHANNEL_3)
   3086            {
   3087              /* TI3 Configuration */
   3088              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3089              
   3090              TIM_TI3_SetConfig(htim->Instance,  
   3091                         sConfig->ICPolarity,
   3092                         sConfig->ICSelection,
   3093                         sConfig->ICFilter);
   3094                         
   3095              /* Reset the IC3PSC Bits */
   3096              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   3097          
   3098              /* Set the IC3PSC value */
   3099              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   3100            }
   3101            else
   3102            {
   3103              /* TI4 Configuration */
   3104              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3105              
   3106              TIM_TI4_SetConfig(htim->Instance, 
   3107                         sConfig->ICPolarity,
   3108                         sConfig->ICSelection,
   3109                         sConfig->ICFilter);
   3110                         
   3111              /* Reset the IC4PSC Bits */
   3112              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   3113          
   3114              /* Set the IC4PSC value */
   3115              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   3116            }
   3117            
   3118            htim->State = HAL_TIM_STATE_READY;
   3119              
   3120            __HAL_UNLOCK(htim);
   3121            
   3122            return HAL_OK; 
   3123          }
   3124          
   3125          /**
   3126            * @brief  Initializes the TIM PWM  channels according to the specified
   3127            *         parameters in the TIM_OC_InitTypeDef.
   3128            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3129            *                the configuration information for TIM module.
   3130            * @param  sConfig TIM PWM configuration structure
   3131            * @param  Channel TIM Channels to be enabled.
   3132            *          This parameter can be one of the following values:
   3133            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3134            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3135            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3136            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3137            * @retval HAL status
   3138            */
   3139          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3140          {
   3141            __HAL_LOCK(htim);
   3142            
   3143            /* Check the parameters */ 
   3144            assert_param(IS_TIM_CHANNELS(Channel)); 
   3145            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3146            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3147            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3148          
   3149            htim->State = HAL_TIM_STATE_BUSY;
   3150              
   3151            switch (Channel)
   3152            {
   3153              case TIM_CHANNEL_1:
   3154              {
   3155                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3156                /* Configure the Channel 1 in PWM mode */
   3157                TIM_OC1_SetConfig(htim->Instance, sConfig);
   3158                
   3159                /* Set the Preload enable bit for channel1 */
   3160                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   3161                
   3162                /* Configure the Output Fast mode */
   3163                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   3164                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   3165              }
   3166              break;
   3167              
   3168              case TIM_CHANNEL_2:
   3169              {
   3170                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3171                /* Configure the Channel 2 in PWM mode */
   3172                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3173                
   3174                /* Set the Preload enable bit for channel2 */
   3175                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   3176                
   3177                /* Configure the Output Fast mode */
   3178                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   3179                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   3180              }
   3181              break;
   3182              
   3183              case TIM_CHANNEL_3:
   3184              {
   3185                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3186                /* Configure the Channel 3 in PWM mode */
   3187                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3188                
   3189                /* Set the Preload enable bit for channel3 */
   3190                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   3191                
   3192               /* Configure the Output Fast mode */
   3193                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   3194                htim->Instance->CCMR2 |= sConfig->OCFastMode;  
   3195              }
   3196              break;
   3197              
   3198              case TIM_CHANNEL_4:
   3199              {
   3200                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3201                /* Configure the Channel 4 in PWM mode */
   3202                TIM_OC4_SetConfig(htim->Instance, sConfig);
   3203                
   3204                /* Set the Preload enable bit for channel4 */
   3205                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   3206                
   3207               /* Configure the Output Fast mode */
   3208                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   3209                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;  
   3210              }
   3211              break;
   3212              
   3213              default:
   3214              break;    
   3215            }
   3216            
   3217            htim->State = HAL_TIM_STATE_READY;
   3218              
   3219            __HAL_UNLOCK(htim);
   3220            
   3221            return HAL_OK;
   3222          }
   3223          
   3224          /**
   3225            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3226            *         parameters in the TIM_OnePulse_InitTypeDef.
   3227            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3228            *                the configuration information for TIM module.
   3229            * @param  sConfig TIM One Pulse configuration structure
   3230            * @param  OutputChannel TIM Channels to be enabled.
   3231            *          This parameter can be one of the following values:
   3232            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3233            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3234            * @param  InputChannel TIM Channels to be enabled.
   3235            *          This parameter can be one of the following values:
   3236            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3237            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3238            * @retval HAL status
   3239            */
   3240          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3241          {
   3242            TIM_OC_InitTypeDef temp1;
   3243            
   3244            /* Check the parameters */
   3245            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3246            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3247          
   3248            if(OutputChannel != InputChannel)  
   3249            {
   3250              __HAL_LOCK(htim);
   3251            
   3252              htim->State = HAL_TIM_STATE_BUSY;
   3253          
   3254              /* Extract the Output compare configuration from sConfig structure */  
   3255              temp1.OCMode = sConfig->OCMode;
   3256              temp1.Pulse = sConfig->Pulse;
   3257              temp1.OCPolarity = sConfig->OCPolarity;
   3258              temp1.OCNPolarity = sConfig->OCNPolarity;
   3259              temp1.OCIdleState = sConfig->OCIdleState;
   3260              temp1.OCNIdleState = sConfig->OCNIdleState; 
   3261              
   3262              switch (OutputChannel)
   3263              {
   3264                case TIM_CHANNEL_1:
   3265                {
   3266                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3267                
   3268                  TIM_OC1_SetConfig(htim->Instance, &temp1); 
   3269                }
   3270                break;
   3271                case TIM_CHANNEL_2:
   3272                {
   3273                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3274                
   3275                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   3276                }
   3277                break;
   3278                default:
   3279                break;  
   3280              } 
   3281              switch (InputChannel)
   3282              {
   3283                case TIM_CHANNEL_1:
   3284                {
   3285                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3286                
   3287                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3288                                  sConfig->ICSelection, sConfig->ICFilter);
   3289                         
   3290                  /* Reset the IC1PSC Bits */
   3291                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3292          
   3293                  /* Select the Trigger source */
   3294                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3295                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   3296                
   3297                  /* Select the Slave Mode */      
   3298                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3299                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3300                }
   3301                break;
   3302                case TIM_CHANNEL_2:
   3303                {
   3304                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3305                
   3306                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3307                           sConfig->ICSelection, sConfig->ICFilter);
   3308                         
   3309                  /* Reset the IC2PSC Bits */
   3310                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3311          
   3312                  /* Select the Trigger source */
   3313                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3314                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   3315                
   3316                  /* Select the Slave Mode */      
   3317                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3318                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3319                }
   3320                break;
   3321              
   3322                default:
   3323                break;  
   3324              }
   3325            
   3326              htim->State = HAL_TIM_STATE_READY;
   3327              
   3328              __HAL_UNLOCK(htim);
   3329            
   3330              return HAL_OK;
   3331            }
   3332            else
   3333            {
   3334              return HAL_ERROR;
   3335            }
   3336          } 
   3337          
   3338          /**
   3339            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral  
   3340            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3341            *                the configuration information for TIM module.
   3342            * @param  BurstBaseAddress TIM Base address from when the DMA will starts the Data write.
   3343            *         This parameters can be on of the following values:
   3344            *            @arg TIM_DMABASE_CR1  
   3345            *            @arg TIM_DMABASE_CR2
   3346            *            @arg TIM_DMABASE_SMCR
   3347            *            @arg TIM_DMABASE_DIER
   3348            *            @arg TIM_DMABASE_SR
   3349            *            @arg TIM_DMABASE_EGR
   3350            *            @arg TIM_DMABASE_CCMR1
   3351            *            @arg TIM_DMABASE_CCMR2
   3352            *            @arg TIM_DMABASE_CCER
   3353            *            @arg TIM_DMABASE_CNT   
   3354            *            @arg TIM_DMABASE_PSC   
   3355            *            @arg TIM_DMABASE_ARR
   3356            *            @arg TIM_DMABASE_RCR
   3357            *            @arg TIM_DMABASE_CCR1
   3358            *            @arg TIM_DMABASE_CCR2
   3359            *            @arg TIM_DMABASE_CCR3  
   3360            *            @arg TIM_DMABASE_CCR4
   3361            *            @arg TIM_DMABASE_BDTR
   3362            *            @arg TIM_DMABASE_DCR
   3363            * @param  BurstRequestSrc TIM DMA Request sources.
   3364            *         This parameters can be on of the following values:
   3365            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3366            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3367            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3368            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3369            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3370            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3371            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3372            * @param  BurstBuffer The Buffer address.
   3373            * @param  BurstLength DMA Burst length. This parameter can be one value
   3374            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3375            * @retval HAL status
   3376            */
   3377          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3378                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3379          {
   3380            /* Check the parameters */
   3381            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3382            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3383            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3384            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3385            
   3386            if((htim->State == HAL_TIM_STATE_BUSY))
   3387            {
   3388               return HAL_BUSY;
   3389            }
   3390            else if((htim->State == HAL_TIM_STATE_READY))
   3391            {
   3392              if((BurstBuffer == 0U) && (BurstLength > 0U)) 
   3393              {
   3394                return HAL_ERROR;                                    
   3395              }
   3396              else
   3397              {
   3398                htim->State = HAL_TIM_STATE_BUSY;
   3399              }
   3400            }
   3401            switch(BurstRequestSrc)
   3402            {
   3403              case TIM_DMA_UPDATE:
   3404              {  
   3405                /* Set the DMA Period elapsed callback */
   3406                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   3407               
   3408                /* Set the DMA error callback */
   3409                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   3410            
   3411                /* Enable the DMA Stream */
   3412                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U); 
   3413              }
   3414              break;
   3415              case TIM_DMA_CC1:
   3416              {  
   3417                /* Set the DMA Period elapsed callback */
   3418                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3419               
   3420                /* Set the DMA error callback */
   3421                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3422            
   3423                /* Enable the DMA Stream */
   3424                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   3425              }
   3426              break;
   3427              case TIM_DMA_CC2:
   3428              {  
   3429                /* Set the DMA Period elapsed callback */
   3430                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3431               
   3432                /* Set the DMA error callback */
   3433                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3434            
   3435                /* Enable the DMA Stream */
   3436                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   3437              }
   3438              break;
   3439              case TIM_DMA_CC3:
   3440              {  
   3441                /* Set the DMA Period elapsed callback */
   3442                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3443               
   3444                /* Set the DMA error callback */
   3445                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   3446            
   3447                /* Enable the DMA Stream */
   3448                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   3449              }
   3450              break;
   3451              case TIM_DMA_CC4:
   3452              {  
   3453                /* Set the DMA Period elapsed callback */
   3454                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   3455               
   3456                /* Set the DMA error callback */
   3457                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   3458            
   3459                /* Enable the DMA Stream */
   3460                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   3461              }
   3462              break;
   3463              case TIM_DMA_COM:
   3464              {  
   3465                /* Set the DMA Period elapsed callback */
   3466                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   3467               
   3468                /* Set the DMA error callback */
   3469                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   3470            
   3471                /* Enable the DMA Stream */
   3472                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   3473              }
   3474              break;
   3475              case TIM_DMA_TRIGGER:
   3476              {  
   3477                /* Set the DMA Period elapsed callback */
   3478                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3479               
   3480                /* Set the DMA error callback */
   3481                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   3482            
   3483                /* Enable the DMA Stream */
   3484                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);     
   3485              }
   3486              break;
   3487              default:
   3488              break;  
   3489            }
   3490             /* configure the DMA Burst Mode */
   3491             htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   3492             
   3493             /* Enable the TIM DMA Request */
   3494             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);  
   3495             
   3496             htim->State = HAL_TIM_STATE_READY;
   3497            
   3498            /* Return function status */
   3499            return HAL_OK;
   3500          }
   3501          
   3502          /**
   3503            * @brief  Stops the TIM DMA Burst mode 
   3504            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3505            *                the configuration information for TIM module.
   3506            * @param  BurstRequestSrc TIM DMA Request sources to disable
   3507            * @retval HAL status
   3508            */
   3509          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3510          {
   3511            /* Check the parameters */
   3512            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3513            
   3514            /* Abort the DMA transfer (at least disable the DMA channel) */
   3515            switch(BurstRequestSrc)
   3516            {
   3517              case TIM_DMA_UPDATE:
   3518              {  
   3519                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   3520              }
   3521              break;
   3522              case TIM_DMA_CC1:
   3523              {  
   3524                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   3525              }
   3526              break;
   3527              case TIM_DMA_CC2:
   3528              {  
   3529                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   3530              }
   3531              break;
   3532              case TIM_DMA_CC3:
   3533              {  
   3534                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   3535              }
   3536              break;
   3537              case TIM_DMA_CC4:
   3538              {  
   3539                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   3540              }
   3541              break;
   3542              case TIM_DMA_COM:
   3543              {  
   3544                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   3545              }
   3546              break;
   3547              case TIM_DMA_TRIGGER:
   3548              {  
   3549                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   3550              }
   3551              break;
   3552              default:
   3553              break;
   3554            }
   3555          
   3556            /* Disable the TIM Update DMA request */
   3557            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   3558                
   3559            /* Return function status */
   3560            return HAL_OK;  
   3561          }
   3562          
   3563          /**
   3564            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3565            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3566            *                the configuration information for TIM module.
   3567            * @param  BurstBaseAddress TIM Base address from when the DMA will starts the Data read.
   3568            *         This parameters can be on of the following values:
   3569            *            @arg TIM_DMABASE_CR1  
   3570            *            @arg TIM_DMABASE_CR2
   3571            *            @arg TIM_DMABASE_SMCR
   3572            *            @arg TIM_DMABASE_DIER
   3573            *            @arg TIM_DMABASE_SR
   3574            *            @arg TIM_DMABASE_EGR
   3575            *            @arg TIM_DMABASE_CCMR1
   3576            *            @arg TIM_DMABASE_CCMR2
   3577            *            @arg TIM_DMABASE_CCER
   3578            *            @arg TIM_DMABASE_CNT   
   3579            *            @arg TIM_DMABASE_PSC   
   3580            *            @arg TIM_DMABASE_ARR
   3581            *            @arg TIM_DMABASE_RCR
   3582            *            @arg TIM_DMABASE_CCR1
   3583            *            @arg TIM_DMABASE_CCR2
   3584            *            @arg TIM_DMABASE_CCR3  
   3585            *            @arg TIM_DMABASE_CCR4
   3586            *            @arg TIM_DMABASE_BDTR
   3587            *            @arg TIM_DMABASE_DCR
   3588            * @param  BurstRequestSrc TIM DMA Request sources.
   3589            *         This parameters can be on of the following values:
   3590            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3591            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3592            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3593            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3594            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3595            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3596            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3597            * @param  BurstBuffer The Buffer address.
   3598            * @param  BurstLength DMA Burst length. This parameter can be one value
   3599            *         between TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3600            * @retval HAL status
   3601            */
   3602          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3603                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3604          {
   3605            /* Check the parameters */
   3606            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3607            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3608            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3609            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3610            
   3611            if((htim->State == HAL_TIM_STATE_BUSY))
   3612            {
   3613               return HAL_BUSY;
   3614            }
   3615            else if((htim->State == HAL_TIM_STATE_READY))
   3616            {
   3617              if((BurstBuffer == 0U) && (BurstLength > 0U)) 
   3618              {
   3619                return HAL_ERROR;                                    
   3620              }
   3621              else
   3622              {
   3623                htim->State = HAL_TIM_STATE_BUSY;
   3624              }
   3625            }  
   3626            switch(BurstRequestSrc)
   3627            {
   3628              case TIM_DMA_UPDATE:
   3629              {  
   3630                /* Set the DMA Period elapsed callback */
   3631                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   3632               
   3633                /* Set the DMA error callback */
   3634                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   3635            
   3636                /* Enable the DMA Stream */
   3637                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);     
   3638              }
   3639              break;
   3640              case TIM_DMA_CC1:
   3641              {  
   3642                /* Set the DMA Period elapsed callback */
   3643                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   3644               
   3645                /* Set the DMA error callback */
   3646                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3647            
   3648                /* Enable the DMA Stream */
   3649                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   3650              }
   3651              break;
   3652              case TIM_DMA_CC2:
   3653              {  
   3654                /* Set the DMA Period elapsed callback */
   3655                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   3656               
   3657                /* Set the DMA error callback */
   3658                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3659            
   3660                /* Enable the DMA Stream */
   3661                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);     
   3662              }
   3663              break;
   3664              case TIM_DMA_CC3:
   3665              {  
   3666                /* Set the DMA Period elapsed callback */
   3667                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   3668               
   3669                /* Set the DMA error callback */
   3670                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   3671            
   3672                /* Enable the DMA Stream */
   3673                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   3674              }
   3675              break;
   3676              case TIM_DMA_CC4:
   3677              {  
   3678                /* Set the DMA Period elapsed callback */
   3679                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   3680               
   3681                /* Set the DMA error callback */
   3682                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   3683            
   3684                /* Enable the DMA Stream */
   3685                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   3686              }
   3687              break;
   3688              case TIM_DMA_COM:
   3689              {  
   3690                /* Set the DMA Period elapsed callback */
   3691                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   3692               
   3693                /* Set the DMA error callback */
   3694                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   3695            
   3696                /* Enable the DMA Stream */
   3697                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);      
   3698              }
   3699              break;
   3700              case TIM_DMA_TRIGGER:
   3701              {  
   3702                /* Set the DMA Period elapsed callback */
   3703                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3704               
   3705                /* Set the DMA error callback */
   3706                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   3707            
   3708                /* Enable the DMA Stream */
   3709                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1);      
   3710              }
   3711              break;
   3712              default:
   3713              break;  
   3714            }
   3715          
   3716            /* configure the DMA Burst Mode */
   3717            htim->Instance->DCR = BurstBaseAddress | BurstLength;  
   3718            
   3719            /* Enable the TIM DMA Request */
   3720            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   3721            
   3722            htim->State = HAL_TIM_STATE_READY;
   3723            
   3724            /* Return function status */
   3725            return HAL_OK;
   3726          }
   3727          
   3728          /**
   3729            * @brief  Stop the DMA burst reading 
   3730            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3731            *                the configuration information for TIM module.
   3732            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   3733            * @retval HAL status
   3734            */
   3735          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3736          {
   3737            /* Check the parameters */
   3738            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3739            
   3740            /* Abort the DMA transfer (at least disable the DMA channel) */
   3741            switch(BurstRequestSrc)
   3742            {
   3743              case TIM_DMA_UPDATE:
   3744              {  
   3745                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   3746              }
   3747              break;
   3748              case TIM_DMA_CC1:
   3749              {  
   3750                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   3751              }
   3752              break;
   3753              case TIM_DMA_CC2:
   3754              {  
   3755                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   3756              }
   3757              break;
   3758              case TIM_DMA_CC3:
   3759              {  
   3760                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   3761              }
   3762              break;
   3763              case TIM_DMA_CC4:
   3764              {  
   3765                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   3766              }
   3767              break;
   3768              case TIM_DMA_COM:
   3769              {  
   3770                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   3771              }
   3772              break;
   3773              case TIM_DMA_TRIGGER:
   3774              {  
   3775                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   3776              }
   3777              break;
   3778              default:
   3779              break;  
   3780            }
   3781            
   3782            /* Disable the TIM Update DMA request */
   3783            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   3784                
   3785            /* Return function status */
   3786            return HAL_OK;  
   3787          }
   3788          
   3789          /**
   3790            * @brief  Generate a software event
   3791            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3792            *                the configuration information for TIM module.
   3793            * @param  EventSource specifies the event source.
   3794            *          This parameter can be one of the following values:
   3795            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3796            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3797            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3798            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3799            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3800            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source  
   3801            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3802            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3803            * @note   TIM6 and TIM7 can only generate an update event. 
   3804            * @note   TIM_EVENTSOURCE_COM and TIM_EVENTSOURCE_BREAK are used only with TIM1 and TIM8.
   3805            * @retval HAL status
   3806            */ 
   3807          
   3808          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3809          {
   3810            /* Check the parameters */
   3811            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3812            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3813            
   3814            /* Process Locked */
   3815            __HAL_LOCK(htim);
   3816            
   3817            /* Change the TIM state */
   3818            htim->State = HAL_TIM_STATE_BUSY;
   3819            
   3820            /* Set the event sources */
   3821            htim->Instance->EGR = EventSource;
   3822            
   3823            /* Change the TIM state */
   3824            htim->State = HAL_TIM_STATE_READY;
   3825            
   3826            __HAL_UNLOCK(htim);
   3827            
   3828            /* Return function status */
   3829            return HAL_OK;  
   3830          }
   3831          
   3832          /**
   3833            * @brief  Configures the OCRef clear feature
   3834            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3835            *                the configuration information for TIM module.
   3836            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   3837            *         contains the OCREF clear feature and parameters for the TIM peripheral. 
   3838            * @param  Channel specifies the TIM Channel.
   3839            *          This parameter can be one of the following values:
   3840            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3841            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3842            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3843            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3844            * @retval HAL status
   3845            */ 
   3846          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3847          { 
   3848            /* Check the parameters */
   3849            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3850            assert_param(IS_TIM_CHANNELS(Channel));
   3851            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3852            assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3853            assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3854            assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3855             
   3856            /* Process Locked */
   3857            __HAL_LOCK(htim);
   3858            
   3859            htim->State = HAL_TIM_STATE_BUSY;
   3860            
   3861            if(sClearInputConfig->ClearInputSource == TIM_CLEARINPUTSOURCE_ETR)
   3862            {
   3863              TIM_ETR_SetConfig(htim->Instance, 
   3864                                sClearInputConfig->ClearInputPrescaler,
   3865                                sClearInputConfig->ClearInputPolarity,
   3866                                sClearInputConfig->ClearInputFilter);
   3867            }
   3868            
   3869            switch (Channel)
   3870            {
   3871              case TIM_CHANNEL_1:
   3872              {        
   3873                if(sClearInputConfig->ClearInputState != RESET)  
   3874                {
   3875                  /* Enable the Ocref clear feature for Channel 1 */
   3876                  htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   3877                }
   3878                else
   3879                {
   3880                  /* Disable the Ocref clear feature for Channel 1 */
   3881                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;      
   3882                }
   3883              }    
   3884              break;
   3885              case TIM_CHANNEL_2:    
   3886              { 
   3887                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance)); 
   3888                if(sClearInputConfig->ClearInputState != RESET)  
   3889                {
   3890                  /* Enable the Ocref clear feature for Channel 2 */
   3891                  htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   3892                }
   3893                else
   3894                {
   3895                  /* Disable the Ocref clear feature for Channel 2 */
   3896                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;      
   3897                }
   3898              } 
   3899              break;
   3900              case TIM_CHANNEL_3:   
   3901              {  
   3902                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3903                if(sClearInputConfig->ClearInputState != RESET)  
   3904                {
   3905                  /* Enable the Ocref clear feature for Channel 3 */
   3906                  htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   3907                }
   3908                else
   3909                {
   3910                  /* Disable the Ocref clear feature for Channel 3 */
   3911                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;      
   3912                }
   3913              } 
   3914              break;
   3915              case TIM_CHANNEL_4:    
   3916              {  
   3917                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3918                if(sClearInputConfig->ClearInputState != RESET)  
   3919                {
   3920                  /* Enable the Ocref clear feature for Channel 4 */
   3921                  htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   3922                }
   3923                else
   3924                {
   3925                  /* Disable the Ocref clear feature for Channel 4 */
   3926                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;      
   3927                }
   3928              } 
   3929              break;
   3930              default:  
   3931              break;
   3932            } 
   3933          
   3934            htim->State = HAL_TIM_STATE_READY;
   3935            
   3936            __HAL_UNLOCK(htim);
   3937            
   3938            return HAL_OK;  
   3939          }  
   3940          
   3941          /**
   3942            * @brief   Configures the clock source to be used
   3943            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   3944            *                the configuration information for TIM module.
   3945            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   3946            *         contains the clock source information for the TIM peripheral. 
   3947            * @retval HAL status
   3948            */ 
   3949          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)    
   3950          {
   3951            uint32_t tmpsmcr = 0U;
   3952              
   3953            /* Process Locked */
   3954            __HAL_LOCK(htim);
   3955            
   3956            htim->State = HAL_TIM_STATE_BUSY;
   3957            
   3958            /* Check the parameters */
   3959            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3960            
   3961            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3962            tmpsmcr = htim->Instance->SMCR;
   3963            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3964            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3965            htim->Instance->SMCR = tmpsmcr;
   3966            
   3967            switch (sClockSourceConfig->ClockSource)
   3968            {
   3969              case TIM_CLOCKSOURCE_INTERNAL:
   3970              { 
   3971                assert_param(IS_TIM_INSTANCE(htim->Instance));
   3972                
   3973                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3974                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3975              }
   3976              break;
   3977              
   3978              case TIM_CLOCKSOURCE_ETRMODE1:
   3979              {
   3980                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   3981          
   3982                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3983                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3984                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3985          
   3986                /* Configure the ETR Clock source */
   3987                TIM_ETR_SetConfig(htim->Instance, 
   3988                                  sClockSourceConfig->ClockPrescaler, 
   3989                                  sClockSourceConfig->ClockPolarity, 
   3990                                  sClockSourceConfig->ClockFilter);
   3991                /* Get the TIMx SMCR register value */
   3992                tmpsmcr = htim->Instance->SMCR;
   3993                /* Reset the SMS and TS Bits */
   3994                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3995                /* Select the External clock mode1 and the ETRF trigger */
   3996                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   3997                /* Write to TIMx SMCR */
   3998                htim->Instance->SMCR = tmpsmcr;
   3999              }
   4000              break;
   4001              
   4002              case TIM_CLOCKSOURCE_ETRMODE2:
   4003              {
   4004                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   4005          
   4006                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4007                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4008                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4009          
   4010                /* Configure the ETR Clock source */
   4011                TIM_ETR_SetConfig(htim->Instance, 
   4012                                  sClockSourceConfig->ClockPrescaler, 
   4013                                  sClockSourceConfig->ClockPolarity,
   4014                                  sClockSourceConfig->ClockFilter);
   4015                /* Enable the External clock mode2 */
   4016                htim->Instance->SMCR |= TIM_SMCR_ECE;
   4017              }
   4018              break;
   4019              
   4020              case TIM_CLOCKSOURCE_TI1:
   4021              {
   4022                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4023          
   4024                /* Check TI1 input conditioning related parameters */
   4025                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4026                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4027          
   4028                TIM_TI1_ConfigInputStage(htim->Instance, 
   4029                                  sClockSourceConfig->ClockPolarity, 
   4030                                  sClockSourceConfig->ClockFilter);
   4031                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   4032              }
   4033              break;
   4034              case TIM_CLOCKSOURCE_TI2:
   4035              {
   4036                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4037          
   4038                /* Check TI1 input conditioning related parameters */
   4039                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4040                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4041          
   4042                TIM_TI2_ConfigInputStage(htim->Instance, 
   4043                                  sClockSourceConfig->ClockPolarity, 
   4044                                  sClockSourceConfig->ClockFilter);
   4045                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   4046              }
   4047              break;
   4048              case TIM_CLOCKSOURCE_TI1ED:
   4049              {
   4050                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4051          
   4052                /* Check TI1 input conditioning related parameters */
   4053                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4054                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4055          
   4056                TIM_TI1_ConfigInputStage(htim->Instance, 
   4057                                  sClockSourceConfig->ClockPolarity,
   4058                                  sClockSourceConfig->ClockFilter);
   4059                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   4060              }
   4061              break;
   4062              case TIM_CLOCKSOURCE_ITR0:
   4063              {
   4064                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4065                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   4066              }
   4067              break;
   4068              case TIM_CLOCKSOURCE_ITR1:
   4069              {
   4070                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4071                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   4072              }
   4073              break;
   4074              case TIM_CLOCKSOURCE_ITR2:
   4075              {
   4076                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4077                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   4078              }
   4079              break;
   4080              case TIM_CLOCKSOURCE_ITR3:
   4081              {
   4082                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4083                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   4084              }
   4085              break;
   4086              
   4087              default:
   4088              break;    
   4089            }
   4090            htim->State = HAL_TIM_STATE_READY;
   4091            
   4092            __HAL_UNLOCK(htim);
   4093            
   4094            return HAL_OK;
   4095          }
   4096          
   4097          /**
   4098            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4099            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4100            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4101            *                the configuration information for TIM module.
   4102            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   4103            *         output of a XOR gate.
   4104            *         This parameter can be one of the following values:
   4105            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4106            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4107            *            pins are connected to the TI1 input (XOR combination)
   4108            * @retval HAL status
   4109            */
   4110          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4111          {
   4112            uint32_t tmpcr2 = 0U;
   4113            
   4114            /* Check the parameters */
   4115            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance)); 
   4116            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4117          
   4118            /* Get the TIMx CR2 register value */
   4119            tmpcr2 = htim->Instance->CR2;
   4120          
   4121            /* Reset the TI1 selection */
   4122            tmpcr2 &= ~TIM_CR2_TI1S;
   4123          
   4124            /* Set the TI1 selection */
   4125            tmpcr2 |= TI1_Selection;
   4126            
   4127            /* Write to TIMxCR2 */
   4128            htim->Instance->CR2 = tmpcr2;
   4129          
   4130            return HAL_OK;
   4131          }
   4132          
   4133          /**
   4134            * @brief  Configures the TIM in Slave mode
   4135            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4136            *                the configuration information for TIM module.
   4137            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4138            *         contains the selected trigger (internal trigger input, filtered
   4139            *         timer input or external trigger input) and the ) and the Slave 
   4140            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4141            * @retval HAL status
   4142            */
   4143          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4144          {
   4145            /* Check the parameters */
   4146            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4147            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4148            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4149             
   4150            __HAL_LOCK(htim);
   4151            
   4152            htim->State = HAL_TIM_STATE_BUSY;
   4153          
   4154            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   4155            
   4156            /* Disable Trigger Interrupt */
   4157            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   4158            
   4159            /* Disable Trigger DMA request */
   4160            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4161            
   4162            htim->State = HAL_TIM_STATE_READY;
   4163               
   4164            __HAL_UNLOCK(htim);  
   4165            
   4166            return HAL_OK;
   4167          } 
   4168          
   4169          /**
   4170            * @brief  Configures the TIM in Slave mode in interrupt mode
   4171            * @param  htim TIM handle.
   4172            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4173            *         contains the selected trigger (internal trigger input, filtered
   4174            *         timer input or external trigger input) and the ) and the Slave 
   4175            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1). 
   4176            * @retval HAL status
   4177            */
   4178          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim, 
   4179                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4180          {
   4181            /* Check the parameters */
   4182            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4183            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4184            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4185            
   4186            __HAL_LOCK(htim);
   4187          
   4188            htim->State = HAL_TIM_STATE_BUSY;
   4189            
   4190            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   4191            
   4192            /* Enable Trigger Interrupt */
   4193            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   4194            
   4195            /* Disable Trigger DMA request */
   4196            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4197            
   4198            htim->State = HAL_TIM_STATE_READY;
   4199               
   4200            __HAL_UNLOCK(htim);  
   4201            
   4202            return HAL_OK;
   4203          }
   4204          
   4205          /**
   4206            * @brief  Read the captured value from Capture Compare unit
   4207            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4208            *                the configuration information for TIM module.
   4209            * @param  Channel TIM Channels to be enabled.
   4210            *          This parameter can be one of the following values:
   4211            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4212            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4213            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4214            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4215            * @retval Captured value
   4216            */
   4217          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4218          {
   4219            uint32_t tmpreg = 0U;
   4220            
   4221            __HAL_LOCK(htim);
   4222            
   4223            switch (Channel)
   4224            {
   4225              case TIM_CHANNEL_1:
   4226              {
   4227                /* Check the parameters */
   4228                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4229                
   4230                /* Return the capture 1 value */
   4231                tmpreg = htim->Instance->CCR1;
   4232                
   4233                break;
   4234              }
   4235              case TIM_CHANNEL_2:
   4236              {
   4237                /* Check the parameters */
   4238                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4239                
   4240                /* Return the capture 2 value */
   4241                tmpreg = htim->Instance->CCR2;
   4242                
   4243                break;
   4244              }
   4245              
   4246              case TIM_CHANNEL_3:
   4247              {
   4248                /* Check the parameters */
   4249                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4250                
   4251                /* Return the capture 3 value */
   4252                tmpreg = htim->Instance->CCR3;
   4253                
   4254                break;
   4255              }
   4256              
   4257              case TIM_CHANNEL_4:
   4258              {
   4259                /* Check the parameters */
   4260                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4261                
   4262                /* Return the capture 4 value */
   4263                tmpreg = htim->Instance->CCR4;
   4264                
   4265                break;
   4266              }
   4267              
   4268              default:
   4269              break;  
   4270            }
   4271               
   4272            __HAL_UNLOCK(htim);  
   4273            return tmpreg;
   4274          }
   4275          /**
   4276            * @}
   4277            */
   4278            
   4279          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4280           *  @brief    TIM Callbacks functions 
   4281           *
   4282          @verbatim   
   4283            ==============================================================================
   4284                                  ##### TIM Callbacks functions #####
   4285            ==============================================================================  
   4286           [..]  
   4287             This section provides TIM callback functions:
   4288             (+) Timer Period elapsed callback
   4289             (+) Timer Output Compare callback
   4290             (+) Timer Input capture callback
   4291             (+) Timer Trigger callback
   4292             (+) Timer Error callback
   4293          
   4294          @endverbatim
   4295            * @{
   4296            */
   4297          
   4298          /**
   4299            * @brief  Period elapsed callback in non blocking mode 
   4300            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4301            *                the configuration information for TIM module.
   4302            * @retval None
   4303            */
   4304          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4305          {
   4306            /* Prevent unused argument(s) compilation warning */
   4307            UNUSED(htim);
   4308            /* NOTE : This function Should not be modified, when the callback is needed,
   4309                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4310             */
   4311          }
   4312          
   4313          /**
   4314            * @brief  Output Compare callback in non blocking mode 
   4315            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4316            *                the configuration information for TIM module.
   4317            * @retval None
   4318            */
   4319          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4320          {
   4321            /* Prevent unused argument(s) compilation warning */
   4322            UNUSED(htim);
   4323            /* NOTE : This function Should not be modified, when the callback is needed,
   4324                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4325             */
   4326          }
   4327          
   4328          /**
   4329            * @brief  Input Capture callback in non blocking mode 
   4330            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4331            *                the configuration information for TIM module.
   4332            * @retval None
   4333            */
   4334          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4335          {
   4336            /* Prevent unused argument(s) compilation warning */
   4337            UNUSED(htim);
   4338            /* NOTE : This function Should not be modified, when the callback is needed,
   4339                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4340             */
   4341          }
   4342          
   4343          /**
   4344            * @brief  PWM Pulse finished callback in non blocking mode 
   4345            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4346            *                the configuration information for TIM module.
   4347            * @retval None
   4348            */
   4349          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4350          {
   4351            /* Prevent unused argument(s) compilation warning */
   4352            UNUSED(htim);
   4353            /* NOTE : This function Should not be modified, when the callback is needed,
   4354                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4355             */
   4356          }
   4357          
   4358          /**
   4359            * @brief  Hall Trigger detection callback in non blocking mode 
   4360            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4361            *                the configuration information for TIM module.
   4362            * @retval None
   4363            */
   4364          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4365          {
   4366            /* Prevent unused argument(s) compilation warning */
   4367            UNUSED(htim);
   4368            /* NOTE : This function Should not be modified, when the callback is needed,
   4369                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4370             */
   4371          }
   4372          
   4373          /**
   4374            * @brief  Timer error callback in non blocking mode 
   4375            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4376            *                the configuration information for TIM module.
   4377            * @retval None
   4378            */
   4379          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4380          {
   4381            /* Prevent unused argument(s) compilation warning */
   4382            UNUSED(htim);
   4383            /* NOTE : This function Should not be modified, when the callback is needed,
   4384                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4385             */
   4386          }
   4387          /**
   4388            * @}
   4389            */
   4390          
   4391          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4392           *  @brief   Peripheral State functions 
   4393           *
   4394          @verbatim   
   4395            ==============================================================================
   4396                                  ##### Peripheral State functions #####
   4397            ==============================================================================  
   4398            [..]
   4399              This subsection permits to get in run-time the status of the peripheral 
   4400              and the data flow.
   4401          
   4402          @endverbatim
   4403            * @{
   4404            */
   4405          
   4406          /**
   4407            * @brief  Return the TIM Base state
   4408            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4409            *                the configuration information for TIM module.
   4410            * @retval HAL state
   4411            */
   4412          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4413          {
   4414            return htim->State;
   4415          }
   4416          
   4417          /**
   4418            * @brief  Return the TIM OC state
   4419            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4420            *                the configuration information for TIM module.
   4421            * @retval HAL state
   4422            */
   4423          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4424          {
   4425            return htim->State;
   4426          }
   4427          
   4428          /**
   4429            * @brief  Return the TIM PWM state
   4430            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4431            *                the configuration information for TIM module.
   4432            * @retval HAL state
   4433            */
   4434          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4435          {
   4436            return htim->State;
   4437          }
   4438          
   4439          /**
   4440            * @brief  Return the TIM Input Capture state
   4441            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4442            *                the configuration information for TIM module.
   4443            * @retval HAL state
   4444            */
   4445          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4446          {
   4447            return htim->State;
   4448          }
   4449          
   4450          /**
   4451            * @brief  Return the TIM One Pulse Mode state
   4452            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4453            *                the configuration information for TIM module.
   4454            * @retval HAL state
   4455            */
   4456          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4457          {
   4458            return htim->State;
   4459          }
   4460          
   4461          /**
   4462            * @brief  Return the TIM Encoder Mode state
   4463            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4464            *                the configuration information for TIM module.
   4465            * @retval HAL state
   4466            */
   4467          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4468          {
   4469            return htim->State;
   4470          }
   4471          /**
   4472            * @}
   4473            */
   4474          
   4475          /**
   4476            * @brief  Time Base configuration
   4477            * @param  TIMx TIM peripheral
   4478            * @param  Structure pointer on TIM Time Base required parameters  
   4479            * @retval None
   4480            */
   4481          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4482          {
   4483            uint32_t tmpcr1 = 0U;
   4484            tmpcr1 = TIMx->CR1;
   4485            
   4486            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4487            if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
   4488            {
   4489              /* Select the Counter Mode */
   4490              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4491              tmpcr1 |= Structure->CounterMode;
   4492            }
   4493           
   4494            if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
   4495            {
   4496              /* Set the clock division */
   4497              tmpcr1 &= ~TIM_CR1_CKD;
   4498              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   4499            }
   4500          
   4501            TIMx->CR1 = tmpcr1;
   4502          
   4503            /* Set the Auto-reload value */
   4504            TIMx->ARR = (uint32_t)Structure->Period ;
   4505           
   4506            /* Set the Prescaler value */
   4507            TIMx->PSC = (uint32_t)Structure->Prescaler;
   4508              
   4509            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
   4510            {
   4511              /* Set the Repetition Counter value */
   4512              TIMx->RCR = Structure->RepetitionCounter;
   4513            }
   4514          
   4515            /* Generate an update event to reload the Prescaler 
   4516               and the repetition counter(only for TIM1 and TIM8) value immediately */
   4517            TIMx->EGR = TIM_EGR_UG;
   4518          }
   4519          
   4520          /**
   4521            * @brief  Configure the TI1 as Input.
   4522            * @param  TIMx to select the TIM peripheral.
   4523            * @param  TIM_ICPolarity  The Input Polarity.
   4524            *          This parameter can be one of the following values:
   4525            *            @arg TIM_ICPolarity_Rising
   4526            *            @arg TIM_ICPolarity_Falling
   4527            *            @arg TIM_ICPolarity_BothEdge  
   4528            * @param  TIM_ICSelection specifies the input to be used.
   4529            *          This parameter can be one of the following values:
   4530            *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
   4531            *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
   4532            *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
   4533            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   4534            *          This parameter must be a value between 0x00 and 0x0F.
   4535            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   4536            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   4537            *        protected against un-initialized filter and polarity values.
   4538            * @retval None
   4539            */
   4540          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   4541                                 uint32_t TIM_ICFilter)
   4542          {
   4543            uint32_t tmpccmr1 = 0U;
   4544            uint32_t tmpccer = 0U;
   4545            
   4546            /* Disable the Channel 1: Reset the CC1E Bit */
   4547            TIMx->CCER &= ~TIM_CCER_CC1E;
   4548            tmpccmr1 = TIMx->CCMR1;
   4549            tmpccer = TIMx->CCER;
   4550          
   4551            /* Select the Input */
   4552            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   4553            {
   4554              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   4555              tmpccmr1 |= TIM_ICSelection;
   4556            } 
   4557            else
   4558            {
   4559              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   4560              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   4561            }
   4562          
   4563            /* Set the filter */
   4564            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4565            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   4566          
   4567            /* Select the Polarity and set the CC1E Bit */
   4568            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   4569            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   4570          
   4571            /* Write to TIMx CCMR1 and CCER registers */
   4572            TIMx->CCMR1 = tmpccmr1;
   4573            TIMx->CCER = tmpccer;
   4574          }
   4575          
   4576          /**
   4577            * @brief  Time Output Compare 2 configuration
   4578            * @param  TIMx to select the TIM peripheral
   4579            * @param  OC_Config The output configuration structure
   4580            * @retval None
   4581            */
   4582          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4583          {
   4584            uint32_t tmpccmrx = 0U;
   4585            uint32_t tmpccer = 0U;
   4586            uint32_t tmpcr2 = 0U;
   4587             
   4588            /* Disable the Channel 2: Reset the CC2E Bit */
   4589            TIMx->CCER &= ~TIM_CCER_CC2E;
   4590            
   4591            /* Get the TIMx CCER register value */  
   4592            tmpccer = TIMx->CCER;
   4593            /* Get the TIMx CR2 register value */
   4594            tmpcr2 = TIMx->CR2;
   4595            
   4596            /* Get the TIMx CCMR1 register value */
   4597            tmpccmrx = TIMx->CCMR1;
   4598              
   4599            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4600            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4601            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4602            
   4603            /* Select the Output Compare Mode */
   4604            tmpccmrx |= (OC_Config->OCMode << 8U);
   4605            
   4606            /* Reset the Output Polarity level */
   4607            tmpccer &= ~TIM_CCER_CC2P;
   4608            /* Set the Output Compare Polarity */
   4609            tmpccer |= (OC_Config->OCPolarity << 4U);
   4610              
   4611            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   4612            {
   4613              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4614              
   4615              /* Reset the Output N Polarity level */
   4616              tmpccer &= ~TIM_CCER_CC2NP;
   4617              /* Set the Output N Polarity */
   4618              tmpccer |= (OC_Config->OCNPolarity << 4U);
   4619              /* Reset the Output N State */
   4620              tmpccer &= ~TIM_CCER_CC2NE;
   4621              
   4622              /* Reset the Output Compare and Output Compare N IDLE State */
   4623              tmpcr2 &= ~TIM_CR2_OIS2;
   4624              tmpcr2 &= ~TIM_CR2_OIS2N;
   4625              /* Set the Output Idle state */
   4626              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   4627              /* Set the Output N Idle state */
   4628              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   4629            }
   4630            /* Write to TIMx CR2 */
   4631            TIMx->CR2 = tmpcr2;
   4632            
   4633            /* Write to TIMx CCMR1 */
   4634            TIMx->CCMR1 = tmpccmrx;
   4635            
   4636            /* Set the Capture Compare Register value */
   4637            TIMx->CCR2 = OC_Config->Pulse;
   4638            
   4639            /* Write to TIMx CCER */
   4640            TIMx->CCER = tmpccer;
   4641          }
   4642          
   4643          /**
   4644            * @brief  TIM DMA Delay Pulse complete callback. 
   4645            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   4646            *               the configuration information for the specified DMA module.
   4647            * @retval None
   4648            */
   4649          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4650          {
   4651            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4652            
   4653            htim->State= HAL_TIM_STATE_READY; 
   4654            
   4655            if(hdma == htim->hdma[TIM_DMA_ID_CC1])
   4656            {
   4657              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   4658            }
   4659            else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
   4660            {
   4661              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   4662            }
   4663            else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
   4664            {
   4665              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   4666            }
   4667            else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
   4668            {
   4669              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   4670            }
   4671          
   4672            HAL_TIM_PWM_PulseFinishedCallback(htim);
   4673          
   4674            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;  
   4675          }
   4676          
   4677          /**
   4678            * @brief  TIM DMA error callback 
   4679            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   4680            *                the configuration information for the specified DMA module.
   4681            * @retval None
   4682            */
   4683          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   4684          {
   4685            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4686            
   4687            htim->State= HAL_TIM_STATE_READY;
   4688             
   4689            HAL_TIM_ErrorCallback(htim);
   4690          }
   4691          
   4692          /**
   4693            * @brief  TIM DMA Capture complete callback. 
   4694            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   4695            *                the configuration information for the specified DMA module.
   4696            * @retval None
   4697            */
   4698          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4699          {
   4700            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4701            
   4702            htim->State= HAL_TIM_STATE_READY;
   4703            
   4704            if(hdma == htim->hdma[TIM_DMA_ID_CC1])
   4705            {
   4706              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   4707            }
   4708            else if(hdma == htim->hdma[TIM_DMA_ID_CC2])
   4709            {
   4710              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   4711            }
   4712            else if(hdma == htim->hdma[TIM_DMA_ID_CC3])
   4713            {
   4714              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   4715            }
   4716            else if(hdma == htim->hdma[TIM_DMA_ID_CC4])
   4717            {
   4718              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   4719            }
   4720            
   4721            HAL_TIM_IC_CaptureCallback(htim); 
   4722            
   4723            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   4724          }
   4725          
   4726          /**
   4727            * @brief  Enables or disables the TIM Capture Compare Channel x.
   4728            * @param  TIMx to select the TIM peripheral
   4729            * @param  Channel specifies the TIM Channel
   4730            *          This parameter can be one of the following values:
   4731            *            @arg TIM_Channel_1: TIM Channel 1
   4732            *            @arg TIM_Channel_2: TIM Channel 2
   4733            *            @arg TIM_Channel_3: TIM Channel 3
   4734            *            @arg TIM_Channel_4: TIM Channel 4
   4735            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   4736            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable. 
   4737            * @retval None
   4738            */
   4739          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   4740          {
   4741            uint32_t tmp = 0U;
   4742          
   4743            /* Check the parameters */
   4744            assert_param(IS_TIM_CC1_INSTANCE(TIMx)); 
   4745            assert_param(IS_TIM_CHANNELS(Channel));
   4746          
   4747            tmp = TIM_CCER_CC1E << Channel;
   4748          
   4749            /* Reset the CCxE Bit */
   4750            TIMx->CCER &= ~tmp;
   4751          
   4752            /* Set or reset the CCxE Bit */ 
   4753            TIMx->CCER |= (uint32_t)(ChannelState << Channel);
   4754          }
   4755          
   4756          /**
   4757            * @brief  TIM DMA Period Elapse complete callback. 
   4758            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   4759            *                the configuration information for the specified DMA module.
   4760            * @retval None
   4761            */
   4762          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4763          {
   4764            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4765            
   4766            htim->State= HAL_TIM_STATE_READY;
   4767            
   4768            HAL_TIM_PeriodElapsedCallback(htim);
   4769          }
   4770          
   4771          /**
   4772            * @brief  TIM DMA Trigger callback. 
   4773            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   4774            *                the configuration information for the specified DMA module.
   4775            * @retval None
   4776            */
   4777          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4778          {
   4779            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;  
   4780            
   4781            htim->State= HAL_TIM_STATE_READY; 
   4782            
   4783            HAL_TIM_TriggerCallback(htim);
   4784          }
   4785          
   4786          /**
   4787            * @brief  Time Output Compare 1 configuration
   4788            * @param  TIMx to select the TIM peripheral
   4789            * @param  OC_Config The output configuration structure
   4790            * @retval None
   4791            */
   4792          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4793          {
   4794            uint32_t tmpccmrx = 0U;
   4795            uint32_t tmpccer = 0U;
   4796            uint32_t tmpcr2 = 0U;  
   4797          
   4798            /* Disable the Channel 1: Reset the CC1E Bit */
   4799            TIMx->CCER &= ~TIM_CCER_CC1E;
   4800            
   4801            /* Get the TIMx CCER register value */
   4802            tmpccer = TIMx->CCER;
   4803            /* Get the TIMx CR2 register value */
   4804            tmpcr2 = TIMx->CR2;
   4805            
   4806            /* Get the TIMx CCMR1 register value */
   4807            tmpccmrx = TIMx->CCMR1;
   4808              
   4809            /* Reset the Output Compare Mode Bits */
   4810            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4811            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4812            /* Select the Output Compare Mode */
   4813            tmpccmrx |= OC_Config->OCMode;
   4814            
   4815            /* Reset the Output Polarity level */
   4816            tmpccer &= ~TIM_CCER_CC1P;
   4817            /* Set the Output Compare Polarity */
   4818            tmpccer |= OC_Config->OCPolarity;
   4819          
   4820              
   4821            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   4822            {   
   4823              /* Reset the Output N Polarity level */
   4824              tmpccer &= ~TIM_CCER_CC1NP;
   4825              /* Set the Output N Polarity */
   4826              tmpccer |= OC_Config->OCNPolarity;
   4827              /* Reset the Output N State */
   4828              tmpccer &= ~TIM_CCER_CC1NE;
   4829              
   4830              /* Reset the Output Compare and Output Compare N IDLE State */
   4831              tmpcr2 &= ~TIM_CR2_OIS1;
   4832              tmpcr2 &= ~TIM_CR2_OIS1N;
   4833              /* Set the Output Idle state */
   4834              tmpcr2 |= OC_Config->OCIdleState;
   4835              /* Set the Output N Idle state */
   4836              tmpcr2 |= OC_Config->OCNIdleState;
   4837            }
   4838            /* Write to TIMx CR2 */
   4839            TIMx->CR2 = tmpcr2;
   4840            
   4841            /* Write to TIMx CCMR1 */
   4842            TIMx->CCMR1 = tmpccmrx;
   4843            
   4844            /* Set the Capture Compare Register value */
   4845            TIMx->CCR1 = OC_Config->Pulse;
   4846            
   4847            /* Write to TIMx CCER */
   4848            TIMx->CCER = tmpccer;  
   4849          } 
   4850          
   4851          /**
   4852            * @brief  Time Output Compare 3 configuration
   4853            * @param  TIMx to select the TIM peripheral
   4854            * @param  OC_Config The output configuration structure
   4855            * @retval None
   4856            */
   4857          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4858          {
   4859            uint32_t tmpccmrx = 0U;
   4860            uint32_t tmpccer = 0U;
   4861            uint32_t tmpcr2 = 0U;   
   4862          
   4863            /* Disable the Channel 3: Reset the CC2E Bit */
   4864            TIMx->CCER &= ~TIM_CCER_CC3E;
   4865            
   4866            /* Get the TIMx CCER register value */
   4867            tmpccer = TIMx->CCER;
   4868            /* Get the TIMx CR2 register value */
   4869            tmpcr2 = TIMx->CR2;
   4870            
   4871            /* Get the TIMx CCMR2 register value */
   4872            tmpccmrx = TIMx->CCMR2;
   4873              
   4874            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4875            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4876            tmpccmrx &= ~TIM_CCMR2_CC3S;  
   4877            /* Select the Output Compare Mode */
   4878            tmpccmrx |= OC_Config->OCMode;
   4879            
   4880            /* Reset the Output Polarity level */
   4881            tmpccer &= ~TIM_CCER_CC3P;
   4882            /* Set the Output Compare Polarity */
   4883            tmpccer |= (OC_Config->OCPolarity << 8U);
   4884              
   4885            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   4886            {
   4887              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4888              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4889              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4890              
   4891              /* Reset the Output N Polarity level */
   4892              tmpccer &= ~TIM_CCER_CC3NP;
   4893              /* Set the Output N Polarity */
   4894              tmpccer |= (OC_Config->OCNPolarity << 8U);
   4895              /* Reset the Output N State */
   4896              tmpccer &= ~TIM_CCER_CC3NE;
   4897              
   4898              /* Reset the Output Compare and Output Compare N IDLE State */
   4899              tmpcr2 &= ~TIM_CR2_OIS3;
   4900              tmpcr2 &= ~TIM_CR2_OIS3N;
   4901              /* Set the Output Idle state */
   4902              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   4903              /* Set the Output N Idle state */
   4904              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   4905            }
   4906            /* Write to TIMx CR2 */
   4907            TIMx->CR2 = tmpcr2;
   4908            
   4909            /* Write to TIMx CCMR2 */
   4910            TIMx->CCMR2 = tmpccmrx;
   4911            
   4912            /* Set the Capture Compare Register value */
   4913            TIMx->CCR3 = OC_Config->Pulse;
   4914            
   4915            /* Write to TIMx CCER */
   4916            TIMx->CCER = tmpccer;
   4917          }
   4918          
   4919          /**
   4920            * @brief  Time Output Compare 4 configuration
   4921            * @param  TIMx to select the TIM peripheral
   4922            * @param  OC_Config The output configuration structure
   4923            * @retval None
   4924            */
   4925          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4926          {
   4927            uint32_t tmpccmrx = 0U;
   4928            uint32_t tmpccer = 0U;
   4929            uint32_t tmpcr2 = 0U;
   4930          
   4931            /* Disable the Channel 4: Reset the CC4E Bit */
   4932            TIMx->CCER &= ~TIM_CCER_CC4E;
   4933            
   4934            /* Get the TIMx CCER register value */
   4935            tmpccer = TIMx->CCER;
   4936            /* Get the TIMx CR2 register value */
   4937            tmpcr2 = TIMx->CR2;
   4938            
   4939            /* Get the TIMx CCMR2 register value */
   4940            tmpccmrx = TIMx->CCMR2;
   4941              
   4942            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4943            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4944            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4945            
   4946            /* Select the Output Compare Mode */
   4947            tmpccmrx |= (OC_Config->OCMode << 8U);
   4948            
   4949            /* Reset the Output Polarity level */
   4950            tmpccer &= ~TIM_CCER_CC4P;
   4951            /* Set the Output Compare Polarity */
   4952            tmpccer |= (OC_Config->OCPolarity << 12U);
   4953             
   4954            /*if((TIMx == TIM1) || (TIMx == TIM8))*/
   4955            if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)
   4956            {
   4957              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4958              /* Reset the Output Compare IDLE State */
   4959              tmpcr2 &= ~TIM_CR2_OIS4;
   4960              /* Set the Output Idle state */
   4961              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   4962            }
   4963            /* Write to TIMx CR2 */
   4964            TIMx->CR2 = tmpcr2;
   4965            
   4966            /* Write to TIMx CCMR2 */  
   4967            TIMx->CCMR2 = tmpccmrx;
   4968              
   4969            /* Set the Capture Compare Register value */
   4970            TIMx->CCR4 = OC_Config->Pulse;
   4971            
   4972            /* Write to TIMx CCER */
   4973            TIMx->CCER = tmpccer;
   4974          }
   4975          
   4976          /**
   4977            * @brief  Time Output Compare 4 configuration
   4978            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   4979            *                the configuration information for TIM module.
   4980            * @param  sSlaveConfig The slave configuration structure
   4981            * @retval None
   4982            */
   4983          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4984                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4985          {
   4986            uint32_t tmpsmcr = 0U;
   4987            uint32_t tmpccmr1 = 0U;
   4988            uint32_t tmpccer = 0U;
   4989          
   4990           /* Get the TIMx SMCR register value */
   4991            tmpsmcr = htim->Instance->SMCR;
   4992          
   4993            /* Reset the Trigger Selection Bits */
   4994            tmpsmcr &= ~TIM_SMCR_TS;
   4995            /* Set the Input Trigger source */
   4996            tmpsmcr |= sSlaveConfig->InputTrigger;
   4997          
   4998            /* Reset the slave mode Bits */
   4999            tmpsmcr &= ~TIM_SMCR_SMS;
   5000            /* Set the slave mode */
   5001            tmpsmcr |= sSlaveConfig->SlaveMode;
   5002          
   5003            /* Write to TIMx SMCR */
   5004            htim->Instance->SMCR = tmpsmcr;
   5005            
   5006            /* Configure the trigger prescaler, filter, and polarity */
   5007            switch (sSlaveConfig->InputTrigger)
   5008            {
   5009            case TIM_TS_ETRF:
   5010              {
   5011                /* Check the parameters */
   5012                assert_param(IS_TIM_ETR_INSTANCE(htim->Instance));
   5013                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   5014                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5015                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5016                /* Configure the ETR Trigger source */
   5017                TIM_ETR_SetConfig(htim->Instance, 
   5018                                  sSlaveConfig->TriggerPrescaler, 
   5019                                  sSlaveConfig->TriggerPolarity, 
   5020                                  sSlaveConfig->TriggerFilter);
   5021              }
   5022              break;
   5023              
   5024            case TIM_TS_TI1F_ED:
   5025              {
   5026                /* Check the parameters */
   5027                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5028                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5029                
   5030                /* Disable the Channel 1: Reset the CC1E Bit */
   5031                tmpccer = htim->Instance->CCER;
   5032                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   5033                tmpccmr1 = htim->Instance->CCMR1;    
   5034                
   5035                /* Set the filter */
   5036                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5037                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   5038                
   5039                /* Write to TIMx CCMR1 and CCER registers */
   5040                htim->Instance->CCMR1 = tmpccmr1;
   5041                htim->Instance->CCER = tmpccer;                               
   5042                                         
   5043              }
   5044              break;
   5045              
   5046            case TIM_TS_TI1FP1:
   5047              {
   5048                /* Check the parameters */
   5049                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   5050                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5051                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5052          
   5053                /* Configure TI1 Filter and Polarity */
   5054                TIM_TI1_ConfigInputStage(htim->Instance,
   5055                                         sSlaveConfig->TriggerPolarity,
   5056                                         sSlaveConfig->TriggerFilter);
   5057              }
   5058              break;
   5059              
   5060            case TIM_TS_TI2FP2:
   5061              {
   5062                /* Check the parameters */
   5063                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5064                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5065                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5066                
   5067                /* Configure TI2 Filter and Polarity */
   5068                TIM_TI2_ConfigInputStage(htim->Instance,
   5069                                          sSlaveConfig->TriggerPolarity,
   5070                                          sSlaveConfig->TriggerFilter);
   5071              }
   5072              break;
   5073              
   5074            case TIM_TS_ITR0:
   5075              {
   5076                /* Check the parameter */
   5077                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5078              }
   5079              break;
   5080              
   5081            case TIM_TS_ITR1:
   5082              {
   5083                /* Check the parameter */
   5084                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5085              }
   5086              break;
   5087              
   5088            case TIM_TS_ITR2:
   5089              {
   5090                /* Check the parameter */
   5091                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5092              }
   5093              break;
   5094              
   5095            case TIM_TS_ITR3:
   5096              {
   5097                /* Check the parameter */
   5098                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5099              }
   5100              break;
   5101                 
   5102            default:
   5103              break;
   5104            }
   5105          }
   5106          
   5107          
   5108          /**
   5109            * @brief  Configure the Polarity and Filter for TI1.
   5110            * @param  TIMx to select the TIM peripheral.
   5111            * @param  TIM_ICPolarity  The Input Polarity.
   5112            *          This parameter can be one of the following values:
   5113            *            @arg TIM_ICPolarity_Rising
   5114            *            @arg TIM_ICPolarity_Falling
   5115            *            @arg TIM_ICPolarity_BothEdge
   5116            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   5117            *          This parameter must be a value between 0x00 and 0x0F.
   5118            * @retval None
   5119            */
   5120          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5121          {
   5122            uint32_t tmpccmr1 = 0U;
   5123            uint32_t tmpccer = 0U;
   5124            
   5125            /* Disable the Channel 1: Reset the CC1E Bit */
   5126            tmpccer = TIMx->CCER;
   5127            TIMx->CCER &= ~TIM_CCER_CC1E;
   5128            tmpccmr1 = TIMx->CCMR1;    
   5129            
   5130            /* Set the filter */
   5131            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5132            tmpccmr1 |= (TIM_ICFilter << 4U);
   5133            
   5134            /* Select the Polarity and set the CC1E Bit */
   5135            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5136            tmpccer |= TIM_ICPolarity;
   5137            
   5138            /* Write to TIMx CCMR1 and CCER registers */
   5139            TIMx->CCMR1 = tmpccmr1;
   5140            TIMx->CCER = tmpccer;
   5141          }
   5142          
   5143          /**
   5144            * @brief  Configure the TI2 as Input.
   5145            * @param  TIMx to select the TIM peripheral
   5146            * @param  TIM_ICPolarity  The Input Polarity.
   5147            *          This parameter can be one of the following values:
   5148            *            @arg TIM_ICPolarity_Rising
   5149            *            @arg TIM_ICPolarity_Falling
   5150            *            @arg TIM_ICPolarity_BothEdge   
   5151            * @param  TIM_ICSelection specifies the input to be used.
   5152            *          This parameter can be one of the following values:
   5153            *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
   5154            *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
   5155            *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
   5156            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   5157            *          This parameter must be a value between 0x00 and 0x0F.
   5158            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5159            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5160            *        protected against un-initialized filter and polarity values.
   5161            * @retval None
   5162            */
   5163          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5164                                 uint32_t TIM_ICFilter)
   5165          {
   5166            uint32_t tmpccmr1 = 0U;
   5167            uint32_t tmpccer = 0U;
   5168          
   5169            /* Disable the Channel 2: Reset the CC2E Bit */
   5170            TIMx->CCER &= ~TIM_CCER_CC2E;
   5171            tmpccmr1 = TIMx->CCMR1;
   5172            tmpccer = TIMx->CCER;
   5173            
   5174            /* Select the Input */
   5175            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   5176            tmpccmr1 |= (TIM_ICSelection << 8U);
   5177            
   5178            /* Set the filter */
   5179            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5180            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   5181          
   5182            /* Select the Polarity and set the CC2E Bit */
   5183            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5184            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   5185          
   5186            /* Write to TIMx CCMR1 and CCER registers */
   5187            TIMx->CCMR1 = tmpccmr1 ;
   5188            TIMx->CCER = tmpccer;
   5189          }
   5190          
   5191          /**
   5192            * @brief  Configure the Polarity and Filter for TI2.
   5193            * @param  TIMx to select the TIM peripheral.
   5194            * @param  TIM_ICPolarity  The Input Polarity.
   5195            *          This parameter can be one of the following values:
   5196            *            @arg TIM_ICPolarity_Rising
   5197            *            @arg TIM_ICPolarity_Falling
   5198            *            @arg TIM_ICPolarity_BothEdge
   5199            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   5200            *          This parameter must be a value between 0x00 and 0x0F.
   5201            * @retval None
   5202            */
   5203          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5204          {
   5205            uint32_t tmpccmr1 = 0U;
   5206            uint32_t tmpccer = 0U;
   5207            
   5208            /* Disable the Channel 2: Reset the CC2E Bit */
   5209            TIMx->CCER &= ~TIM_CCER_CC2E;
   5210            tmpccmr1 = TIMx->CCMR1;
   5211            tmpccer = TIMx->CCER;
   5212            
   5213            /* Set the filter */
   5214            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5215            tmpccmr1 |= (TIM_ICFilter << 12U);
   5216          
   5217            /* Select the Polarity and set the CC2E Bit */
   5218            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5219            tmpccer |= (TIM_ICPolarity << 4U);
   5220          
   5221            /* Write to TIMx CCMR1 and CCER registers */
   5222            TIMx->CCMR1 = tmpccmr1 ;
   5223            TIMx->CCER = tmpccer;
   5224          }
   5225          
   5226          /**
   5227            * @brief  Configure the TI3 as Input.
   5228            * @param  TIMx to select the TIM peripheral
   5229            * @param  TIM_ICPolarity  The Input Polarity.
   5230            *          This parameter can be one of the following values:
   5231            *            @arg TIM_ICPolarity_Rising
   5232            *            @arg TIM_ICPolarity_Falling
   5233            *            @arg TIM_ICPolarity_BothEdge         
   5234            * @param  TIM_ICSelection specifies the input to be used.
   5235            *          This parameter can be one of the following values:
   5236            *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
   5237            *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
   5238            *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
   5239            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   5240            *          This parameter must be a value between 0x00 and 0x0F.
   5241            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5242            *       (on channel4 path) is used as the input signal. Therefore CCMR2 must be 
   5243            *        protected against un-initialized filter and polarity values.
   5244            * @retval None
   5245            */
   5246          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5247                                 uint32_t TIM_ICFilter)
   5248          {
   5249            uint32_t tmpccmr2 = 0U;
   5250            uint32_t tmpccer = 0U;
   5251          
   5252            /* Disable the Channel 3: Reset the CC3E Bit */
   5253            TIMx->CCER &= ~TIM_CCER_CC3E;
   5254            tmpccmr2 = TIMx->CCMR2;
   5255            tmpccer = TIMx->CCER;
   5256          
   5257            /* Select the Input */
   5258            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   5259            tmpccmr2 |= TIM_ICSelection;
   5260          
   5261            /* Set the filter */
   5262            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   5263            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   5264          
   5265            /* Select the Polarity and set the CC3E Bit */
   5266            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   5267            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   5268          
   5269            /* Write to TIMx CCMR2 and CCER registers */
   5270            TIMx->CCMR2 = tmpccmr2;
   5271            TIMx->CCER = tmpccer;
   5272          }
   5273          
   5274          /**
   5275            * @brief  Configure the TI4 as Input.
   5276            * @param  TIMx to select the TIM peripheral
   5277            * @param  TIM_ICPolarity  The Input Polarity.
   5278            *          This parameter can be one of the following values:
   5279            *            @arg TIM_ICPolarity_Rising
   5280            *            @arg TIM_ICPolarity_Falling
   5281            *            @arg TIM_ICPolarity_BothEdge     
   5282            * @param  TIM_ICSelection specifies the input to be used.
   5283            *          This parameter can be one of the following values:
   5284            *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
   5285            *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
   5286            *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
   5287            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   5288            *          This parameter must be a value between 0x00 and 0x0F.
   5289            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5290            *       (on channel3 path) is used as the input signal. Therefore CCMR2 must be 
   5291            *        protected against un-initialized filter and polarity values.
   5292            * @retval None
   5293            */
   5294          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5295                                 uint32_t TIM_ICFilter)
   5296          {
   5297            uint32_t tmpccmr2 = 0U;
   5298            uint32_t tmpccer = 0U;
   5299          
   5300            /* Disable the Channel 4: Reset the CC4E Bit */
   5301            TIMx->CCER &= ~TIM_CCER_CC4E;
   5302            tmpccmr2 = TIMx->CCMR2;
   5303            tmpccer = TIMx->CCER;
   5304          
   5305            /* Select the Input */
   5306            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   5307            tmpccmr2 |= (TIM_ICSelection << 8U);
   5308          
   5309            /* Set the filter */
   5310            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   5311            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   5312          
   5313            /* Select the Polarity and set the CC4E Bit */
   5314            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   5315            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   5316          
   5317            /* Write to TIMx CCMR2 and CCER registers */
   5318            TIMx->CCMR2 = tmpccmr2;
   5319            TIMx->CCER = tmpccer ;
   5320          }
   5321          
   5322          /**
   5323            * @brief  Selects the Input Trigger source
   5324            * @param  TIMx to select the TIM peripheral
   5325            * @param  TIM_ITRx The Input Trigger source.
   5326            *          This parameter can be one of the following values:
   5327            *            @arg TIM_TS_ITR0: Internal Trigger 0
   5328            *            @arg TIM_TS_ITR1: Internal Trigger 1
   5329            *            @arg TIM_TS_ITR2: Internal Trigger 2
   5330            *            @arg TIM_TS_ITR3: Internal Trigger 3
   5331            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   5332            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   5333            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   5334            *            @arg TIM_TS_ETRF: External Trigger input
   5335            * @retval None
   5336            */
   5337          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t TIM_ITRx)
   5338          {
   5339            uint32_t tmpsmcr = 0U;
   5340            
   5341             /* Get the TIMx SMCR register value */
   5342             tmpsmcr = TIMx->SMCR;
   5343             /* Reset the TS Bits */
   5344             tmpsmcr &= ~TIM_SMCR_TS;
   5345             /* Set the Input Trigger source and the slave mode*/
   5346             tmpsmcr |= TIM_ITRx | TIM_SLAVEMODE_EXTERNAL1;
   5347             /* Write to TIMx SMCR */
   5348             TIMx->SMCR = tmpsmcr;
   5349          }
   5350          
   5351          /**
   5352            * @brief  Configures the TIMx External Trigger (ETR).
   5353            * @param  TIMx to select the TIM peripheral
   5354            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   5355            *          This parameter can be one of the following values:
   5356            *            @arg TIM_ETRPRESCALER_DIV1 : ETRP Prescaler OFF.
   5357            *            @arg TIM_ETRPRESCALER_DIV2 : ETRP frequency divided by 2.
   5358            *            @arg TIM_ETRPRESCALER_DIV4 : ETRP frequency divided by 4.
   5359            *            @arg TIM_ETRPRESCALER_DIV8 : ETRP frequency divided by 8.
   5360            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   5361            *          This parameter can be one of the following values:
   5362            *            @arg TIM_ETRPOLARITY_INVERTED : active low or falling edge active.
   5363            *            @arg TIM_ETRPOLARITY_NONINVERTED : active high or rising edge active.
   5364            * @param  ExtTRGFilter External Trigger Filter.
   5365            *          This parameter must be a value between 0x00 and 0x0F
   5366            * @retval None
   5367            */
   5368          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5369                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5370          {
   5371            uint32_t tmpsmcr = 0U;
   5372          
   5373            tmpsmcr = TIMx->SMCR;
   5374          
   5375            /* Reset the ETR Bits */
   5376            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5377          
   5378            /* Set the Prescaler, the Filter value and the Polarity */
   5379            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
   5380          
   5381            /* Write to TIMx SMCR */
   5382            TIMx->SMCR = tmpsmcr;
   5383          } 
   5384          
   5385          /**
   5386            * @}
   5387            */
   5388          
   5389          #endif /* HAL_TIM_MODULE_ENABLED */
   5390          /**
   5391            * @}
   5392            */ 
   5393          
   5394          /**
   5395            * @}
   5396            */ 
   5397          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/


 

 


Errors: none
Warnings: none
