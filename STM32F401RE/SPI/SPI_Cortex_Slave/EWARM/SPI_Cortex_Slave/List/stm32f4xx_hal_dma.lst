###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
#    Command line =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
#        -D USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\stm32f4xx_hal_dma.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\stm32f4xx_hal_dma.o
#
###############################################################################

C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @brief   DMA HAL module driver.
      6            *    
      7            *          This file provides firmware functions to manage the following 
      8            *          functionalities of the Direct Memory Access (DMA) peripheral:
      9            *           + Initialization and de-initialization functions
     10            *           + IO operation functions
     11            *           + Peripheral State and errors functions
     12            @verbatim     
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16            [..]
     17             (#) Enable and configure the peripheral to be connected to the DMA Stream
     18                 (except for internal SRAM/FLASH memories: no initialization is 
     19                 necessary) please refer to Reference manual for connection between peripherals
     20                 and DMA requests.
     21          
     22             (#) For a given Stream, program the required configuration through the following parameters:
     23                 Transfer Direction, Source and Destination data formats, 
     24                 Circular, Normal or peripheral flow control mode, Stream Priority level, 
     25                 Source and Destination Increment mode, FIFO mode and its Threshold (if needed), 
     26                 Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.
     27          
     28             -@-   Prior to HAL_DMA_Init() the clock must be enabled for DMA through the following macros:
     29                   __HAL_RCC_DMA1_CLK_ENABLE() or __HAL_RCC_DMA2_CLK_ENABLE().
     30          
     31               *** Polling mode IO operation ***
     32               =================================
     33              [..]
     34                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
     35                        address and destination address and the Length of data to be transferred.
     36                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
     37                        case a fixed Timeout can be configured by User depending from his application.
     38                    (+) Use HAL_DMA_Abort() function to abort the current transfer.
     39          
     40               *** Interrupt mode IO operation ***
     41               ===================================
     42              [..]
     43                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     44                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() 
     45                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
     46                        Source address and destination address and the Length of data to be transferred. In this 
     47                        case the DMA interrupt is configured 
     48                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     49                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
     50                        add his own function by customization of function pointer XferCpltCallback and 
     51                        XferErrorCallback (i.e a member of DMA handle structure).
     52              [..]
     53               (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
     54                   detection.
     55          
     56               (#) Use HAL_DMA_Abort_IT() function to abort the current transfer
     57          
     58               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.
     59          
     60               -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
     61                     possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
     62                     Half-Word data size for the peripheral to access its data register and set Word data size
     63                     for the Memory to gain in access time. Each two half words will be packed and written in
     64                     a single access to a Word in the Memory).
     65          
     66               -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
     67                     and Destination. In this case the Peripheral Data Size will be applied to both Source
     68                     and Destination.
     69          
     70               *** DMA HAL driver macros list ***
     71               =============================================
     72               [..]
     73                 Below the list of most used macros in DMA HAL driver.
     74                 
     75                (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.
     76                (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.
     77                (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. 
     78          
     79               [..]
     80                (@) You can refer to the DMA HAL driver header file for more useful macros
     81          
     82            @endverbatim
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
     87            *
     88            * Redistribution and use in source and binary forms, with or without modification,
     89            * are permitted provided that the following conditions are met:
     90            *   1. Redistributions of source code must retain the above copyright notice,
     91            *      this list of conditions and the following disclaimer.
     92            *   2. Redistributions in binary form must reproduce the above copyright notice,
     93            *      this list of conditions and the following disclaimer in the documentation
     94            *      and/or other materials provided with the distribution.
     95            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     96            *      may be used to endorse or promote products derived from this software
     97            *      without specific prior written permission.
     98            *
     99            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    100            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    101            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    102            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    103            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    104            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    105            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    106            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    107            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    108            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    109            *
    110            ******************************************************************************
    111            */ 
    112          
    113          /* Includes ------------------------------------------------------------------*/
    114          #include "stm32f4xx_hal.h"
    115          
    116          /** @addtogroup STM32F4xx_HAL_Driver
    117            * @{
    118            */
    119          
    120          /** @defgroup DMA DMA
    121            * @brief DMA HAL module driver
    122            * @{
    123            */
    124          
    125          #ifdef HAL_DMA_MODULE_ENABLED
    126          
    127          /* Private types -------------------------------------------------------------*/
    128          typedef struct
    129          {
    130            __IO uint32_t ISR;   /*!< DMA interrupt status register */
    131            __IO uint32_t Reserved0;
    132            __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */
    133          } DMA_Base_Registers;
    134          
    135          /* Private variables ---------------------------------------------------------*/
    136          /* Private constants ---------------------------------------------------------*/
    137          /** @addtogroup DMA_Private_Constants
    138           * @{
    139           */
    140           #define HAL_TIMEOUT_DMA_ABORT    5U  /* 5 ms */
    141          /**
    142            * @}
    143            */
    144          /* Private macros ------------------------------------------------------------*/
    145          /* Private functions ---------------------------------------------------------*/
    146          /** @addtogroup DMA_Private_Functions
    147            * @{
    148            */
    149          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    150          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);
    151          static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma);
    152          
    153          /**
    154            * @}
    155            */  
    156          
    157          /* Exported functions ---------------------------------------------------------*/
    158          /** @addtogroup DMA_Exported_Functions
    159            * @{
    160            */
    161          
    162          /** @addtogroup DMA_Exported_Functions_Group1
    163            *
    164          @verbatim
    165           ===============================================================================
    166                       ##### Initialization and de-initialization functions  #####
    167           ===============================================================================
    168              [..]
    169              This section provides functions allowing to initialize the DMA Stream source
    170              and destination addresses, incrementation and data sizes, transfer direction, 
    171              circular/normal mode selection, memory-to-memory mode selection and Stream priority value.
    172              [..]
    173              The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    174              reference manual.
    175          
    176          @endverbatim
    177            * @{
    178            */
    179            
    180          /**
    181            * @brief  Initialize the DMA according to the specified
    182            *         parameters in the DMA_InitTypeDef and create the associated handle.
    183            * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
    184            *               the configuration information for the specified DMA Stream.  
    185            * @retval HAL status
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    188          {
   \                     HAL_DMA_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    189            uint32_t tmp = 0U;
    190            uint32_t tickstart = HAL_GetTick();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x4605             MOV      R5,R0
    191            DMA_Base_Registers *regs;
    192          
    193            /* Check the DMA peripheral state */
    194            if(hdma == NULL)
   \   0000000A   0xB90C             CBNZ.N   R4,??HAL_DMA_Init_0
    195            {
    196              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    197            }
    198          
    199            /* Check the parameters */
    200            assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
    201            assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
    202            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    203            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    204            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    205            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    206            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    207            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    208            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    209            assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    210            /* Check the memory burst, peripheral burst and FIFO threshold parameters only
    211               when FIFO mode is enabled */
    212            if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
    213            {
    214              assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    215              assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    216              assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    217            }
    218            
    219            /* Allocate lock resource */
    220            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Init_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF884 0x0034      STRB     R0,[R4, #+52]
    221          
    222            /* Change DMA peripheral state */
    223            hdma->State = HAL_DMA_STATE_BUSY;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF884 0x0035      STRB     R0,[R4, #+53]
    224            
    225            /* Disable the peripheral */
    226            __HAL_DMA_DISABLE(hdma);
   \   0000001C   0x6820             LDR      R0,[R4, #+0]
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0x0849             LSRS     R1,R1,#+1
   \   00000022   0x0049             LSLS     R1,R1,#+1
   \   00000024   0x6001             STR      R1,[R0, #+0]
    227            
    228            /* Check if the DMA Stream is effectively disabled */
    229            while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
   \                     ??HAL_DMA_Init_1: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0x07C9             LSLS     R1,R1,#+31
   \   0000002C   0xD508             BPL.N    ??HAL_DMA_Init_2
    230            {
    231              /* Check for the Timeout */
    232              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \   0000002E   0x.... 0x....      BL       HAL_GetTick
   \   00000032   0x1B40             SUBS     R0,R0,R5
   \   00000034   0x2806             CMP      R0,#+6
   \   00000036   0xD3F6             BCC.N    ??HAL_DMA_Init_1
    233              {
    234                /* Update error code */
    235                hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \   00000038   0x2020             MOVS     R0,#+32
   \   0000003A   0x6560             STR      R0,[R4, #+84]
    236                
    237                /* Change the DMA state */
    238                hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0xE054             B.N      ??HAL_DMA_Init_3
    239                
    240                return HAL_TIMEOUT;
    241              }
    242            }
    243            
    244            /* Get the CR register value */
    245            tmp = hdma->Instance->CR;
   \                     ??HAL_DMA_Init_2: (+1)
   \   00000040   0x6801             LDR      R1,[R0, #+0]
    246          
    247            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    248            tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    249                                DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
    250                                DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
    251                                DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
    252          
    253            /* Prepare the DMA Stream configuration */
    254            tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
    255                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    256                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    257                    hdma->Init.Mode                | hdma->Init.Priority;
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable2  ;; 0xf010803f
   \   00000046   0x4011             ANDS     R1,R2,R1
   \   00000048   0x6862             LDR      R2,[R4, #+4]
   \   0000004A   0x4311             ORRS     R1,R2,R1
   \   0000004C   0x68A2             LDR      R2,[R4, #+8]
   \   0000004E   0x4311             ORRS     R1,R2,R1
   \   00000050   0x68E2             LDR      R2,[R4, #+12]
   \   00000052   0x4311             ORRS     R1,R2,R1
   \   00000054   0x6922             LDR      R2,[R4, #+16]
   \   00000056   0x4311             ORRS     R1,R2,R1
   \   00000058   0x6962             LDR      R2,[R4, #+20]
   \   0000005A   0x4311             ORRS     R1,R2,R1
   \   0000005C   0x69A2             LDR      R2,[R4, #+24]
   \   0000005E   0x4311             ORRS     R1,R2,R1
   \   00000060   0x69E2             LDR      R2,[R4, #+28]
   \   00000062   0x4311             ORRS     R1,R2,R1
   \   00000064   0x6A22             LDR      R2,[R4, #+32]
   \   00000066   0x4311             ORRS     R1,R2,R1
    258          
    259            /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    260            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \   00000068   0x6A62             LDR      R2,[R4, #+36]
   \   0000006A   0x2A04             CMP      R2,#+4
   \   0000006C   0xD103             BNE.N    ??HAL_DMA_Init_4
    261            {
    262              /* Get memory burst and peripheral burst */
    263              tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
   \   0000006E   0x6AE2             LDR      R2,[R4, #+44]
   \   00000070   0x6B23             LDR      R3,[R4, #+48]
   \   00000072   0x431A             ORRS     R2,R3,R2
   \   00000074   0x4311             ORRS     R1,R2,R1
    264            }
    265            
    266            /* Write to DMA Stream CR register */
    267            hdma->Instance->CR = tmp;  
   \                     ??HAL_DMA_Init_4: (+1)
   \   00000076   0x6001             STR      R1,[R0, #+0]
    268          
    269            /* Get the FCR register value */
    270            tmp = hdma->Instance->FCR;
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x6941             LDR      R1,[R0, #+20]
    271          
    272            /* Clear Direct mode and FIFO threshold bits */
    273            tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    274          
    275            /* Prepare the DMA Stream FIFO configuration */
    276            tmp |= hdma->Init.FIFOMode;
   \   0000007C   0x6A62             LDR      R2,[R4, #+36]
   \   0000007E   0x08C9             LSRS     R1,R1,#+3
   \   00000080   0xEA42 0x01C1      ORR      R1,R2,R1, LSL #+3
    277          
    278            /* The FIFO threshold is not used when the FIFO mode is disabled */
    279            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \   00000084   0x2A04             CMP      R2,#+4
   \   00000086   0xD10A             BNE.N    ??HAL_DMA_Init_5
    280            {
    281              /* Get the FIFO threshold */
    282              tmp |= hdma->Init.FIFOThreshold;
   \   00000088   0x6AA2             LDR      R2,[R4, #+40]
    283              
    284              /* Check compatibility between FIFO threshold level and size of the memory burst */
    285              /* for INCR4, INCR8, INCR16 bursts */
    286              if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
   \   0000008A   0x6AE3             LDR      R3,[R4, #+44]
   \   0000008C   0x4311             ORRS     R1,R2,R1
   \   0000008E   0xB133             CBZ.N    R3,??HAL_DMA_Init_5
    287              {
    288                if (DMA_CheckFifoParam(hdma) != HAL_OK)
   \   00000090   0x69A5             LDR      R5,[R4, #+24]
   \   00000092   0xB99D             CBNZ.N   R5,??HAL_DMA_Init_6
   \   00000094   0x2A00             CMP      R2,#+0
   \   00000096   0xBF18             IT       NE 
   \   00000098   0x2A02             CMPNE    R2,#+2
   \   0000009A   0xD021             BEQ.N    ??HAL_DMA_Init_7
   \   0000009C   0xD318             BCC.N    ??HAL_DMA_Init_8
    289                {
    290                  /* Update error code */
    291                  hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
    292                  
    293                  /* Change the DMA state */
    294                  hdma->State = HAL_DMA_STATE_READY;
    295                  
    296                  return HAL_ERROR; 
    297                }
    298              }
    299            }
    300            
    301            /* Write to DMA Stream FCR */
    302            hdma->Instance->FCR = tmp;
   \                     ??HAL_DMA_Init_5: (+1)
   \   0000009E   0x6141             STR      R1,[R0, #+20]
    303          
    304            /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    305               DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    306            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       DMA_CalcBaseAndBitshift
    307            
    308            /* Clear all interrupt flags */
    309            regs->IFCR = 0x3FU << hdma->StreamIndex;
   \   000000A6   0x6DE2             LDR      R2,[R4, #+92]
   \   000000A8   0x213F             MOVS     R1,#+63
   \   000000AA   0x4091             LSLS     R1,R1,R2
   \   000000AC   0x6081             STR      R1,[R0, #+8]
    310          
    311            /* Initialize the error code */
    312            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x6560             STR      R0,[R4, #+84]
    313                                                                                               
    314            /* Initialize the DMA state */
    315            hdma->State = HAL_DMA_STATE_READY;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xF884 0x0035      STRB     R0,[R4, #+53]
    316          
    317            return HAL_OK;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??HAL_DMA_Init_6: (+1)
   \   000000BC   0xF5B5 0x5F00      CMP      R5,#+8192
   \   000000C0   0xD10A             BNE.N    ??HAL_DMA_Init_9
   \   000000C2   0x2A00             CMP      R2,#+0
   \   000000C4   0xBF18             IT       NE 
   \   000000C6   0x2A02             CMPNE    R2,#+2
   \   000000C8   0xD00C             BEQ.N    ??HAL_DMA_Init_10
   \   000000CA   0xD309             BCC.N    ??HAL_DMA_Init_7
   \   000000CC   0x2A03             CMP      R2,#+3
   \   000000CE   0xD1E6             BNE.N    ??HAL_DMA_Init_5
   \                     ??HAL_DMA_Init_8: (+1)
   \   000000D0   0xF1B3 0x7FC0      CMP      R3,#+25165824
   \   000000D4   0xD1E3             BNE.N    ??HAL_DMA_Init_5
   \   000000D6   0xE005             B.N      ??HAL_DMA_Init_10
   \                     ??HAL_DMA_Init_9: (+1)
   \   000000D8   0x2A02             CMP      R2,#+2
   \   000000DA   0xD903             BLS.N    ??HAL_DMA_Init_10
   \   000000DC   0x1ED2             SUBS     R2,R2,#+3
   \   000000DE   0xD1DE             BNE.N    ??HAL_DMA_Init_5
   \                     ??HAL_DMA_Init_7: (+1)
   \   000000E0   0x01DA             LSLS     R2,R3,#+7
   \   000000E2   0xD5DC             BPL.N    ??HAL_DMA_Init_5
   \                     ??HAL_DMA_Init_10: (+1)
   \   000000E4   0x2040             MOVS     R0,#+64
   \   000000E6   0x6560             STR      R0,[R4, #+84]
   \   000000E8   0x2001             MOVS     R0,#+1
   \                     ??HAL_DMA_Init_3: (+1)
   \   000000EA   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000EE   0xBD32             POP      {R1,R4,R5,PC}
    318          }
    319          
    320          /**
    321            * @brief  DeInitializes the DMA peripheral 
    322            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    323            *               the configuration information for the specified DMA Stream.  
    324            * @retval HAL status
    325            */

   \                                 In section .text, align 2, keep-with-next
    326          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    327          {
   \                     HAL_DMA_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    328            DMA_Base_Registers *regs;
    329          
    330            /* Check the DMA peripheral state */
    331            if(hdma == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_DMA_DeInit_0
    332            {
    333              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    334            }
    335            
    336            /* Check the DMA peripheral state */
    337            if(hdma->State == HAL_DMA_STATE_BUSY)
   \                     ??HAL_DMA_DeInit_0: (+1)
   \   0000000A   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD01F             BEQ.N    ??HAL_DMA_DeInit_1
    338            {
    339              /* Return error status */
    340              return HAL_BUSY;
    341            }
    342          
    343            /* Check the parameters */
    344            assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
    345          
    346            /* Disable the selected DMA Streamx */
    347            __HAL_DMA_DISABLE(hdma);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x0849             LSRS     R1,R1,#+1
   \   00000018   0x0049             LSLS     R1,R1,#+1
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    348          
    349            /* Reset DMA Streamx control register */
    350            hdma->Instance->CR   = 0U;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6008             STR      R0,[R1, #+0]
    351          
    352            /* Reset DMA Streamx number of data to transfer register */
    353            hdma->Instance->NDTR = 0U;
   \   00000022   0x6821             LDR      R1,[R4, #+0]
   \   00000024   0x6048             STR      R0,[R1, #+4]
    354          
    355            /* Reset DMA Streamx peripheral address register */
    356            hdma->Instance->PAR  = 0U;
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6088             STR      R0,[R1, #+8]
    357          
    358            /* Reset DMA Streamx memory 0 address register */
    359            hdma->Instance->M0AR = 0U;
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x60C8             STR      R0,[R1, #+12]
    360            
    361            /* Reset DMA Streamx memory 1 address register */
    362            hdma->Instance->M1AR = 0U;
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6108             STR      R0,[R1, #+16]
    363            
    364            /* Reset DMA Streamx FIFO control register */
    365            hdma->Instance->FCR  = 0x00000021U;
   \   00000032   0x2021             MOVS     R0,#+33
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x6148             STR      R0,[R1, #+20]
    366            
    367            /* Get DMA steam Base Address */  
    368            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       DMA_CalcBaseAndBitshift
    369            
    370            /* Clear all interrupt flags at correct offset within the register */
    371            regs->IFCR = 0x3FU << hdma->StreamIndex;
   \   0000003E   0x6DE2             LDR      R2,[R4, #+92]
   \   00000040   0x213F             MOVS     R1,#+63
   \   00000042   0x4091             LSLS     R1,R1,R2
   \   00000044   0x6081             STR      R1,[R0, #+8]
    372          
    373            /* Initialize the error code */
    374            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6560             STR      R0,[R4, #+84]
    375          
    376            /* Initialize the DMA state */
    377            hdma->State = HAL_DMA_STATE_RESET;
   \   0000004A   0xF884 0x0035      STRB     R0,[R4, #+53]
    378          
    379            /* Release Lock */
    380            __HAL_UNLOCK(hdma);
   \   0000004E   0xF884 0x0034      STRB     R0,[R4, #+52]
    381          
    382            return HAL_OK;
   \                     ??HAL_DMA_DeInit_1: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    383          }
    384          
    385          /**
    386            * @}
    387            */
    388          
    389          /** @addtogroup DMA_Exported_Functions_Group2
    390            *
    391          @verbatim   
    392           ===============================================================================
    393                                #####  IO operation functions  #####
    394           ===============================================================================
    395              [..]  This section provides functions allowing to:
    396                (+) Configure the source, destination address and data length and Start DMA transfer
    397                (+) Configure the source, destination address and data length and 
    398                    Start DMA transfer with interrupt
    399                (+) Abort DMA transfer
    400                (+) Poll for transfer complete
    401                (+) Handle DMA interrupt request  
    402          
    403          @endverbatim
    404            * @{
    405            */
    406          
    407          /**
    408            * @brief  Starts the DMA Transfer.
    409            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
    410            *                     the configuration information for the specified DMA Stream.
    411            * @param  SrcAddress The source memory Buffer address
    412            * @param  DstAddress The destination memory Buffer address
    413            * @param  DataLength The length of data to be transferred from source to destination
    414            * @retval HAL status
    415            */

   \                                 In section .text, align 2, keep-with-next
    416          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    417          {
   \                     HAL_DMA_Start: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    418            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2400             MOVS     R4,#+0
    419            
    420            /* Check the parameters */
    421            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    422          
    423            /* Process locked */
    424            __HAL_LOCK(hdma);
   \   00000006   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_Start_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_DMA_Start_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF885 0x0034      STRB     R0,[R5, #+52]
    425          
    426            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000018   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD107             BNE.N    ??HAL_DMA_Start_1
    427            {
    428              /* Change DMA peripheral state */
    429              hdma->State = HAL_DMA_STATE_BUSY;
   \   00000020   0x.... 0x....      BL       ?Subroutine0
    430              
    431              /* Initialize the error code */
    432              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    433              
    434              /* Configure the source, destination address and the data length */
    435              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
    436          
    437              /* Enable the Peripheral */
    438              __HAL_DMA_ENABLE(hdma);
   \                     ??CrossCallReturnLabel_1: (+1)
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   \   0000002E   0xE002             B.N      ??HAL_DMA_Start_2
    439            }
    440            else
    441            {
    442              /* Process unlocked */
    443              __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Start_1: (+1)
   \   00000030   0xF885 0x4034      STRB     R4,[R5, #+52]
    444              
    445              /* Return error status */
    446              status = HAL_BUSY;
   \   00000034   0x2402             MOVS     R4,#+2
    447            } 
    448            return status; 
   \                     ??HAL_DMA_Start_2: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    449          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2002             MOVS     R0,#+2
   \   00000002   0xF885 0x0035      STRB     R0,[R5, #+53]
   \   00000006   0x656C             STR      R4,[R5, #+84]
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x....             B.N      DMA_SetConfig
    450          
    451          /**
    452            * @brief  Start the DMA Transfer with interrupt enabled.
    453            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
    454            *                     the configuration information for the specified DMA Stream.  
    455            * @param  SrcAddress The source memory Buffer address
    456            * @param  DstAddress The destination memory Buffer address
    457            * @param  DataLength The length of data to be transferred from source to destination
    458            * @retval HAL status
    459            */

   \                                 In section .text, align 2, keep-with-next
    460          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    461          {
   \                     HAL_DMA_Start_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    462            HAL_StatusTypeDef status = HAL_OK;
   \   00000004   0x2400             MOVS     R4,#+0
    463          
    464            /* calculate DMA base and stream number */
    465            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
    466            
    467            /* Check the parameters */
    468            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    469           
    470            /* Process locked */
    471            __HAL_LOCK(hdma);
   \   00000006   0xF895 0x0034      LDRB     R0,[R5, #+52]
   \   0000000A   0x6DAE             LDR      R6,[R5, #+88]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD101             BNE.N    ??HAL_DMA_Start_IT_0
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_DMA_Start_IT_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF885 0x0034      STRB     R0,[R5, #+52]
    472            
    473            if(HAL_DMA_STATE_READY == hdma->State)
   \   0000001A   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD11C             BNE.N    ??HAL_DMA_Start_IT_1
    474            {
    475              /* Change DMA peripheral state */
    476              hdma->State = HAL_DMA_STATE_BUSY;
   \   00000022   0x.... 0x....      BL       ?Subroutine0
    477              
    478              /* Initialize the error code */
    479              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
    480              
    481              /* Configure the source, destination address and the data length */
    482              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
    483              
    484              /* Clear all interrupt flags at correct offset within the register */
    485              regs->IFCR = 0x3FU << hdma->StreamIndex;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   00000026   0x6DE9             LDR      R1,[R5, #+92]
   \   00000028   0x203F             MOVS     R0,#+63
   \   0000002A   0x4088             LSLS     R0,R0,R1
   \   0000002C   0x60B0             STR      R0,[R6, #+8]
    486              
    487              /* Enable Common interrupts*/
    488              hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0xF041 0x0116      ORR      R1,R1,#0x16
   \   00000036   0x6001             STR      R1,[R0, #+0]
    489              hdma->Instance->FCR |= DMA_IT_FE;
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0x6941             LDR      R1,[R0, #+20]
   \   0000003C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000040   0x6141             STR      R1,[R0, #+20]
    490              
    491              if(hdma->XferHalfCpltCallback != NULL)
   \   00000042   0x6C28             LDR      R0,[R5, #+64]
   \   00000044   0xB120             CBZ.N    R0,??HAL_DMA_Start_IT_2
    492              {
    493                hdma->Instance->CR  |= DMA_IT_HT;
   \   00000046   0x6828             LDR      R0,[R5, #+0]
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xF041 0x0108      ORR      R1,R1,#0x8
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    494              }
    495              
    496              /* Enable the Peripheral */
    497              __HAL_DMA_ENABLE(hdma);
   \                     ??HAL_DMA_Start_IT_2: (+1)
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000058   0x6001             STR      R1,[R0, #+0]
   \   0000005A   0xE002             B.N      ??HAL_DMA_Start_IT_3
    498            }
    499            else
    500            {
    501              /* Process unlocked */
    502              __HAL_UNLOCK(hdma);	  
   \                     ??HAL_DMA_Start_IT_1: (+1)
   \   0000005C   0xF885 0x4034      STRB     R4,[R5, #+52]
    503              
    504              /* Return error status */
    505              status = HAL_BUSY;
   \   00000060   0x2402             MOVS     R4,#+2
    506            }
    507            
    508            return status;
   \                     ??HAL_DMA_Start_IT_3: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    509          }
    510          
    511          /**
    512            * @brief  Aborts the DMA Transfer.
    513            * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
    514            *                 the configuration information for the specified DMA Stream.
    515            *                   
    516            * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is 
    517            *        effectively disabled is added. If a Stream is disabled 
    518            *        while a data transfer is ongoing, the current data will be transferred
    519            *        and the Stream will be effectively disabled only after the transfer of
    520            *        this single data is finished.  
    521            * @retval HAL status
    522            */

   \                                 In section .text, align 2, keep-with-next
    523          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    524          {
   \                     HAL_DMA_Abort: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    525            /* calculate DMA base and stream number */
    526            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   00000004   0x6DA5             LDR      R5,[R4, #+88]
    527            
    528            uint32_t tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   \   0000000A   0x4606             MOV      R6,R0
    529            
    530            if(hdma->State != HAL_DMA_STATE_BUSY)
   \   0000000C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD006             BEQ.N    ??HAL_DMA_Abort_0
    531            {
    532              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   00000014   0x2080             MOVS     R0,#+128
   \   00000016   0x6560             STR      R0,[R4, #+84]
    533              
    534              /* Process Unlocked */
    535              __HAL_UNLOCK(hdma);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0034      STRB     R0,[R4, #+52]
    536              
    537              return HAL_ERROR;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD70             POP      {R4-R6,PC}
    538            }
    539            else
    540            {
    541              /* Disable all the transfer interrupts */
    542              hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
   \                     ??HAL_DMA_Abort_0: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF021 0x0116      BIC      R1,R1,#0x16
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    543              hdma->Instance->FCR &= ~(DMA_IT_FE);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6941             LDR      R1,[R0, #+20]
   \   00000030   0xF021 0x0180      BIC      R1,R1,#0x80
   \   00000034   0x6141             STR      R1,[R0, #+20]
    544              
    545              if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
   \   00000036   0x6C20             LDR      R0,[R4, #+64]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xBF04             ITT      EQ 
   \   0000003C   0x6CA0             LDREQ    R0,[R4, #+72]
   \   0000003E   0x2800             CMPEQ    R0,#+0
   \   00000040   0xD004             BEQ.N    ??HAL_DMA_Abort_1
    546              {
    547                hdma->Instance->CR  &= ~(DMA_IT_HT);
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF021 0x0108      BIC      R1,R1,#0x8
   \   0000004A   0x6001             STR      R1,[R0, #+0]
    548              }
    549              
    550              /* Disable the stream */
    551              __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_Abort_1: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0x0849             LSRS     R1,R1,#+1
   \   00000052   0x0049             LSLS     R1,R1,#+1
   \   00000054   0x6001             STR      R1,[R0, #+0]
    552              
    553              /* Check if the DMA Stream is effectively disabled */
    554              while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
   \                     ??HAL_DMA_Abort_2: (+1)
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x07C0             LSLS     R0,R0,#+31
   \   0000005C   0xD50D             BPL.N    ??HAL_DMA_Abort_3
    555              {
    556                /* Check for the Timeout */
    557                if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \   0000005E   0x.... 0x....      BL       HAL_GetTick
   \   00000062   0x1B80             SUBS     R0,R0,R6
   \   00000064   0x2806             CMP      R0,#+6
   \   00000066   0xD3F6             BCC.N    ??HAL_DMA_Abort_2
    558                {
    559                  /* Update error code */
    560                  hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \   00000068   0x2020             MOVS     R0,#+32
   \   0000006A   0x6560             STR      R0,[R4, #+84]
    561                  
    562                  /* Process Unlocked */
    563                  __HAL_UNLOCK(hdma);
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF884 0x0034      STRB     R0,[R4, #+52]
    564                  
    565                  /* Change the DMA state */
    566                  hdma->State = HAL_DMA_STATE_TIMEOUT;
   \   00000072   0x2003             MOVS     R0,#+3
   \   00000074   0xF884 0x0035      STRB     R0,[R4, #+53]
    567                  
    568                  return HAL_TIMEOUT;
   \   00000078   0xBD70             POP      {R4-R6,PC}
    569                }
    570              }
    571              
    572              /* Clear all interrupt flags at correct offset within the register */
    573              regs->IFCR = 0x3FU << hdma->StreamIndex;
   \                     ??HAL_DMA_Abort_3: (+1)
   \   0000007A   0x203F             MOVS     R0,#+63
   \   0000007C   0x6DE1             LDR      R1,[R4, #+92]
   \   0000007E   0x4088             LSLS     R0,R0,R1
   \   00000080   0x60A8             STR      R0,[R5, #+8]
    574              
    575              /* Process Unlocked */
    576              __HAL_UNLOCK(hdma);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0034      STRB     R0,[R4, #+52]
    577              
    578              /* Change the DMA state*/
    579              hdma->State = HAL_DMA_STATE_READY;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xF884 0x0035      STRB     R0,[R4, #+53]
    580            }
    581            return HAL_OK;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
    582          }
    583          
    584          /**
    585            * @brief  Aborts the DMA Transfer in Interrupt mode.
    586            * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
    587            *                 the configuration information for the specified DMA Stream.
    588            * @retval HAL status
    589            */

   \                                 In section .text, align 2, keep-with-next
    590          HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
    591          {
    592            if(hdma->State != HAL_DMA_STATE_BUSY)
   \                     HAL_DMA_Abort_IT: (+1)
   \   00000000   0xF890 0x1035      LDRB     R1,[R0, #+53]
   \   00000004   0x2902             CMP      R1,#+2
   \   00000006   0xD003             BEQ.N    ??HAL_DMA_Abort_IT_0
    593            {
    594              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x6541             STR      R1,[R0, #+84]
    595              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
    596            }
    597            else
    598            {
    599              /* Set Abort State  */
    600              hdma->State = HAL_DMA_STATE_ABORT;
   \                     ??HAL_DMA_Abort_IT_0: (+1)
   \   00000010   0x2105             MOVS     R1,#+5
   \   00000012   0xF880 0x1035      STRB     R1,[R0, #+53]
    601              
    602              /* Disable the stream */
    603              __HAL_DMA_DISABLE(hdma);
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x0849             LSRS     R1,R1,#+1
   \   0000001C   0x0049             LSLS     R1,R1,#+1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    604            }
    605          
    606            return HAL_OK;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x4770             BX       LR               ;; return
    607          }
    608          
    609          /**
    610            * @brief  Polling for transfer complete.
    611            * @param  hdma          pointer to a DMA_HandleTypeDef structure that contains
    612            *                        the configuration information for the specified DMA Stream.
    613            * @param  CompleteLevel Specifies the DMA level complete.
    614            * @note   The polling mode is kept in this version for legacy. it is recommanded to use the IT model instead.
    615            *         This model could be used for debug purpose.
    616            * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). 
    617            * @param  Timeout       Timeout duration.
    618            * @retval HAL status
    619            */

   \                                 In section .text, align 2, keep-with-next
    620          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
    621          {
   \                     HAL_DMA_PollForTransfer: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    622            HAL_StatusTypeDef status = HAL_OK; 
    623            uint32_t mask_cpltlevel;
    624            uint32_t tickstart = HAL_GetTick(); 
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x4681             MOV      R9,R0
    625            uint32_t tmpisr;
    626            
    627            /* calculate DMA base and stream number */
    628            DMA_Base_Registers *regs;
    629          
    630            if(HAL_DMA_STATE_BUSY != hdma->State)
   \   00000010   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD005             BEQ.N    ??HAL_DMA_PollForTransfer_0
    631            {
    632              /* No transfer ongoing */
    633              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0x6560             STR      R0,[R4, #+84]
    634              __HAL_UNLOCK(hdma);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF884 0x0034      STRB     R0,[R4, #+52]
    635              return HAL_ERROR;
   \   00000022   0xE006             B.N      ??HAL_DMA_PollForTransfer_1
    636            }
    637          
    638            /* Polling mode not supported in circular mode and double buffering mode */
    639            if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
   \                     ??HAL_DMA_PollForTransfer_0: (+1)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x05C0             LSLS     R0,R0,#+23
   \   0000002A   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_2
    640            {
    641              hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
   \   0000002C   0xF44F 0x7080      MOV      R0,#+256
   \   00000030   0x6560             STR      R0,[R4, #+84]
    642              return HAL_ERROR;
   \                     ??HAL_DMA_PollForTransfer_1: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE06C             B.N      ??HAL_DMA_PollForTransfer_3
    643            }
    644            
    645            /* Get the level transfer complete flag */
    646            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_2: (+1)
   \   00000036   0xF04F 0x0810      MOV      R8,#+16
   \   0000003A   0x6DE0             LDR      R0,[R4, #+92]
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xBF06             ITTE     EQ 
    647            {
    648              /* Transfer Complete flag */
    649              mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \   00000040   0x2120             MOVEQ    R1,#+32
   \   00000042   0xFA01 0xFA00      LSLEQ    R10,R1,R0
    650            }
    651            else
    652            {
    653              /* Half Transfer Complete flag */
    654              mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \   00000046   0xFA08 0xFA00      LSLNE    R10,R8,R0
    655            }
    656            
    657            regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   0000004A   0x6DA7             LDR      R7,[R4, #+88]
    658            tmpisr = regs->ISR;
   \   0000004C   0x6838             LDR      R0,[R7, #+0]
   \   0000004E   0xE021             B.N      ??HAL_DMA_PollForTransfer_4
    659            
    660            while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
    661            {
    662              /* Check for the Timeout (Not applicable in circular mode)*/
    663              if(Timeout != HAL_MAX_DELAY)
    664              {
    665                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
    666                {
    667                  /* Update error code */
    668                  hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
    669          
    670                  /* Process Unlocked */
    671                  __HAL_UNLOCK(hdma);
    672                  
    673                  /* Change the DMA state */
    674                  hdma->State = HAL_DMA_STATE_READY;
    675                  
    676                  return HAL_TIMEOUT;
    677                }
    678              }
    679          
    680              /* Get the ISR register value */
    681              tmpisr = regs->ISR;
   \                     ??HAL_DMA_PollForTransfer_5: (+1)
   \   00000050   0x6838             LDR      R0,[R7, #+0]
   \   00000052   0x6DE2             LDR      R2,[R4, #+92]
   \   00000054   0x2108             MOVS     R1,#+8
   \   00000056   0x4091             LSLS     R1,R1,R2
   \   00000058   0x4208             TST      R0,R1
   \   0000005A   0xD004             BEQ.N    ??HAL_DMA_PollForTransfer_6
    682          
    683              if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
    684              {
    685                /* Update error code */
    686                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   0000005C   0x6D62             LDR      R2,[R4, #+84]
   \   0000005E   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000062   0x6562             STR      R2,[R4, #+84]
    687                
    688                /* Clear the transfer error flag */
    689                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   00000064   0x60B9             STR      R1,[R7, #+8]
    690              }
    691              
    692              if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_PollForTransfer_6: (+1)
   \   00000066   0x6DE1             LDR      R1,[R4, #+92]
   \   00000068   0xFA20 0xF201      LSR      R2,R0,R1
   \   0000006C   0x07D2             LSLS     R2,R2,#+31
   \   0000006E   0xD507             BPL.N    ??HAL_DMA_PollForTransfer_7
    693              {
    694                /* Update error code */
    695                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   00000070   0x6D62             LDR      R2,[R4, #+84]
   \   00000072   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000076   0x6562             STR      R2,[R4, #+84]
    696                
    697                /* Clear the FIFO error flag */
    698                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000007E   0x60B9             STR      R1,[R7, #+8]
   \                     ??HAL_DMA_PollForTransfer_7: (+1)
   \   00000080   0x2104             MOVS     R1,#+4
   \   00000082   0x6DE2             LDR      R2,[R4, #+92]
   \   00000084   0x4091             LSLS     R1,R1,R2
   \   00000086   0x4208             TST      R0,R1
   \   00000088   0xD004             BEQ.N    ??HAL_DMA_PollForTransfer_4
    699              }
    700              
    701              if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
    702              {
    703                /* Update error code */
    704                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   0000008A   0x6D62             LDR      R2,[R4, #+84]
   \   0000008C   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000090   0x6562             STR      R2,[R4, #+84]
    705                
    706                /* Clear the Direct Mode error flag */
    707                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   00000092   0x60B9             STR      R1,[R7, #+8]
    708              }
   \                     ??HAL_DMA_PollForTransfer_4: (+1)
   \   00000094   0xEA10 0x0F0A      TST      R0,R10
   \   00000098   0xD116             BNE.N    ??HAL_DMA_PollForTransfer_8
   \   0000009A   0x6D60             LDR      R0,[R4, #+84]
   \   0000009C   0x07C0             LSLS     R0,R0,#+31
   \   0000009E   0xD413             BMI.N    ??HAL_DMA_PollForTransfer_8
   \   000000A0   0xF116 0x0F01      CMN      R6,#+1
   \   000000A4   0xD0D4             BEQ.N    ??HAL_DMA_PollForTransfer_5
   \   000000A6   0xB12E             CBZ.N    R6,??HAL_DMA_PollForTransfer_9
   \   000000A8   0x.... 0x....      BL       HAL_GetTick
   \   000000AC   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000B0   0x4286             CMP      R6,R0
   \   000000B2   0xD2CD             BCS.N    ??HAL_DMA_PollForTransfer_5
   \                     ??HAL_DMA_PollForTransfer_9: (+1)
   \   000000B4   0x2020             MOVS     R0,#+32
   \   000000B6   0x6560             STR      R0,[R4, #+84]
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF884 0x0034      STRB     R0,[R4, #+52]
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   000000C4   0x2003             MOVS     R0,#+3
   \   000000C6   0xE023             B.N      ??HAL_DMA_PollForTransfer_3
    709            }
    710            
    711            if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
   \                     ??HAL_DMA_PollForTransfer_8: (+1)
   \   000000C8   0x6D60             LDR      R0,[R4, #+84]
   \   000000CA   0x2630             MOVS     R6,#+48
   \   000000CC   0xB180             CBZ.N    R0,??HAL_DMA_PollForTransfer_10
    712            {
    713              if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
   \   000000CE   0x6D60             LDR      R0,[R4, #+84]
   \   000000D0   0x07C0             LSLS     R0,R0,#+31
   \   000000D2   0xD50D             BPL.N    ??HAL_DMA_PollForTransfer_10
    714              {
    715                HAL_DMA_Abort(hdma);
   \   000000D4   0x4620             MOV      R0,R4
   \   000000D6   0x.... 0x....      BL       HAL_DMA_Abort
    716              
    717                /* Clear the half transfer and transfer complete flags */
    718                regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \   000000DA   0x6DE0             LDR      R0,[R4, #+92]
   \   000000DC   0xFA06 0xF000      LSL      R0,R6,R0
   \   000000E0   0x60B8             STR      R0,[R7, #+8]
    719              
    720                /* Process Unlocked */
    721                __HAL_UNLOCK(hdma);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF884 0x0034      STRB     R0,[R4, #+52]
    722          
    723                /* Change the DMA state */
    724                hdma->State= HAL_DMA_STATE_READY;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0xF884 0x0035      STRB     R0,[R4, #+53]
    725          
    726                return HAL_ERROR;
   \   000000EE   0xE00F             B.N      ??HAL_DMA_PollForTransfer_3
    727             }
    728            }
    729            
    730            /* Get the level transfer complete flag */
    731            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_10: (+1)
   \   000000F0   0x6DE0             LDR      R0,[R4, #+92]
   \   000000F2   0xB94D             CBNZ.N   R5,??HAL_DMA_PollForTransfer_11
    732            {
    733              /* Clear the half transfer and transfer complete flags */
    734              regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \   000000F4   0xFA06 0xF000      LSL      R0,R6,R0
   \   000000F8   0x60B8             STR      R0,[R7, #+8]
    735              
    736              /* Process Unlocked */
    737              __HAL_UNLOCK(hdma);
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF884 0x0034      STRB     R0,[R4, #+52]
    738          
    739              hdma->State = HAL_DMA_STATE_READY;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0xF884 0x0035      STRB     R0,[R4, #+53]
   \   00000106   0xE002             B.N      ??HAL_DMA_PollForTransfer_12
    740            }
    741            else
    742            {
    743              /* Clear the half transfer and transfer complete flags */
    744              regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
   \                     ??HAL_DMA_PollForTransfer_11: (+1)
   \   00000108   0xFA08 0xF000      LSL      R0,R8,R0
   \   0000010C   0x60B8             STR      R0,[R7, #+8]
    745            }
    746            
    747            return status;
   \                     ??HAL_DMA_PollForTransfer_12: (+1)
   \   0000010E   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_PollForTransfer_3: (+1)
   \   00000110   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    748          }
    749          
    750          /**
    751            * @brief  Handles DMA interrupt request.
    752            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    753            *               the configuration information for the specified DMA Stream.  
    754            * @retval None
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    757          {
   \                     HAL_DMA_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
    758            uint32_t tmpisr;
    759            __IO uint32_t count = 0U;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    760            uint32_t timeout = SystemCoreClock / 9600U;
   \   00000008   0xF44F 0x5116      MOV      R1,#+9600
   \   0000000C   0x....             LDR.N    R0,??DataTable2_1
    761          
    762            /* calculate DMA base and stream number */
    763            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \   0000000E   0x6DA6             LDR      R6,[R4, #+88]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
    764          
    765            tmpisr = regs->ISR;
   \   00000012   0x6837             LDR      R7,[R6, #+0]
   \   00000014   0xFBB0 0xF5F1      UDIV     R5,R0,R1
    766          
    767            /* Transfer Error Interrupt management ***************************************/
    768            if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
   \   00000018   0x6DE1             LDR      R1,[R4, #+92]
   \   0000001A   0x2008             MOVS     R0,#+8
   \   0000001C   0xFA00 0xF101      LSL      R1,R0,R1
   \   00000020   0x420F             TST      R7,R1
   \   00000022   0xD00E             BEQ.N    ??HAL_DMA_IRQHandler_0
    769            {
    770              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x0752             LSLS     R2,R2,#+29
   \   0000002A   0xD50A             BPL.N    ??HAL_DMA_IRQHandler_0
    771              {
    772                /* Disable the transfer error interrupt */
    773                hdma->Instance->CR  &= ~(DMA_IT_TE);
   \   0000002C   0x680A             LDR      R2,[R1, #+0]
   \   0000002E   0xF022 0x0204      BIC      R2,R2,#0x4
   \   00000032   0x600A             STR      R2,[R1, #+0]
    774                
    775                /* Clear the transfer error flag */
    776                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \   00000034   0x6DE1             LDR      R1,[R4, #+92]
   \   00000036   0x4088             LSLS     R0,R0,R1
   \   00000038   0x60B0             STR      R0,[R6, #+8]
    777                
    778                /* Update error code */
    779                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \   0000003A   0x6D60             LDR      R0,[R4, #+84]
   \   0000003C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000040   0x6560             STR      R0,[R4, #+84]
    780              }
    781            }
    782            /* FIFO Error Interrupt management ******************************************/
    783            if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_0: (+1)
   \   00000042   0x6DE0             LDR      R0,[R4, #+92]
   \   00000044   0xFA27 0xF100      LSR      R1,R7,R0
   \   00000048   0x07C9             LSLS     R1,R1,#+31
   \   0000004A   0xD50B             BPL.N    ??HAL_DMA_IRQHandler_1
    784            {
    785              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x6949             LDR      R1,[R1, #+20]
   \   00000050   0x0609             LSLS     R1,R1,#+24
   \   00000052   0xD507             BPL.N    ??HAL_DMA_IRQHandler_1
    786              {
    787                /* Clear the FIFO error flag */
    788                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0xFA01 0xF000      LSL      R0,R1,R0
   \   0000005A   0x60B0             STR      R0,[R6, #+8]
    789          
    790                /* Update error code */
    791                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \   0000005C   0x6D60             LDR      R0,[R4, #+84]
   \   0000005E   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000062   0x6560             STR      R0,[R4, #+84]
   \                     ??HAL_DMA_IRQHandler_1: (+1)
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0x6DE1             LDR      R1,[R4, #+92]
   \   00000068   0x4088             LSLS     R0,R0,R1
   \   0000006A   0x4207             TST      R7,R0
   \   0000006C   0xD008             BEQ.N    ??HAL_DMA_IRQHandler_2
    792              }
    793            }
    794            /* Direct Mode Error Interrupt management ***********************************/
    795            if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
    796            {
    797              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0x0789             LSLS     R1,R1,#+30
   \   00000074   0xD504             BPL.N    ??HAL_DMA_IRQHandler_2
    798              {
    799                /* Clear the direct mode error flag */
    800                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \   00000076   0x60B0             STR      R0,[R6, #+8]
    801          
    802                /* Update error code */
    803                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \   00000078   0x6D60             LDR      R0,[R4, #+84]
   \   0000007A   0xF040 0x0004      ORR      R0,R0,#0x4
   \   0000007E   0x6560             STR      R0,[R4, #+84]
   \                     ??HAL_DMA_IRQHandler_2: (+1)
   \   00000080   0x2010             MOVS     R0,#+16
   \   00000082   0x6DE1             LDR      R1,[R4, #+92]
   \   00000084   0x4088             LSLS     R0,R0,R1
   \   00000086   0x4207             TST      R7,R0
   \   00000088   0xD01D             BEQ.N    ??HAL_DMA_IRQHandler_3
    804              }
    805            }
    806            /* Half Transfer Complete Interrupt management ******************************/
    807            if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
    808            {
    809              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6809             LDR      R1,[R1, #+0]
   \   0000008E   0x0709             LSLS     R1,R1,#+28
   \   00000090   0xD519             BPL.N    ??HAL_DMA_IRQHandler_3
    810              {
    811                /* Clear the half transfer complete flag */
    812                regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \   00000092   0x60B0             STR      R0,[R6, #+8]
    813                
    814                /* Multi_Buffering mode enabled */
    815                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x6801             LDR      R1,[R0, #+0]
   \   00000098   0x0349             LSLS     R1,R1,#+13
   \   0000009A   0xD508             BPL.N    ??HAL_DMA_IRQHandler_4
    816                {
    817                  /* Current memory buffer used is Memory 0 */
    818                  if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x0300             LSLS     R0,R0,#+12
   \   000000A0   0xD50C             BPL.N    ??HAL_DMA_IRQHandler_5
    819                  {
    820                    if(hdma->XferHalfCpltCallback != NULL)
    821                    {
    822                      /* Half transfer callback */
    823                      hdma->XferHalfCpltCallback(hdma);
    824                    }
    825                  }
    826                  /* Current memory buffer used is Memory 1 */
    827                  else
    828                  {
    829                    if(hdma->XferM1HalfCpltCallback != NULL)
   \   000000A2   0x6CA1             LDR      R1,[R4, #+72]
   \   000000A4   0x0008             MOVS     R0,R1
   \   000000A6   0xD00E             BEQ.N    ??HAL_DMA_IRQHandler_3
    830                    {
    831                      /* Half transfer callback */
    832                      hdma->XferM1HalfCpltCallback(hdma);
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x4788             BLX      R1
   \   000000AC   0xE00B             B.N      ??HAL_DMA_IRQHandler_3
    833                    }
    834                  }
    835                }
    836                else
    837                {
    838                  /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    839                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
   \                     ??HAL_DMA_IRQHandler_4: (+1)
   \   000000AE   0x6801             LDR      R1,[R0, #+0]
   \   000000B0   0x05C9             LSLS     R1,R1,#+23
   \   000000B2   0xD403             BMI.N    ??HAL_DMA_IRQHandler_5
    840                  {
    841                    /* Disable the half transfer interrupt */
    842                    hdma->Instance->CR  &= ~(DMA_IT_HT);
   \   000000B4   0x6801             LDR      R1,[R0, #+0]
   \   000000B6   0xF021 0x0108      BIC      R1,R1,#0x8
   \   000000BA   0x6001             STR      R1,[R0, #+0]
    843                  }
    844                  
    845                  if(hdma->XferHalfCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_5: (+1)
   \   000000BC   0x6C21             LDR      R1,[R4, #+64]
   \   000000BE   0x0008             MOVS     R0,R1
   \   000000C0   0xBF1C             ITT      NE 
    846                  {
    847                    /* Half transfer callback */
    848                    hdma->XferHalfCpltCallback(hdma);
   \   000000C2   0x4620             MOVNE    R0,R4
   \   000000C4   0x4788             BLXNE    R1
   \                     ??HAL_DMA_IRQHandler_3: (+1)
   \   000000C6   0x6DE1             LDR      R1,[R4, #+92]
   \   000000C8   0x2020             MOVS     R0,#+32
   \   000000CA   0x4088             LSLS     R0,R0,R1
   \   000000CC   0x4207             TST      R7,R0
   \   000000CE   0xD04B             BEQ.N    ??HAL_DMA_IRQHandler_6
    849                  }
    850                }
    851              }
    852            }
    853            /* Transfer Complete Interrupt management ***********************************/
    854            if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
    855            {
    856              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0x06C9             LSLS     R1,R1,#+27
   \   000000D6   0xD547             BPL.N    ??HAL_DMA_IRQHandler_6
    857              {
    858                /* Clear the transfer complete flag */
    859                regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \   000000D8   0x60B0             STR      R0,[R6, #+8]
    860                
    861                if(HAL_DMA_STATE_ABORT == hdma->State)
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0xF894 0x1035      LDRB     R1,[R4, #+53]
   \   000000E0   0x2905             CMP      R1,#+5
   \   000000E2   0x6801             LDR      R1,[R0, #+0]
   \   000000E4   0xD123             BNE.N    ??HAL_DMA_IRQHandler_7
    862                {
    863                  /* Disable all the transfer interrupts */
    864                  hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
   \   000000E6   0xF021 0x0116      BIC      R1,R1,#0x16
   \   000000EA   0x6001             STR      R1,[R0, #+0]
    865                  hdma->Instance->FCR &= ~(DMA_IT_FE);
   \   000000EC   0x6820             LDR      R0,[R4, #+0]
   \   000000EE   0x6941             LDR      R1,[R0, #+20]
   \   000000F0   0xF021 0x0180      BIC      R1,R1,#0x80
   \   000000F4   0x6141             STR      R1,[R0, #+20]
    866                  
    867                  if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
   \   000000F6   0x6C20             LDR      R0,[R4, #+64]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xBF04             ITT      EQ 
   \   000000FC   0x6CA0             LDREQ    R0,[R4, #+72]
   \   000000FE   0x2800             CMPEQ    R0,#+0
   \   00000100   0xD004             BEQ.N    ??HAL_DMA_IRQHandler_8
    868                  {
    869                    hdma->Instance->CR  &= ~(DMA_IT_HT);
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6801             LDR      R1,[R0, #+0]
   \   00000106   0xF021 0x0108      BIC      R1,R1,#0x8
   \   0000010A   0x6001             STR      R1,[R0, #+0]
    870                  }
    871          
    872                  /* Clear all interrupt flags at correct offset within the register */
    873                  regs->IFCR = 0x3FU << hdma->StreamIndex;
   \                     ??HAL_DMA_IRQHandler_8: (+1)
   \   0000010C   0x203F             MOVS     R0,#+63
   \   0000010E   0x6DE1             LDR      R1,[R4, #+92]
   \   00000110   0x4088             LSLS     R0,R0,R1
   \   00000112   0x60B0             STR      R0,[R6, #+8]
    874          
    875                  /* Process Unlocked */
    876                  __HAL_UNLOCK(hdma);
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xF884 0x0034      STRB     R0,[R4, #+52]
    877          
    878                  /* Change the DMA state */
    879                  hdma->State = HAL_DMA_STATE_READY;
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0xF884 0x0035      STRB     R0,[R4, #+53]
    880          
    881                  if(hdma->XferAbortCallback != NULL)
   \   00000120   0x6D21             LDR      R1,[R4, #+80]
   \   00000122   0x0008             MOVS     R0,R1
   \   00000124   0xD043             BEQ.N    ??HAL_DMA_IRQHandler_9
    882                  {
    883                    hdma->XferAbortCallback(hdma);
   \   00000126   0x4620             MOV      R0,R4
   \   00000128   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   0000012C   0x4708             BX       R1
    884                  }
    885                  return;
    886                }
    887          
    888                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
   \                     ??HAL_DMA_IRQHandler_7: (+1)
   \   0000012E   0x0349             LSLS     R1,R1,#+13
   \   00000130   0xD508             BPL.N    ??HAL_DMA_IRQHandler_10
    889                {
    890                  /* Current memory buffer used is Memory 0 */
    891                  if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x0300             LSLS     R0,R0,#+12
   \   00000136   0xD412             BMI.N    ??HAL_DMA_IRQHandler_11
    892                  {
    893                    if(hdma->XferM1CpltCallback != NULL)
   \   00000138   0x6C61             LDR      R1,[R4, #+68]
   \   0000013A   0x0008             MOVS     R0,R1
   \   0000013C   0xD014             BEQ.N    ??HAL_DMA_IRQHandler_6
    894                    {
    895                      /* Transfer complete Callback for memory1 */
    896                      hdma->XferM1CpltCallback(hdma);
   \   0000013E   0x4620             MOV      R0,R4
   \   00000140   0x4788             BLX      R1
   \   00000142   0xE011             B.N      ??HAL_DMA_IRQHandler_6
    897                    }
    898                  }
    899                  /* Current memory buffer used is Memory 1 */
    900                  else
    901                  {
    902                    if(hdma->XferCpltCallback != NULL)
    903                    {
    904                      /* Transfer complete Callback for memory0 */
    905                      hdma->XferCpltCallback(hdma);
    906                    }
    907                  }
    908                }
    909                /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
    910                else
    911                {
    912                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
   \                     ??HAL_DMA_IRQHandler_10: (+1)
   \   00000144   0x6801             LDR      R1,[R0, #+0]
   \   00000146   0x05C9             LSLS     R1,R1,#+23
   \   00000148   0xD409             BMI.N    ??HAL_DMA_IRQHandler_11
    913                  {
    914                    /* Disable the transfer complete interrupt */
    915                    hdma->Instance->CR  &= ~(DMA_IT_TC);
   \   0000014A   0x6801             LDR      R1,[R0, #+0]
   \   0000014C   0xF021 0x0110      BIC      R1,R1,#0x10
   \   00000150   0x6001             STR      R1,[R0, #+0]
    916          
    917                    /* Process Unlocked */
    918                    __HAL_UNLOCK(hdma);
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0xF884 0x0034      STRB     R0,[R4, #+52]
    919          
    920                    /* Change the DMA state */
    921                    hdma->State = HAL_DMA_STATE_READY;
   \   00000158   0x2001             MOVS     R0,#+1
   \   0000015A   0xF884 0x0035      STRB     R0,[R4, #+53]
    922                  }
    923          
    924                  if(hdma->XferCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_11: (+1)
   \   0000015E   0x6BE1             LDR      R1,[R4, #+60]
   \   00000160   0x0008             MOVS     R0,R1
   \   00000162   0xBF1C             ITT      NE 
    925                  {
    926                    /* Transfer complete callback */
    927                    hdma->XferCpltCallback(hdma);
   \   00000164   0x4620             MOVNE    R0,R4
   \   00000166   0x4788             BLXNE    R1
    928                  }
    929                }
    930              }
    931            }
    932            
    933            /* manage error case */
    934            if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
   \                     ??HAL_DMA_IRQHandler_6: (+1)
   \   00000168   0x6D60             LDR      R0,[R4, #+84]
   \   0000016A   0xB300             CBZ.N    R0,??HAL_DMA_IRQHandler_9
    935            {
    936              if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
   \   0000016C   0x6D60             LDR      R0,[R4, #+84]
   \   0000016E   0x07C0             LSLS     R0,R0,#+31
   \   00000170   0xD516             BPL.N    ??HAL_DMA_IRQHandler_12
    937              {
    938                hdma->State = HAL_DMA_STATE_ABORT;
   \   00000172   0x2005             MOVS     R0,#+5
   \   00000174   0xF884 0x0035      STRB     R0,[R4, #+53]
    939          
    940                /* Disable the stream */
    941                __HAL_DMA_DISABLE(hdma);
   \   00000178   0x6820             LDR      R0,[R4, #+0]
   \   0000017A   0x6801             LDR      R1,[R0, #+0]
   \   0000017C   0x0849             LSRS     R1,R1,#+1
   \   0000017E   0x0049             LSLS     R1,R1,#+1
   \   00000180   0x6001             STR      R1,[R0, #+0]
    942          
    943                do
    944                {
    945                  if (++count > timeout)
   \                     ??HAL_DMA_IRQHandler_13: (+1)
   \   00000182   0x9800             LDR      R0,[SP, #+0]
   \   00000184   0x1C40             ADDS     R0,R0,#+1
   \   00000186   0x9000             STR      R0,[SP, #+0]
   \   00000188   0x4285             CMP      R5,R0
   \   0000018A   0xD303             BCC.N    ??HAL_DMA_IRQHandler_14
    946                  {
    947                    break;
    948                  }
    949                }
    950                while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
   \   0000018C   0x6820             LDR      R0,[R4, #+0]
   \   0000018E   0x6800             LDR      R0,[R0, #+0]
   \   00000190   0x07C0             LSLS     R0,R0,#+31
   \   00000192   0xD4F6             BMI.N    ??HAL_DMA_IRQHandler_13
    951          
    952                /* Process Unlocked */
    953                __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_IRQHandler_14: (+1)
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0xF884 0x0034      STRB     R0,[R4, #+52]
    954          
    955                /* Change the DMA state */
    956                hdma->State = HAL_DMA_STATE_READY;
   \   0000019A   0x2001             MOVS     R0,#+1
   \   0000019C   0xF884 0x0035      STRB     R0,[R4, #+53]
    957              }
    958          
    959              if(hdma->XferErrorCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_12: (+1)
   \   000001A0   0x6CE1             LDR      R1,[R4, #+76]
   \   000001A2   0x0008             MOVS     R0,R1
   \   000001A4   0xD003             BEQ.N    ??HAL_DMA_IRQHandler_9
    960              {
    961                /* Transfer error callback */
    962                hdma->XferErrorCallback(hdma);
   \   000001A6   0x4620             MOV      R0,R4
   \   000001A8   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000001AC   0x4708             BX       R1
    963              }
    964            }
    965          }
   \                     ??HAL_DMA_IRQHandler_9: (+1)
   \   000001AE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    966          
    967          /**
    968            * @brief  Register callbacks
    969            * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
    970            *                               the configuration information for the specified DMA Stream.
    971            * @param  CallbackID           User Callback identifer
    972            *                               a DMA_HandleTypeDef structure as parameter.
    973            * @param  pCallback            pointer to private callbacsk function which has pointer to 
    974            *                               a DMA_HandleTypeDef structure as parameter.
    975            * @retval HAL status
    976            */                      

   \                                 In section .text, align 4, keep-with-next
    977          HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
    978          {
   \                     HAL_DMA_RegisterCallback: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    979          
    980            HAL_StatusTypeDef status = HAL_OK;
    981          
    982            /* Process locked */
    983            __HAL_LOCK(hdma);
   \   00000002   0xF890 0x4034      LDRB     R4,[R0, #+52]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2C01             CMP      R4,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_DMA_RegisterCallback_1
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xBD30             POP      {R4,R5,PC}
   \                     ??HAL_DMA_RegisterCallback_1: (+1)
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xF880 0x4034      STRB     R4,[R0, #+52]
    984          
    985            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000016   0xF100 0x0434      ADD      R4,R0,#+52
   \   0000001A   0x7865             LDRB     R5,[R4, #+1]
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD112             BNE.N    ??HAL_DMA_RegisterCallback_2
    986            {
    987              switch (CallbackID)
   \   00000020   0x2905             CMP      R1,#+5
   \   00000022   0xD811             BHI.N    ??HAL_DMA_RegisterCallback_3
   \   00000024   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??HAL_DMA_RegisterCallback_0:
   \   00000028   0x03 0x05          DC8      0x3,0x5,0x7,0x9
   \              0x07 0x09    
   \   0000002C   0x0B 0x0D          DC8      0xB,0xD
    988              {
    989              case  HAL_DMA_XFER_CPLT_CB_ID:
    990                hdma->XferCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_4: (+1)
   \   0000002E   0x60A2             STR      R2,[R4, #+8]
    991                break;
   \   00000030   0xE00A             B.N      ??HAL_DMA_RegisterCallback_3
    992          
    993              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
    994                hdma->XferHalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_5: (+1)
   \   00000032   0x60E2             STR      R2,[R4, #+12]
    995                break;
   \   00000034   0xE008             B.N      ??HAL_DMA_RegisterCallback_3
    996          
    997              case  HAL_DMA_XFER_M1CPLT_CB_ID:
    998                hdma->XferM1CpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_6: (+1)
   \   00000036   0x6122             STR      R2,[R4, #+16]
    999                break;
   \   00000038   0xE006             B.N      ??HAL_DMA_RegisterCallback_3
   1000          
   1001              case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
   1002                hdma->XferM1HalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_7: (+1)
   \   0000003A   0x6162             STR      R2,[R4, #+20]
   1003                break;
   \   0000003C   0xE004             B.N      ??HAL_DMA_RegisterCallback_3
   1004          
   1005              case  HAL_DMA_XFER_ERROR_CB_ID:
   1006                hdma->XferErrorCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_8: (+1)
   \   0000003E   0x61A2             STR      R2,[R4, #+24]
   1007                break;
   \   00000040   0xE002             B.N      ??HAL_DMA_RegisterCallback_3
   1008          
   1009              case  HAL_DMA_XFER_ABORT_CB_ID:
   1010                hdma->XferAbortCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_9: (+1)
   \   00000042   0x61E2             STR      R2,[R4, #+28]
   1011                break;
   \   00000044   0xE000             B.N      ??HAL_DMA_RegisterCallback_3
   1012          
   1013              default:
   1014                break;
   1015              }
   1016            }
   1017            else
   1018            {
   1019              /* Return error status */
   1020              status =  HAL_ERROR;
   \                     ??HAL_DMA_RegisterCallback_2: (+1)
   \   00000046   0x2301             MOVS     R3,#+1
   1021            }
   1022          
   1023            /* Release Lock */
   1024            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_RegisterCallback_3: (+1)
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF880 0x1034      STRB     R1,[R0, #+52]
   1025            
   1026            return status;
   \   0000004E   0x4618             MOV      R0,R3
   \   00000050   0xBD30             POP      {R4,R5,PC}       ;; return
   1027          }
   1028          
   1029          /**
   1030            * @brief  UnRegister callbacks
   1031            * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
   1032            *                               the configuration information for the specified DMA Stream.
   1033            * @param  CallbackID           User Callback identifer
   1034            *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
   1035            * @retval HAL status
   1036            */              

   \                                 In section .text, align 4, keep-with-next
   1037          HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
   1038          {
   \                     HAL_DMA_UnRegisterCallback: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460A             MOV      R2,R1
   1039            HAL_StatusTypeDef status = HAL_OK;
   1040            
   1041            /* Process locked */
   1042            __HAL_LOCK(hdma);
   \   00000004   0xF890 0x3034      LDRB     R3,[R0, #+52]
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_DMA_UnRegisterCallback_1
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD10             POP      {R4,PC}
   \                     ??HAL_DMA_UnRegisterCallback_1: (+1)
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0xF880 0x3034      STRB     R3,[R0, #+52]
   1043            
   1044            if(HAL_DMA_STATE_READY == hdma->State)
   \   00000018   0xF100 0x0334      ADD      R3,R0,#+52
   \   0000001C   0x785C             LDRB     R4,[R3, #+1]
   \   0000001E   0x2C01             CMP      R4,#+1
   \   00000020   0xD118             BNE.N    ??HAL_DMA_UnRegisterCallback_2
   1045            {
   1046              switch (CallbackID)
   \   00000022   0x2A06             CMP      R2,#+6
   \   00000024   0xD816             BHI.N    ??HAL_DMA_UnRegisterCallback_2
   \   00000026   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??HAL_DMA_UnRegisterCallback_0:
   \   0000002A   0x04 0x06          DC8      0x4,0x6,0x8,0xA
   \              0x08 0x0A    
   \   0000002E   0x0C 0x13          DC8      0xC,0x13,0xE,0x0
   \              0x0E 0x00    
   1047              {
   1048              case  HAL_DMA_XFER_CPLT_CB_ID:
   1049                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_3: (+1)
   \   00000032   0x6099             STR      R1,[R3, #+8]
   1050                break;
   \   00000034   0xE00F             B.N      ??HAL_DMA_UnRegisterCallback_4
   1051                
   1052              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
   1053                hdma->XferHalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_5: (+1)
   \   00000036   0x60D9             STR      R1,[R3, #+12]
   1054                break;
   \   00000038   0xE00D             B.N      ??HAL_DMA_UnRegisterCallback_4
   1055                
   1056              case  HAL_DMA_XFER_M1CPLT_CB_ID:
   1057                hdma->XferM1CpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_6: (+1)
   \   0000003A   0x6119             STR      R1,[R3, #+16]
   1058                break;
   \   0000003C   0xE00B             B.N      ??HAL_DMA_UnRegisterCallback_4
   1059                
   1060              case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
   1061                hdma->XferM1HalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_7: (+1)
   \   0000003E   0x6159             STR      R1,[R3, #+20]
   1062                break;
   \   00000040   0xE009             B.N      ??HAL_DMA_UnRegisterCallback_4
   1063                
   1064              case  HAL_DMA_XFER_ERROR_CB_ID:
   1065                hdma->XferErrorCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_8: (+1)
   \   00000042   0x6199             STR      R1,[R3, #+24]
   1066                break;
   \   00000044   0xE007             B.N      ??HAL_DMA_UnRegisterCallback_4
   1067                
   1068              case  HAL_DMA_XFER_ABORT_CB_ID:
   1069                hdma->XferAbortCallback = NULL;
   1070                break; 
   1071                
   1072              case   HAL_DMA_XFER_ALL_CB_ID:
   1073                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_9: (+1)
   \   00000046   0x6099             STR      R1,[R3, #+8]
   1074                hdma->XferHalfCpltCallback = NULL;
   \   00000048   0x60D9             STR      R1,[R3, #+12]
   1075                hdma->XferM1CpltCallback = NULL;
   \   0000004A   0x6119             STR      R1,[R3, #+16]
   1076                hdma->XferM1HalfCpltCallback = NULL;
   \   0000004C   0x6159             STR      R1,[R3, #+20]
   1077                hdma->XferErrorCallback = NULL;
   \   0000004E   0x6199             STR      R1,[R3, #+24]
   1078                hdma->XferAbortCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_10: (+1)
   \   00000050   0x61D9             STR      R1,[R3, #+28]
   1079                break; 
   \   00000052   0xE000             B.N      ??HAL_DMA_UnRegisterCallback_4
   1080                
   1081              default:
   1082                status = HAL_ERROR;
   1083                break;
   1084              }
   1085            }
   1086            else
   1087            {
   1088              status = HAL_ERROR;
   \                     ??HAL_DMA_UnRegisterCallback_2: (+1)
   \   00000054   0x2101             MOVS     R1,#+1
   1089            }
   1090            
   1091            /* Release Lock */
   1092            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_UnRegisterCallback_4: (+1)
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0xF880 0x2034      STRB     R2,[R0, #+52]
   1093            
   1094            return status;
   \   0000005C   0x4608             MOV      R0,R1
   \   0000005E   0xBD10             POP      {R4,PC}          ;; return
   1095          }
   1096          
   1097          /**
   1098            * @}
   1099            */
   1100          
   1101          /** @addtogroup DMA_Exported_Functions_Group3
   1102            *
   1103          @verbatim
   1104           ===============================================================================
   1105                              ##### State and Errors functions #####
   1106           ===============================================================================
   1107              [..]
   1108              This subsection provides functions allowing to
   1109                (+) Check the DMA state
   1110                (+) Get error code
   1111          
   1112          @endverbatim
   1113            * @{
   1114            */
   1115          
   1116          /**
   1117            * @brief  Returns the DMA state.
   1118            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1119            *               the configuration information for the specified DMA Stream.
   1120            * @retval HAL state
   1121            */

   \                                 In section .text, align 2, keep-with-next
   1122          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
   1123          {
   1124            return hdma->State;
   \                     HAL_DMA_GetState: (+1)
   \   00000000   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000004   0x4770             BX       LR               ;; return
   1125          }
   1126          
   1127          /**
   1128            * @brief  Return the DMA error code
   1129            * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
   1130            *              the configuration information for the specified DMA Stream.
   1131            * @retval DMA Error Code
   1132            */

   \                                 In section .text, align 2, keep-with-next
   1133          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
   1134          {
   1135            return hdma->ErrorCode;
   \                     HAL_DMA_GetError: (+1)
   \   00000000   0x6D40             LDR      R0,[R0, #+84]
   \   00000002   0x4770             BX       LR               ;; return
   1136          }
   1137          
   1138          /**
   1139            * @}
   1140            */
   1141          
   1142          /**
   1143            * @}
   1144            */
   1145          
   1146          /** @addtogroup DMA_Private_Functions
   1147            * @{
   1148            */
   1149          
   1150          /**
   1151            * @brief  Sets the DMA Transfer parameter.
   1152            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
   1153            *                     the configuration information for the specified DMA Stream.
   1154            * @param  SrcAddress The source memory Buffer address
   1155            * @param  DstAddress The destination memory Buffer address
   1156            * @param  DataLength The length of data to be transferred from source to destination
   1157            * @retval HAL status
   1158            */

   \                                 In section .text, align 2, keep-with-next
   1159          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
   1160          {
   \                     DMA_SetConfig: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1161            /* Clear DBM bit */
   1162            hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
   \   00000002   0x6804             LDR      R4,[R0, #+0]
   \   00000004   0x6825             LDR      R5,[R4, #+0]
   \   00000006   0xF425 0x2580      BIC      R5,R5,#0x40000
   \   0000000A   0x6025             STR      R5,[R4, #+0]
   1163          
   1164            /* Configure DMA Stream data length */
   1165            hdma->Instance->NDTR = DataLength;
   \   0000000C   0x6063             STR      R3,[R4, #+4]
   1166          
   1167            /* Memory to Peripheral */
   1168            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x2840             CMP      R0,#+64
   \   00000012   0xBF07             ITTEE    EQ 
   1169            {
   1170              /* Configure DMA Stream destination address */
   1171              hdma->Instance->PAR = DstAddress;
   \   00000014   0x60A2             STREQ    R2,[R4, #+8]
   1172          
   1173              /* Configure DMA Stream source address */
   1174              hdma->Instance->M0AR = SrcAddress;
   \   00000016   0x60E1             STREQ    R1,[R4, #+12]
   1175            }
   1176            /* Peripheral to Memory */
   1177            else
   1178            {
   1179              /* Configure DMA Stream source address */
   1180              hdma->Instance->PAR = SrcAddress;
   \   00000018   0x60A1             STRNE    R1,[R4, #+8]
   1181          
   1182              /* Configure DMA Stream destination address */
   1183              hdma->Instance->M0AR = DstAddress;
   \   0000001A   0x60E2             STRNE    R2,[R4, #+12]
   \   0000001C   0xBD30             POP      {R4,R5,PC}
   1184            }
   1185          }
   1186          
   1187          /**
   1188            * @brief  Returns the DMA Stream base address depending on stream number
   1189            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
   1190            *                     the configuration information for the specified DMA Stream. 
   1191            * @retval Stream base address
   1192            */

   \                                 In section .text, align 2, keep-with-next
   1193          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
   1194          {
   1195            uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
   \                     DMA_CalcBaseAndBitshift: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xB2CA             UXTB     R2,R1
   \   00000004   0x3A10             SUBS     R2,R2,#+16
   \   00000006   0x2318             MOVS     R3,#+24
   \   00000008   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   1196            
   1197            /* lookup table for necessary bitshift of flags within status registers */
   1198            static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
   1199            hdma->StreamIndex = flagBitshiftOffset[stream_number];
   \   0000000C   0x.... 0x....      ADR.W    R3,??flagBitshiftOffset
   \   00000010   0x5CD3             LDRB     R3,[R2, R3]
   \   00000012   0x65C3             STR      R3,[R0, #+92]
   1200            
   1201            if (stream_number > 3U)
   \   00000014   0x0A89             LSRS     R1,R1,#+10
   \   00000016   0x0289             LSLS     R1,R1,#+10
   \   00000018   0x2A04             CMP      R2,#+4
   \   0000001A   0xBF28             IT       CS 
   1202            {
   1203              /* return pointer to HISR and HIFCR */
   1204              hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
   \   0000001C   0x1D09             ADDCS    R1,R1,#+4
   1205            }
   1206            else
   1207            {
   1208              /* return pointer to LISR and LIFCR */
   1209              hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
   \   0000001E   0x6581             STR      R1,[R0, #+88]
   1210            }
   1211            
   1212            return hdma->StreamBaseAddress;
   \   00000020   0x4608             MOV      R0,R1
   \   00000022   0x4770             BX       LR               ;; return
   1213          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??flagBitshiftOffset:
   \   00000000   0x00 0x06          DC8 0, 6, 16, 22, 0, 6, 16, 22
   \              0x10 0x16    
   \              0x00 0x06    
   \              0x10 0x16    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0xF010803F         DC32     0xf010803f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     SystemCoreClock
   1214          
   1215          /**
   1216            * @brief  Check compatibility between FIFO threshold level and size of the memory burst
   1217            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
   1218            *                     the configuration information for the specified DMA Stream. 
   1219            * @retval HAL status
   1220            */
   1221          static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
   1222          {
   1223            HAL_StatusTypeDef status = HAL_OK;
   1224            uint32_t tmp = hdma->Init.FIFOThreshold;
   1225            
   1226            /* Memory Data size equal to Byte */
   1227            if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
   1228            {
   1229              switch (tmp)
   1230              {
   1231              case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1232              case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1233                if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   1234                {
   1235                  status = HAL_ERROR;
   1236                }
   1237                break;
   1238              case DMA_FIFO_THRESHOLD_HALFFULL:
   1239                if (hdma->Init.MemBurst == DMA_MBURST_INC16)
   1240                {
   1241                  status = HAL_ERROR;
   1242                }
   1243                break;
   1244              case DMA_FIFO_THRESHOLD_FULL:
   1245                break;
   1246              default:
   1247                break;
   1248              }
   1249            }
   1250            
   1251            /* Memory Data size equal to Half-Word */
   1252            else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   1253            {
   1254              switch (tmp)
   1255              {
   1256              case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1257              case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1258                status = HAL_ERROR;
   1259                break;
   1260              case DMA_FIFO_THRESHOLD_HALFFULL:
   1261                if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   1262                {
   1263                  status = HAL_ERROR;
   1264                }
   1265                break;
   1266              case DMA_FIFO_THRESHOLD_FULL:
   1267                if (hdma->Init.MemBurst == DMA_MBURST_INC16)
   1268                {
   1269                  status = HAL_ERROR;
   1270                }
   1271                break;   
   1272              default:
   1273                break;
   1274              }
   1275            }
   1276            
   1277            /* Memory Data size equal to Word */
   1278            else
   1279            {
   1280              switch (tmp)
   1281              {
   1282              case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1283              case DMA_FIFO_THRESHOLD_HALFFULL:
   1284              case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1285                status = HAL_ERROR;
   1286                break;
   1287              case DMA_FIFO_THRESHOLD_FULL:
   1288                if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   1289                {
   1290                  status = HAL_ERROR;
   1291                }
   1292                break;
   1293              default:
   1294                break;
   1295              }
   1296            } 
   1297            
   1298            return status; 
   1299          }
   1300          
   1301          /**
   1302            * @}
   1303            */
   1304          
   1305          #endif /* HAL_DMA_MODULE_ENABLED */
   1306          /**
   1307            * @}
   1308            */
   1309          
   1310          /**
   1311            * @}
   1312            */
   1313          
   1314          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA_CalcBaseAndBitshift
      12   DMA_SetConfig
      16   HAL_DMA_Abort
        16   -> HAL_GetTick
       0   HAL_DMA_Abort_IT
       8   HAL_DMA_DeInit
         8   -> DMA_CalcBaseAndBitshift
       0   HAL_DMA_GetError
       0   HAL_DMA_GetState
      24   HAL_DMA_IRQHandler
         0   -- Indirect call
        24   -- Indirect call
      16   HAL_DMA_Init
        16   -> DMA_CalcBaseAndBitshift
        16   -> HAL_GetTick
      32   HAL_DMA_PollForTransfer
        32   -> HAL_DMA_Abort
        32   -> HAL_GetTick
      12   HAL_DMA_RegisterCallback
      16   HAL_DMA_Start
        16   -> DMA_SetConfig
      16   HAL_DMA_Start_IT
        16   -> DMA_SetConfig
       8   HAL_DMA_UnRegisterCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
      12  ?Subroutine0
      36  DMA_CalcBaseAndBitshift
      30  DMA_SetConfig
     146  HAL_DMA_Abort
      36  HAL_DMA_Abort_IT
      84  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     432  HAL_DMA_IRQHandler
     240  HAL_DMA_Init
     276  HAL_DMA_PollForTransfer
      82  HAL_DMA_RegisterCallback
      58  HAL_DMA_Start
     102  HAL_DMA_Start_IT
      96  HAL_DMA_UnRegisterCallback
       8  flagBitshiftOffset

 
 1 656 bytes in section .text
 
 1 656 bytes of CODE memory

Errors: none
Warnings: none
