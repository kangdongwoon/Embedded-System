###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:36
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c
#    Command line =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\stm32f4xx_hal_spi.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\stm32f4xx_hal_spi.o
#
###############################################################################

C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @brief   SPI HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *           + Peripheral State functions
     12            *
     13            @verbatim
     14            ==============================================================================
     15                                  ##### How to use this driver #####
     16            ==============================================================================
     17              [..]
     18                The SPI HAL driver can be used as follows:
     19          
     20                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     21                    SPI_HandleTypeDef  hspi;
     22          
     23                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API:
     24                    (##) Enable the SPIx interface clock
     25                    (##) SPI pins configuration
     26                        (+++) Enable the clock for the SPI GPIOs
     27                        (+++) Configure these SPI pins as alternate function push-pull
     28                    (##) NVIC configuration if you need to use interrupt process
     29                        (+++) Configure the SPIx interrupt priority
     30                        (+++) Enable the NVIC SPI IRQ handle
     31                    (##) DMA Configuration if you need to use DMA process
     32                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     33                        (+++) Enable the DMAx clock
     34                        (+++) Configure the DMA handle parameters
     35                        (+++) Configure the DMA Tx or Rx stream
     36                        (+++) Associate the initialized hdma_tx handle to the hspi DMA Tx or Rx handle
     37                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx stream
     38          
     39                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     40                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     41          
     42                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     43                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     44                        by calling the customized HAL_SPI_MspInit() API.
     45               [..]
     46                 Circular mode restriction:
     47                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     48                    (##) Master 2Lines RxOnly
     49                    (##) Master 1Line Rx
     50                (#) The CRC feature is not managed when the DMA circular mode is enabled
     51                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     52                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     53               [..]
     54                 Master Receive mode restriction:
     55                (#) In Master unidirectional receive-only mode (MSTR =1, BIDIMODE=0, RXONLY=0) or
     56                    bidirectional receive mode (MSTR=1, BIDIMODE=1, BIDIOE=0), to ensure that the SPI
     57                    does not initiate a new transfer the following procedure has to be respected:
     58                    (##) HAL_SPI_DeInit()
     59                    (##) HAL_SPI_Init()
     60          
     61            @endverbatim
     62          
     63              Using the HAL it is not possible to reach all supported SPI frequency with the differents SPI Modes,
     64              the following tables resume the max SPI frequency reached with data size 8bits/16bits,
     65              according to frequency used on APBx Peripheral Clock (fPCLK) used by the SPI instance :
     66              
     67              DataSize = SPI_DATASIZE_8BIT:
     68              +----------------------------------------------------------------------------------------------+
     69              |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
     70              | Process | Tranfert mode  |---------------------|----------------------|----------------------|
     71              |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
     72              |==============================================================================================|
     73              |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
     74              |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
     75              |    /    |     Interrupt  | Fpclk/4  | Fpclk/8  |    NA     |    NA    |    NA     |   NA     |
     76              |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
     77              |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
     78              |=========|================|==========|==========|===========|==========|===========|==========|
     79              |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
     80              |         |----------------|----------|----------|-----------|----------|-----------|----------|
     81              |    R    |     Interrupt  | Fpclk/8  | Fpclk/8  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
     82              |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
     83              |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
     84              |=========|================|==========|==========|===========|==========|===========|==========|
     85              |         |     Polling    | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
     86              |         |----------------|----------|----------|-----------|----------|-----------|----------|
     87              |    T    |     Interrupt  | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
     88              |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
     89              |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
     90              +----------------------------------------------------------------------------------------------+
     91              
     92              DataSize = SPI_DATASIZE_16BIT:
     93              +----------------------------------------------------------------------------------------------+
     94              |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
     95              | Process | Tranfert mode  |---------------------|----------------------|----------------------|
     96              |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
     97              |==============================================================================================|
     98              |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
     99              |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    100              |    /    |     Interrupt  | Fpclk/4  | Fpclk/4  |    NA     |    NA    |    NA     |   NA     |
    101              |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
    102              |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    103              |=========|================|==========|==========|===========|==========|===========|==========|
    104              |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/32  | Fpclk/2  |
    105              |         |----------------|----------|----------|-----------|----------|-----------|----------|
    106              |    R    |     Interrupt  | Fpclk/4  | Fpclk/4  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
    107              |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    108              |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
    109              |=========|================|==========|==========|===========|==========|===========|==========|
    110              |         |     Polling    | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/32 |
    111              |         |----------------|----------|----------|-----------|----------|-----------|----------|
    112              |    T    |     Interrupt  | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
    113              |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    114              |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
    115              +----------------------------------------------------------------------------------------------+
    116               [..]
    117                 (@) The max SPI frequency depend on SPI data size (8bits, 16bits),
    118                     SPI mode(2 Lines fullduplex, 2 lines RxOnly, 1 line TX/RX) and Process mode (Polling, IT, DMA).
    119                 (@)
    120                      (+@) TX/RX processes are HAL_SPI_TransmitReceive(), HAL_SPI_TransmitReceive_IT() and HAL_SPI_TransmitReceive_DMA()
    121                      (+@) RX processes are HAL_SPI_Receive(), HAL_SPI_Receive_IT() and HAL_SPI_Receive_DMA()
    122                      (+@) TX processes are HAL_SPI_Transmit(), HAL_SPI_Transmit_IT() and HAL_SPI_Transmit_DMA()
    123            ******************************************************************************
    124            * @attention
    125            *
    126            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
    127            *
    128            * Redistribution and use in source and binary forms, with or without modification,
    129            * are permitted provided that the following conditions are met:
    130            *   1. Redistributions of source code must retain the above copyright notice,
    131            *      this list of conditions and the following disclaimer.
    132            *   2. Redistributions in binary form must reproduce the above copyright notice,
    133            *      this list of conditions and the following disclaimer in the documentation
    134            *      and/or other materials provided with the distribution.
    135            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    136            *      may be used to endorse or promote products derived from this software
    137            *      without specific prior written permission.
    138            *
    139            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    140            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    141            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    142            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    143            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    144            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    145            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    146            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    147            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    148            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    149            *
    150            ******************************************************************************
    151            */
    152          
    153          /* Includes ------------------------------------------------------------------*/
    154          #include "stm32f4xx_hal.h"
    155          
    156          /** @addtogroup STM32F4xx_HAL_Driver
    157            * @{
    158            */
    159          /** @defgroup SPI SPI
    160            * @brief SPI HAL module driver
    161            * @{
    162            */
    163          #ifdef HAL_SPI_MODULE_ENABLED
    164          
    165          /* Private typedef -----------------------------------------------------------*/
    166          /* Private defines -----------------------------------------------------------*/
    167          /** @defgroup SPI_Private_Constants SPI Private Constants
    168            * @{
    169            */
    170          #define SPI_DEFAULT_TIMEOUT 100U
    171          /**
    172            * @}
    173            */
    174          
    175          /* Private macros ------------------------------------------------------------*/
    176          /* Private variables ---------------------------------------------------------*/
    177          /* Private function prototypes -----------------------------------------------*/
    178          /** @addtogroup SPI_Private_Functions
    179            * @{
    180            */
    181          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    182          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    183          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    184          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    185          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    186          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    187          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    188          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    189          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    190          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    191          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout, uint32_t Tickstart);
    192          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    193          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    194          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    195          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    196          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    197          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    198          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    199          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    200          #if (USE_SPI_CRC != 0U)
    201          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    202          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    203          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    204          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    205          #endif /* USE_SPI_CRC */
    206          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi);
    207          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi);
    208          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    209          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    210          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    211          static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart);
    212          /**
    213            * @}
    214            */
    215          
    216          /* Exported functions --------------------------------------------------------*/
    217          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    218            * @{
    219            */
    220          
    221          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    222           *  @brief    Initialization and Configuration functions
    223           *
    224          @verbatim
    225           ===============================================================================
    226                        ##### Initialization and de-initialization functions #####
    227           ===============================================================================
    228              [..]  This subsection provides a set of functions allowing to initialize and
    229                    de-initialize the SPIx peripheral:
    230          
    231                (+) User must implement HAL_SPI_MspInit() function in which he configures
    232                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    233          
    234                (+) Call the function HAL_SPI_Init() to configure the selected device with
    235                    the selected configuration:
    236                  (++) Mode
    237                  (++) Direction
    238                  (++) Data Size
    239                  (++) Clock Polarity and Phase
    240                  (++) NSS Management
    241                  (++) BaudRate Prescaler
    242                  (++) FirstBit
    243                  (++) TIMode
    244                  (++) CRC Calculation
    245                  (++) CRC Polynomial if CRC enabled
    246          
    247                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    248                    of the selected SPIx peripheral.
    249          
    250          @endverbatim
    251            * @{
    252            */
    253          
    254          /**
    255            * @brief  Initialize the SPI according to the specified parameters
    256            *         in the SPI_InitTypeDef and initialize the associated handle.
    257            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    258            *               the configuration information for SPI module.
    259            * @retval HAL status
    260            */

   \                                 In section .text, align 2, keep-with-next
    261          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    262          {
   \                     HAL_SPI_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    263            /* Check the SPI handle allocation */
    264            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_Init_0
    265            {
    266              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    267            }
    268          
    269            /* Check the parameters */
    270            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    271            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    272            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    273            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    274            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    275            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    276            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    277            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    278            if(hspi->Init.TIMode == SPI_TIMODE_DISABLE)
    279            {
    280              assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    281              assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    282            }
    283          #if (USE_SPI_CRC != 0U)
    284            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    285            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    286            {
    287              assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    288            }
    289          #else
    290            hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \                     ??HAL_SPI_Init_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x62A0             STR      R0,[R4, #+40]
    291          #endif /* USE_SPI_CRC */
    292          
    293            if(hspi->State == HAL_SPI_STATE_RESET)
   \   0000000E   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000012   0xB920             CBNZ.N   R0,??HAL_SPI_Init_1
    294            {
    295              /* Allocate lock resource and initialize it */
    296              hspi->Lock = HAL_UNLOCKED;
   \   00000014   0xF884 0x0050      STRB     R0,[R4, #+80]
    297          
    298              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    299              HAL_SPI_MspInit(hspi);
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       HAL_SPI_MspInit
    300            }
    301          
    302            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_1: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x0051      STRB     R0,[R4, #+81]
    303          
    304            /* Disable the selected SPI peripheral */
    305            __HAL_SPI_DISABLE(hspi);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    306          
    307            /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
    308            /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
    309            Communication speed, First bit and CRC calculation state */
    310            WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
    311                                            hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    312                                            hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );
   \   0000002E   0x6860             LDR      R0,[R4, #+4]
   \   00000030   0x68A1             LDR      R1,[R4, #+8]
   \   00000032   0x4308             ORRS     R0,R1,R0
   \   00000034   0x68E1             LDR      R1,[R4, #+12]
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x6921             LDR      R1,[R4, #+16]
   \   0000003A   0x4308             ORRS     R0,R1,R0
   \   0000003C   0x6961             LDR      R1,[R4, #+20]
   \   0000003E   0x4308             ORRS     R0,R1,R0
   \   00000040   0x69A1             LDR      R1,[R4, #+24]
   \   00000042   0xF401 0x7100      AND      R1,R1,#0x200
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x69E1             LDR      R1,[R4, #+28]
   \   0000004A   0x4308             ORRS     R0,R1,R0
   \   0000004C   0x6A21             LDR      R1,[R4, #+32]
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0x6AA1             LDR      R1,[R4, #+40]
   \   00000052   0x4308             ORRS     R0,R1,R0
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6008             STR      R0,[R1, #+0]
    313          
    314            /* Configure : NSS management */
    315            WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
   \   00000058   0x69A0             LDR      R0,[R4, #+24]
   \   0000005A   0x6A61             LDR      R1,[R4, #+36]
   \   0000005C   0x0C00             LSRS     R0,R0,#+16
   \   0000005E   0xF000 0x0004      AND      R0,R0,#0x4
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6048             STR      R0,[R1, #+4]
    316          
    317          #if (USE_SPI_CRC != 0U)
    318            /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
    319            /* Configure : CRC Polynomial */
    320            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    321            {
    322              WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
    323            }
    324          #endif /* USE_SPI_CRC */
    325          
    326          #if defined(SPI_I2SCFGR_I2SMOD)
    327            /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
    328            CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x69C1             LDR      R1,[R0, #+28]
   \   0000006C   0xF421 0x6100      BIC      R1,R1,#0x800
   \   00000070   0x61C1             STR      R1,[R0, #+28]
    329          #endif /* USE_SPI_CRC */
    330          
    331            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6560             STR      R0,[R4, #+84]
    332            hspi->State     = HAL_SPI_STATE_READY;
   \   00000076   0x.... 0x....      B.W      ?Subroutine0
    333          
    334            return HAL_OK;
    335          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF884 0x0051      STRB     R0,[R4, #+81]
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
    336          
    337          /**
    338            * @brief  De Initialize the SPI peripheral.
    339            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    340            *               the configuration information for SPI module.
    341            * @retval HAL status
    342            */

   \                                 In section .text, align 2, keep-with-next
    343          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    344          {
   \                     HAL_SPI_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    345            /* Check the SPI handle allocation */
    346            if(hspi == NULL)
   \   00000004   0xD101             BNE.N    ??HAL_SPI_DeInit_0
    347            {
    348              return HAL_ERROR;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xBD10             POP      {R4,PC}
    349            }
    350          
    351            /* Check SPI Instance parameter */
    352            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    353          
    354            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xF884 0x0051      STRB     R0,[R4, #+81]
    355          
    356            /* Disable the SPI Peripheral Clock */
    357            __HAL_SPI_DISABLE(hspi);
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000018   0x6001             STR      R1,[R0, #+0]
    358          
    359            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    360            HAL_SPI_MspDeInit(hspi);
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_SPI_MspDeInit
    361          
    362            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6560             STR      R0,[R4, #+84]
    363            hspi->State = HAL_SPI_STATE_RESET;
   \   00000024   0xF884 0x0051      STRB     R0,[R4, #+81]
    364          
    365            /* Release Lock */
    366            __HAL_UNLOCK(hspi);
   \   00000028   0xF884 0x0050      STRB     R0,[R4, #+80]
    367          
    368            return HAL_OK;
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    369          }
    370          
    371          /**
    372            * @brief  Initialize the SPI MSP.
    373            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    374            *               the configuration information for SPI module.
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    378          {
    379            /* Prevent unused argument(s) compilation warning */
    380            UNUSED(hspi);
    381            /* NOTE : This function should not be modified, when the callback is needed,
    382                      the HAL_SPI_MspInit should be implemented in the user file
    383            */
    384          }
   \                     HAL_SPI_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    385          
    386          /**
    387            * @brief  De-Initialize the SPI MSP.
    388            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    389            *               the configuration information for SPI module.
    390            * @retval None
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    393          {
    394            /* Prevent unused argument(s) compilation warning */
    395            UNUSED(hspi);
    396            /* NOTE : This function should not be modified, when the callback is needed,
    397                      the HAL_SPI_MspDeInit should be implemented in the user file
    398            */
    399          }
   \                     HAL_SPI_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    400          
    401          /**
    402            * @}
    403            */
    404          
    405          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    406           *  @brief   Data transfers functions
    407           *
    408          @verbatim
    409            ==============================================================================
    410                                ##### IO operation functions #####
    411           ===============================================================================
    412           [..]
    413              This subsection provides a set of functions allowing to manage the SPI
    414              data transfers.
    415          
    416              [..] The SPI supports master and slave mode :
    417          
    418              (#) There are two modes of transfer:
    419                 (++) Blocking mode: The communication is performed in polling mode.
    420                      The HAL status of all data processing is returned by the same function
    421                      after finishing transfer.
    422                 (++) No-Blocking mode: The communication is performed using Interrupts
    423                      or DMA, These APIs return the HAL status.
    424                      The end of the data processing will be indicated through the
    425                      dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    426                      using DMA mode.
    427                      The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    428                      will be executed respectively at the end of the transmit or Receive process
    429                      The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    430          
    431              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    432                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    433          
    434          @endverbatim
    435            * @{
    436            */
    437          
    438          /**
    439            * @brief  Transmit an amount of data in blocking mode.
    440            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    441            *               the configuration information for SPI module.
    442            * @param  pData pointer to data buffer
    443            * @param  Size amount of data to be sent
    444            * @param  Timeout Timeout duration
    445            * @retval HAL status
    446            */

   \                                 In section .text, align 2, keep-with-next
    447          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    448          {
   \                     HAL_SPI_Transmit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    449            uint32_t tickstart = 0U;
    450            HAL_StatusTypeDef errorcode = HAL_OK;
   \   00000006   0x2500             MOVS     R5,#+0
    451          
    452            /* Check Direction parameter */
    453            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    454          
    455            /* Process Locked */
    456            __HAL_LOCK(hspi);
   \   00000008   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   0000000C   0x4688             MOV      R8,R1
   \   0000000E   0x4617             MOV      R7,R2
   \   00000010   0x4699             MOV      R9,R3
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xBF08             IT       EQ 
   \   00000016   0x2002             MOVEQ    R0,#+2
   \   00000018   0xF000 0x8099      BEQ.W    ??HAL_SPI_Transmit_0
   \   0000001C   0x.... 0x....      BL       ?Subroutine13
    457          
    458            /* Init tickstart for timeout management*/
    459            tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_19: (+1)
   \   00000020   0x4606             MOV      R6,R0
    460          
    461            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000022   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xBF18             IT       NE 
    462            {
    463              errorcode = HAL_BUSY;
   \   0000002A   0x2502             MOVNE    R5,#+2
    464              goto error;
   \   0000002C   0xD172             BNE.N    ??HAL_SPI_Transmit_1
    465            }
    466          
    467            if((pData == NULL ) || (Size == 0))
   \   0000002E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000032   0xBF18             IT       NE 
   \   00000034   0x2F00             CMPNE    R7,#+0
   \   00000036   0xF000 0x8082      BEQ.W    ??HAL_SPI_Transmit_2
    468            {
    469              errorcode = HAL_ERROR;
    470              goto error;
    471            }
    472          
    473            /* Set the transaction information */
    474            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   0000003A   0x2003             MOVS     R0,#+3
   \   0000003C   0xF884 0x0051      STRB     R0,[R4, #+81]
    475            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000040   0x6565             STR      R5,[R4, #+84]
    476            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \   00000042   0xF8C4 0x8030      STR      R8,[R4, #+48]
    477            hspi->TxXferSize  = Size;
   \   00000046   0x86A7             STRH     R7,[R4, #+52]
    478            hspi->TxXferCount = Size;
   \   00000048   0x86E7             STRH     R7,[R4, #+54]
    479          
    480            /*Init field not used in handle to zero */
    481            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   0000004A   0x63A5             STR      R5,[R4, #+56]
    482            hspi->RxXferSize  = 0U;
   \   0000004C   0x87A5             STRH     R5,[R4, #+60]
    483            hspi->RxXferCount = 0U;
   \   0000004E   0x87E5             STRH     R5,[R4, #+62]
    484            hspi->TxISR       = NULL;
   \   00000050   0x6465             STR      R5,[R4, #+68]
    485            hspi->RxISR       = NULL;
   \   00000052   0x6425             STR      R5,[R4, #+64]
    486          
    487            /* Configure communication direction : 1Line */
    488            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000054   0x68A0             LDR      R0,[R4, #+8]
   \   00000056   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000005A   0xD104             BNE.N    ??HAL_SPI_Transmit_3
    489            {
    490              SPI_1LINE_TX(hspi);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000064   0x6001             STR      R1,[R0, #+0]
    491            }
    492          
    493          #if (USE_SPI_CRC != 0U)
    494            /* Reset CRC Calculation */
    495            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    496            {
    497              SPI_RESET_CRC(hspi);
    498            }
    499          #endif /* USE_SPI_CRC */
    500          
    501            /* Check if the SPI is already enabled */
    502            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_3: (+1)
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x6801             LDR      R1,[R0, #+0]
   \   0000006A   0x0649             LSLS     R1,R1,#+25
   \   0000006C   0xD403             BMI.N    ??HAL_SPI_Transmit_4
    503            {
    504              /* Enable SPI peripheral */
    505              __HAL_SPI_ENABLE(hspi);
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000074   0x6001             STR      R1,[R0, #+0]
    506            }
    507          
    508            /* Transmit data in 16 Bit mode */
    509            if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_Transmit_4: (+1)
   \   00000076   0x68E0             LDR      R0,[R4, #+12]
   \   00000078   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000007C   0x6860             LDR      R0,[R4, #+4]
   \   0000007E   0xD121             BNE.N    ??HAL_SPI_Transmit_5
    510            {
    511              if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xBF1C             ITT      NE 
   \   00000084   0x8EE0             LDRHNE   R0,[R4, #+54]
   \   00000086   0x2801             CMPNE    R0,#+1
   \   00000088   0xD10A             BNE.N    ??HAL_SPI_Transmit_6
    512              {
    513                hspi->Instance->DR = *((uint16_t *)pData);
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0xF838 0x0B02      LDRH     R0,[R8], #+2
   \   00000090   0x60C8             STR      R0,[R1, #+12]
    514                pData += sizeof(uint16_t);
    515                hspi->TxXferCount--;
   \   00000092   0xE002             B.N      ??HAL_SPI_Transmit_7
    516              }
    517              /* Transmit data in 16 Bit mode */
    518              while (hspi->TxXferCount > 0U)
    519              {
    520                /* Wait until TXE flag is set to send data */
    521                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
    522                {
    523                    hspi->Instance->DR = *((uint16_t *)pData);
   \                     ??HAL_SPI_Transmit_8: (+1)
   \   00000094   0xF838 0x1B02      LDRH     R1,[R8], #+2
   \   00000098   0x60C1             STR      R1,[R0, #+12]
    524                    pData += sizeof(uint16_t);
    525                    hspi->TxXferCount--;
   \                     ??HAL_SPI_Transmit_7: (+1)
   \   0000009A   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000009C   0x1E40             SUBS     R0,R0,#+1
   \   0000009E   0x86E0             STRH     R0,[R4, #+54]
    526                }
   \                     ??HAL_SPI_Transmit_6: (+1)
   \   000000A0   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000A2   0xB388             CBZ.N    R0,??HAL_SPI_Transmit_9
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6881             LDR      R1,[R0, #+8]
   \   000000A8   0x0789             LSLS     R1,R1,#+30
   \   000000AA   0xD4F3             BMI.N    ??HAL_SPI_Transmit_8
    527                else
    528                {
    529                  /* Timeout management */
    530                  if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
   \   000000AC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000B0   0xD02F             BEQ.N    ??HAL_SPI_Transmit_10
   \   000000B2   0xF119 0x0F01      CMN      R9,#+1
   \   000000B6   0xD0F3             BEQ.N    ??HAL_SPI_Transmit_6
   \   000000B8   0x.... 0x....      BL       HAL_GetTick
   \   000000BC   0x1B80             SUBS     R0,R0,R6
   \   000000BE   0x4548             CMP      R0,R9
   \   000000C0   0xD3EE             BCC.N    ??HAL_SPI_Transmit_6
   \   000000C2   0xE026             B.N      ??HAL_SPI_Transmit_10
    531                  {
    532                    errorcode = HAL_TIMEOUT;
    533                    goto error;
    534                  }
    535                }
    536              }
    537            }
    538            /* Transmit data in 8 Bit mode */
    539            else
    540            {
    541              if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
   \                     ??HAL_SPI_Transmit_5: (+1)
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xBF1C             ITT      NE 
   \   000000C8   0x8EE0             LDRHNE   R0,[R4, #+54]
   \   000000CA   0x2801             CMPNE    R0,#+1
   \   000000CC   0xD10A             BNE.N    ??HAL_SPI_Transmit_11
    542              {
    543                *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
   \   000000CE   0x6821             LDR      R1,[R4, #+0]
   \   000000D0   0xF818 0x0B01      LDRB     R0,[R8], #+1
   \   000000D4   0x7308             STRB     R0,[R1, #+12]
    544                pData += sizeof(uint8_t);
    545                hspi->TxXferCount--;
   \   000000D6   0xE002             B.N      ??HAL_SPI_Transmit_12
    546              }
    547              while (hspi->TxXferCount > 0U)
    548              {
    549                /* Wait until TXE flag is set to send data */
    550                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
    551                {
    552                  *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
   \                     ??HAL_SPI_Transmit_13: (+1)
   \   000000D8   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   000000DC   0x7301             STRB     R1,[R0, #+12]
    553                  pData += sizeof(uint8_t);
    554                  hspi->TxXferCount--;
   \                     ??HAL_SPI_Transmit_12: (+1)
   \   000000DE   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000E0   0x1E40             SUBS     R0,R0,#+1
   \   000000E2   0x86E0             STRH     R0,[R4, #+54]
    555                }
   \                     ??HAL_SPI_Transmit_11: (+1)
   \   000000E4   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000E6   0xB178             CBZ.N    R0,??HAL_SPI_Transmit_9
   \   000000E8   0x6820             LDR      R0,[R4, #+0]
   \   000000EA   0x6881             LDR      R1,[R0, #+8]
   \   000000EC   0x0789             LSLS     R1,R1,#+30
   \   000000EE   0xD4F3             BMI.N    ??HAL_SPI_Transmit_13
    556                else
    557                {
    558                  /* Timeout management */
    559                  if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
   \   000000F0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F4   0xD00D             BEQ.N    ??HAL_SPI_Transmit_10
   \   000000F6   0xF119 0x0F01      CMN      R9,#+1
   \   000000FA   0xD0F3             BEQ.N    ??HAL_SPI_Transmit_11
   \   000000FC   0x.... 0x....      BL       HAL_GetTick
   \   00000100   0x1B80             SUBS     R0,R0,R6
   \   00000102   0x4548             CMP      R0,R9
   \   00000104   0xD3EE             BCC.N    ??HAL_SPI_Transmit_11
   \   00000106   0xE004             B.N      ??HAL_SPI_Transmit_10
    560                  {
    561                    errorcode = HAL_TIMEOUT;
    562                    goto error;
    563                  }
    564                }
    565              }
    566            }
    567          
    568            /* Wait until TXE flag */
    569            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_SPI_Transmit_9: (+1)
   \   00000108   0x9600             STR      R6,[SP, #+0]
   \   0000010A   0x464B             MOV      R3,R9
   \   0000010C   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_29: (+1)
   \   00000110   0xB108             CBZ.N    R0,??HAL_SPI_Transmit_14
    570            {
    571              errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Transmit_10: (+1)
   \   00000112   0x2503             MOVS     R5,#+3
    572              goto error;
   \                     ??HAL_SPI_Transmit_1: (+1)
   \   00000114   0xE014             B.N      ??HAL_SPI_Transmit_15
    573            }
    574            
    575            /* Check Busy flag */
    576            if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_SPI_Transmit_14: (+1)
   \   00000116   0x4632             MOV      R2,R6
   \   00000118   0x4649             MOV      R1,R9
   \   0000011A   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_17: (+1)
   \   0000011E   0xB118             CBZ.N    R0,??HAL_SPI_Transmit_16
    577            {
    578              errorcode = HAL_ERROR;
    579              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \   00000120   0x2020             MOVS     R0,#+32
   \   00000122   0x2501             MOVS     R5,#+1
   \   00000124   0x6560             STR      R0,[R4, #+84]
    580              goto error;
   \   00000126   0xE00B             B.N      ??HAL_SPI_Transmit_15
    581            }
    582          
    583            /* Clear overrun flag in 2 Lines communication mode because received is not read */
    584            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_16: (+1)
   \   00000128   0x68A0             LDR      R0,[R4, #+8]
   \   0000012A   0xB930             CBNZ.N   R0,??HAL_SPI_Transmit_17
    585            {
    586              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000012C   0x9000             STR      R0,[SP, #+0]
   \   0000012E   0x6820             LDR      R0,[R4, #+0]
   \   00000130   0x68C1             LDR      R1,[R0, #+12]
   \   00000132   0x9100             STR      R1,[SP, #+0]
   \   00000134   0x6880             LDR      R0,[R0, #+8]
   \   00000136   0x9000             STR      R0,[SP, #+0]
   \   00000138   0x9800             LDR      R0,[SP, #+0]
    587            }
    588          #if (USE_SPI_CRC != 0U)
    589            /* Enable CRC Transmission */
    590            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    591            {
    592               SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    593            }
    594          #endif /* USE_SPI_CRC */
    595          
    596            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_Transmit_17: (+1)
   \   0000013A   0x6D60             LDR      R0,[R4, #+84]
   \   0000013C   0xB100             CBZ.N    R0,??HAL_SPI_Transmit_15
    597            {
    598              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Transmit_2: (+1)
   \   0000013E   0x2501             MOVS     R5,#+1
    599            }
    600          
    601          error:
    602            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Transmit_15: (+1)
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0xF884 0x0051      STRB     R0,[R4, #+81]
    603            /* Process Unlocked */
    604            __HAL_UNLOCK(hspi);
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xF884 0x0050      STRB     R0,[R4, #+80]
    605            return errorcode;
   \   0000014C   0x4628             MOV      R0,R5
   \                     ??HAL_SPI_Transmit_0: (+1)
   \   0000014E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    606          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF884 0x0050      STRB     R0,[R4, #+80]
   \   00000006   0x.... 0x....      B.W      HAL_GetTick

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      B.W      SPI_WaitFlagStateUntilTimeout

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x....             B.N      SPI_CheckFlag_BSY
    607          
    608          /**
    609            * @brief  Receive an amount of data in blocking mode.
    610            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    611            *               the configuration information for SPI module.
    612            * @param  pData pointer to data buffer
    613            * @param  Size amount of data to be received
    614            * @param  Timeout Timeout duration
    615            * @retval HAL status
    616            */

   \                                 In section .text, align 2, keep-with-next
    617          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    618          {
   \                     HAL_SPI_Receive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    619          #if (USE_SPI_CRC != 0U)
    620            __IO uint16_t tmpreg = 0U;
    621          #endif /* USE_SPI_CRC */
    622            uint32_t tickstart = 0U;
    623            HAL_StatusTypeDef errorcode = HAL_OK;
   \   00000006   0x2500             MOVS     R5,#+0
    624          
    625            if((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \   00000008   0x6860             LDR      R0,[R4, #+4]
   \   0000000A   0x4689             MOV      R9,R1
   \   0000000C   0x4616             MOV      R6,R2
   \   0000000E   0x461F             MOV      R7,R3
   \   00000010   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000014   0xBF04             ITT      EQ 
   \   00000016   0x68A0             LDREQ    R0,[R4, #+8]
   \   00000018   0x2800             CMPEQ    R0,#+0
   \   0000001A   0xD109             BNE.N    ??HAL_SPI_Receive_0
    626            {
    627               hspi->State = HAL_SPI_STATE_BUSY_RX;
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0xF884 0x0051      STRB     R0,[R4, #+81]
    628               /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    629              return HAL_SPI_TransmitReceive(hspi,pData,pData,Size,Timeout);
   \   00000022   0x9700             STR      R7,[SP, #+0]
   \   00000024   0x4633             MOV      R3,R6
   \   00000026   0x464A             MOV      R2,R9
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       HAL_SPI_TransmitReceive
   \   0000002E   0xE07D             B.N      ??HAL_SPI_Receive_1
    630            }
    631          
    632            /* Process Locked */
    633            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_0: (+1)
   \   00000030   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xBF08             IT       EQ 
   \   00000038   0x2002             MOVEQ    R0,#+2
   \   0000003A   0xD077             BEQ.N    ??HAL_SPI_Receive_1
   \   0000003C   0x.... 0x....      BL       ?Subroutine13
    634          
    635            /* Init tickstart for timeout management*/
    636            tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_18: (+1)
   \   00000040   0x4680             MOV      R8,R0
    637          
    638            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000042   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xBF18             IT       NE 
    639            {
    640              errorcode = HAL_BUSY;
   \   0000004A   0x2502             MOVNE    R5,#+2
    641              goto error;
   \   0000004C   0xD167             BNE.N    ??HAL_SPI_Receive_2
    642            }
    643          
    644            if((pData == NULL ) || (Size == 0))
   \   0000004E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000052   0xBF18             IT       NE 
   \   00000054   0x2E00             CMPNE    R6,#+0
   \   00000056   0xD061             BEQ.N    ??HAL_SPI_Receive_3
    645            {
    646              errorcode = HAL_ERROR;
    647              goto error;
    648            }
    649          
    650            /* Set the transaction information */
    651            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000058   0x2004             MOVS     R0,#+4
   \   0000005A   0xF884 0x0051      STRB     R0,[R4, #+81]
    652            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   0000005E   0x6565             STR      R5,[R4, #+84]
    653            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \   00000060   0xF8C4 0x9038      STR      R9,[R4, #+56]
    654            hspi->RxXferSize  = Size;
   \   00000064   0x87A6             STRH     R6,[R4, #+60]
    655            hspi->RxXferCount = Size;
   \   00000066   0x87E6             STRH     R6,[R4, #+62]
    656          
    657            /*Init field not used in handle to zero */
    658            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \   00000068   0x6325             STR      R5,[R4, #+48]
    659            hspi->TxXferSize  = 0U;
   \   0000006A   0x86A5             STRH     R5,[R4, #+52]
    660            hspi->TxXferCount = 0U;
   \   0000006C   0x86E5             STRH     R5,[R4, #+54]
    661            hspi->RxISR       = NULL;
   \   0000006E   0x6425             STR      R5,[R4, #+64]
    662            hspi->TxISR       = NULL;
   \   00000070   0x6465             STR      R5,[R4, #+68]
    663          
    664          #if (USE_SPI_CRC != 0U)
    665            /* Reset CRC Calculation */
    666            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    667            {
    668              SPI_RESET_CRC(hspi);
    669              /* this is done to handle the CRCNEXT before the latest data */
    670              hspi->RxXferCount--;
    671            }
    672          #endif /* USE_SPI_CRC */
    673          
    674            /* Configure communication direction: 1Line */
    675            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000072   0x68A0             LDR      R0,[R4, #+8]
   \   00000074   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000078   0xD104             BNE.N    ??HAL_SPI_Receive_4
    676            {
    677              SPI_1LINE_RX(hspi);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000082   0x6001             STR      R1,[R0, #+0]
    678            }
    679          
    680            /* Check if the SPI is already enabled */
    681            if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_4: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0x0649             LSLS     R1,R1,#+25
   \   0000008A   0xD403             BMI.N    ??HAL_SPI_Receive_5
    682            {
    683              /* Enable SPI peripheral */
    684              __HAL_SPI_ENABLE(hspi);
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000092   0x6001             STR      R1,[R0, #+0]
    685            }
    686          
    687              /* Receive data in 8 Bit mode */
    688            if(hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_5: (+1)
   \   00000094   0x68E0             LDR      R0,[R4, #+12]
   \   00000096   0xB9E8             CBNZ.N   R0,??HAL_SPI_Receive_6
   \   00000098   0xE005             B.N      ??HAL_SPI_Receive_7
    689            {
    690              /* Transfer loop */
    691              while(hspi->RxXferCount > 0U)
    692              {
    693                /* Check the RXNE flag */
    694                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
    695                {
    696                  /* read the received data */
    697                  (* (uint8_t *)pData)= *(__IO uint8_t *)&hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_8: (+1)
   \   0000009A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000009C   0xF809 0x0B01      STRB     R0,[R9], #+1
    698                  pData += sizeof(uint8_t);
    699                  hspi->RxXferCount--;
   \   000000A0   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000A2   0x1E40             SUBS     R0,R0,#+1
   \   000000A4   0x87E0             STRH     R0,[R4, #+62]
    700                }
   \                     ??HAL_SPI_Receive_7: (+1)
   \   000000A6   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000A8   0xB330             CBZ.N    R0,??HAL_SPI_Receive_9
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x6881             LDR      R1,[R0, #+8]
   \   000000AE   0x07C9             LSLS     R1,R1,#+31
   \   000000B0   0xD4F3             BMI.N    ??HAL_SPI_Receive_8
    701                else
    702                {
    703                  /* Timeout management */
    704                  if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
   \   000000B2   0xB1FF             CBZ.N    R7,??HAL_SPI_Receive_10
   \   000000B4   0xF117 0x0F01      CMN      R7,#+1
   \   000000B8   0xD0F5             BEQ.N    ??HAL_SPI_Receive_7
   \   000000BA   0x.... 0x....      BL       HAL_GetTick
   \   000000BE   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000000C2   0x42B8             CMP      R0,R7
   \   000000C4   0xD3EF             BCC.N    ??HAL_SPI_Receive_7
   \   000000C6   0xE015             B.N      ??HAL_SPI_Receive_10
    705                  {
    706                    errorcode = HAL_TIMEOUT;
    707                    goto error;
    708                  }
    709                }
    710              }
    711            }
    712            else
    713            {
    714              /* Transfer loop */
    715              while(hspi->RxXferCount > 0U)
    716              {
    717                /* Check the RXNE flag */
    718                if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
    719                {
    720                  *((uint16_t*)pData) = hspi->Instance->DR;
   \                     ??HAL_SPI_Receive_11: (+1)
   \   000000C8   0x68C0             LDR      R0,[R0, #+12]
   \   000000CA   0xF829 0x0B02      STRH     R0,[R9], #+2
    721                  pData += sizeof(uint16_t);
    722                  hspi->RxXferCount--;
   \   000000CE   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000D0   0x1E40             SUBS     R0,R0,#+1
   \   000000D2   0x87E0             STRH     R0,[R4, #+62]
    723                }
   \                     ??HAL_SPI_Receive_6: (+1)
   \   000000D4   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000D6   0xB178             CBZ.N    R0,??HAL_SPI_Receive_9
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x6881             LDR      R1,[R0, #+8]
   \   000000DC   0x07C9             LSLS     R1,R1,#+31
   \   000000DE   0xD4F3             BMI.N    ??HAL_SPI_Receive_11
    724                else
    725                {
    726                  /* Timeout management */
    727                  if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
   \   000000E0   0xB147             CBZ.N    R7,??HAL_SPI_Receive_10
   \   000000E2   0xF117 0x0F01      CMN      R7,#+1
   \   000000E6   0xD0F5             BEQ.N    ??HAL_SPI_Receive_6
   \   000000E8   0x.... 0x....      BL       HAL_GetTick
   \   000000EC   0xEBA0 0x0008      SUB      R0,R0,R8
   \   000000F0   0x42B8             CMP      R0,R7
   \   000000F2   0xD3EF             BCC.N    ??HAL_SPI_Receive_6
    728                  {
    729                    errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Receive_10: (+1)
   \   000000F4   0x2503             MOVS     R5,#+3
    730                    goto error;
   \   000000F6   0xE012             B.N      ??HAL_SPI_Receive_2
    731                  }
    732                }
    733              }
    734            }
    735          
    736          #if (USE_SPI_CRC != 0U)
    737            /* Handle the CRC Transmission */
    738            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    739            {
    740              /* freeze the CRC before the latest data */
    741              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    742          
    743              /* Read the latest data */
    744              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
    745              {
    746                /* the latest data has not been received */
    747                errorcode = HAL_TIMEOUT;
    748                goto error;
    749              }
    750          
    751              /* Receive last data in 16 Bit mode */
    752              if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
    753              {
    754                *((uint16_t*)pData) = hspi->Instance->DR;
    755              }
    756              /* Receive last data in 8 Bit mode */
    757              else
    758              {
    759                (*(uint8_t *)pData) = *(__IO uint8_t *)&hspi->Instance->DR;
    760              }
    761          
    762              /* Wait the CRC data */
    763              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
    764              {
    765                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    766                errorcode = HAL_TIMEOUT;
    767                goto error;
    768              }
    769          
    770              /* Read CRC to Flush DR and RXNE flag */
    771              tmpreg = hspi->Instance->DR;
    772              /* To avoid GCC warning */
    773              UNUSED(tmpreg);
    774            }
    775          #endif /* USE_SPI_CRC */
    776          
    777            /* Check the end of the transaction */
    778            if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \                     ??HAL_SPI_Receive_9: (+1)
   \   000000F8   0x6860             LDR      R0,[R4, #+4]
   \   000000FA   0xF5B0 0x7F82      CMP      R0,#+260
   \   000000FE   0xD10B             BNE.N    ??HAL_SPI_Receive_12
   \   00000100   0x68A0             LDR      R0,[R4, #+8]
   \   00000102   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000106   0xBF18             IT       NE 
   \   00000108   0xF5B0 0x6F80      CMPNE    R0,#+1024
   \   0000010C   0xD104             BNE.N    ??HAL_SPI_Receive_12
    779            {
    780              /* Disable SPI peripheral */
    781              __HAL_SPI_DISABLE(hspi);
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x6801             LDR      R1,[R0, #+0]
   \   00000112   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000116   0x6001             STR      R1,[R0, #+0]
    782            }
    783          
    784          #if (USE_SPI_CRC != 0U)
    785            /* Check if CRC error occurred */
    786            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
    787            {
    788              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    789              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    790            }
    791          #endif /* USE_SPI_CRC */
    792          
    793            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_Receive_12: (+1)
   \   00000118   0x6D60             LDR      R0,[R4, #+84]
   \   0000011A   0xB100             CBZ.N    R0,??HAL_SPI_Receive_2
    794            {
    795              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Receive_3: (+1)
   \   0000011C   0x2501             MOVS     R5,#+1
    796            }
    797          
    798          error :
    799            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Receive_2: (+1)
   \   0000011E   0x2001             MOVS     R0,#+1
   \   00000120   0xF884 0x0051      STRB     R0,[R4, #+81]
    800            __HAL_UNLOCK(hspi);
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xF884 0x0050      STRB     R0,[R4, #+80]
    801            return errorcode;
   \   0000012A   0x4628             MOV      R0,R5
   \                     ??HAL_SPI_Receive_1: (+1)
   \   0000012C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    802          }
    803          
    804          /**
    805            * @brief  Transmit and Receive an amount of data in blocking mode.
    806            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    807            *               the configuration information for SPI module.
    808            * @param  pTxData pointer to transmission data buffer
    809            * @param  pRxData pointer to reception data buffer
    810            * @param  Size amount of data to be sent and received
    811            * @param  Timeout Timeout duration
    812            * @retval HAL status
    813            */

   \                                 In section .text, align 2, keep-with-next
    814          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
    815          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xB082             SUB      SP,SP,#+8
    816            uint32_t tmp = 0U, tmp1 = 0U;
    817          #if (USE_SPI_CRC != 0U)
    818            __IO uint16_t tmpreg1 = 0U;
    819          #endif /* USE_SPI_CRC */
    820            uint32_t tickstart = 0U;
    821            /* Variable used to alternate Rx and Tx during transfer */
    822            uint32_t txallowed = 1U;
    823            HAL_StatusTypeDef errorcode = HAL_OK;
    824          
    825            /* Check Direction parameter */
    826            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
    827          
    828            /* Process Locked */
    829            __HAL_LOCK(hspi);
   \   00000008   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   0000000C   0x2601             MOVS     R6,#+1
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x4688             MOV      R8,R1
   \   00000012   0x4692             MOV      R10,R2
   \   00000014   0x461F             MOV      R7,R3
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2002             MOVEQ    R0,#+2
   \   0000001C   0xF000 0x80C9      BEQ.W    ??HAL_SPI_TransmitReceive_0
   \   00000020   0xF884 0x6050      STRB     R6,[R4, #+80]
    830          
    831            /* Init tickstart for timeout management*/
    832            tickstart = HAL_GetTick();
   \   00000024   0x.... 0x....      BL       HAL_GetTick
   \   00000028   0x4681             MOV      R9,R0
    833            
    834            tmp  = hspi->State;
   \   0000002A   0xF894 0x0051      LDRB     R0,[R4, #+81]
    835            tmp1 = hspi->Init.Mode;
    836            
    837            if(!((tmp == HAL_SPI_STATE_READY) || \
    838              ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD009             BEQ.N    ??HAL_SPI_TransmitReceive_1
   \   00000032   0x6861             LDR      R1,[R4, #+4]
   \   00000034   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000038   0xBF02             ITTT     EQ 
   \   0000003A   0x68A1             LDREQ    R1,[R4, #+8]
   \   0000003C   0x2900             CMPEQ    R1,#+0
   \   0000003E   0x2804             CMPEQ    R0,#+4
   \   00000040   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_1
    839            {
    840              errorcode = HAL_BUSY;
   \   00000042   0x2502             MOVS     R5,#+2
    841              goto error;
   \   00000044   0xE0AE             B.N      ??HAL_SPI_TransmitReceive_2
    842            }
    843          
    844            if((pTxData == NULL) || (pRxData == NULL) || (Size == 0))
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \   00000046   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0xF1BA 0x0F00      CMPNE    R10,#+0
   \   00000050   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_3
   \   00000052   0xB90F             CBNZ.N   R7,??HAL_SPI_TransmitReceive_4
    845            {
    846              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \   00000054   0x2501             MOVS     R5,#+1
    847              goto error;
   \   00000056   0xE0A5             B.N      ??HAL_SPI_TransmitReceive_2
    848            }
    849          
    850            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
    851            if(hspi->State == HAL_SPI_STATE_READY)
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \   00000058   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xBF04             ITT      EQ 
    852            {
    853              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   00000060   0x2005             MOVEQ    R0,#+5
   \   00000062   0xF884 0x0051      STRBEQ   R0,[R4, #+81]
    854            }
    855          
    856            /* Set the transaction information */
    857            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000066   0x6565             STR      R5,[R4, #+84]
    858            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \   00000068   0xF8C4 0xA038      STR      R10,[R4, #+56]
    859            hspi->RxXferCount = Size;
   \   0000006C   0x87E7             STRH     R7,[R4, #+62]
    860            hspi->RxXferSize  = Size;
   \   0000006E   0x87A7             STRH     R7,[R4, #+60]
    861            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \   00000070   0xF8C4 0x8030      STR      R8,[R4, #+48]
    862            hspi->TxXferCount = Size;
   \   00000074   0x86E7             STRH     R7,[R4, #+54]
    863            hspi->TxXferSize  = Size;
   \   00000076   0x86A7             STRH     R7,[R4, #+52]
    864          
    865            /*Init field not used in handle to zero */
    866            hspi->RxISR       = NULL;
   \   00000078   0x6425             STR      R5,[R4, #+64]
    867            hspi->TxISR       = NULL;
   \   0000007A   0x6465             STR      R5,[R4, #+68]
    868          
    869          #if (USE_SPI_CRC != 0U)
    870            /* Reset CRC Calculation */
    871            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    872            {
    873              SPI_RESET_CRC(hspi);
    874            }
    875          #endif /* USE_SPI_CRC */
    876          
    877            /* Check if the SPI is already enabled */
    878            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x6801             LDR      R1,[R0, #+0]
   \   00000080   0x0649             LSLS     R1,R1,#+25
   \   00000082   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_5
    879            {
    880              /* Enable SPI peripheral */
    881              __HAL_SPI_ENABLE(hspi);
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000008A   0x6001             STR      R1,[R0, #+0]
    882            }
    883          
    884            /* Transmit and Receive data in 16 Bit mode */
    885            if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \   0000008C   0x68E0             LDR      R0,[R4, #+12]
   \   0000008E   0x9F0A             LDR      R7,[SP, #+40]
   \   00000090   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000094   0x6860             LDR      R0,[R4, #+4]
   \   00000096   0xD135             BNE.N    ??HAL_SPI_TransmitReceive_6
    886            {
    887              if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xBF1C             ITT      NE 
   \   0000009C   0x8EE0             LDRHNE   R0,[R4, #+54]
   \   0000009E   0x2801             CMPNE    R0,#+1
   \   000000A0   0xD105             BNE.N    ??CrossCallReturnLabel_32
    888              {
    889                hspi->Instance->DR = *((uint16_t *)pTxData);
   \   000000A2   0x6821             LDR      R1,[R4, #+0]
   \   000000A4   0xF838 0x0B02      LDRH     R0,[R8], #+2
   \   000000A8   0x60C8             STR      R0,[R1, #+12]
    890                pTxData += sizeof(uint16_t);
    891                hspi->TxXferCount--;
   \   000000AA   0x.... 0x....      BL       ??Subroutine19_0
    892              }
    893              while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   \                     ??CrossCallReturnLabel_32: (+1)
   \   000000AE   0x8EE0             LDRH     R0,[R4, #+54]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xBF04             ITT      EQ 
   \   000000B4   0x8FE0             LDRHEQ   R0,[R4, #+62]
   \   000000B6   0x2800             CMPEQ    R0,#+0
   \   000000B8   0xD05A             BEQ.N    ??HAL_SPI_TransmitReceive_7
    894              {
    895                /* Check TXE flag */
    896                if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
   \   000000BA   0x2E00             CMP      R6,#+0
   \   000000BC   0xBF1C             ITT      NE 
   \   000000BE   0x8EE0             LDRHNE   R0,[R4, #+54]
   \   000000C0   0x2800             CMPNE    R0,#+0
   \   000000C2   0xD008             BEQ.N    ??CrossCallReturnLabel_30
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x6881             LDR      R1,[R0, #+8]
   \   000000C8   0x0789             LSLS     R1,R1,#+30
   \   000000CA   0xD504             BPL.N    ??CrossCallReturnLabel_30
    897                {
    898                  hspi->Instance->DR = *((uint16_t *)pTxData);
   \   000000CC   0xF838 0x1B02      LDRH     R1,[R8], #+2
   \   000000D0   0x60C1             STR      R1,[R0, #+12]
   \   000000D2   0x.... 0x....      BL       ?Subroutine19
    899                  pTxData += sizeof(uint16_t);
    900                  hspi->TxXferCount--;
    901                  /* Next Data is a reception (Rx). Tx not allowed */ 
    902                  txallowed = 0U;
    903          
    904          #if (USE_SPI_CRC != 0U)
    905                  /* Enable CRC Transmission */
    906                  if((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    907                  {
    908                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    909                  }
    910          #endif /* USE_SPI_CRC */
    911                }
    912          
    913                /* Check RXNE flag */
    914                if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
   \                     ??CrossCallReturnLabel_30: (+1)
   \   000000D6   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000D8   0xB150             CBZ.N    R0,??HAL_SPI_TransmitReceive_8
   \   000000DA   0x6820             LDR      R0,[R4, #+0]
   \   000000DC   0x6881             LDR      R1,[R0, #+8]
   \   000000DE   0x07C9             LSLS     R1,R1,#+31
   \   000000E0   0xD506             BPL.N    ??HAL_SPI_TransmitReceive_8
    915                {
    916                  *((uint16_t *)pRxData) = hspi->Instance->DR;
   \   000000E2   0x68C0             LDR      R0,[R0, #+12]
   \   000000E4   0xF82A 0x0B02      STRH     R0,[R10], #+2
   \   000000E8   0x2601             MOVS     R6,#+1
    917                  pRxData += sizeof(uint16_t);
    918                  hspi->RxXferCount--;
   \   000000EA   0x8FE0             LDRH     R0,[R4, #+62]
   \   000000EC   0x1E40             SUBS     R0,R0,#+1
   \   000000EE   0x87E0             STRH     R0,[R4, #+62]
    919                  /* Next Data is a Transmission (Tx). Tx is allowed */ 
    920                  txallowed = 1U;
    921                }
    922                if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \   000000F0   0xF117 0x0F01      CMN      R7,#+1
   \   000000F4   0xD0DB             BEQ.N    ??CrossCallReturnLabel_32
   \   000000F6   0x.... 0x....      BL       HAL_GetTick
   \   000000FA   0xEBA0 0x0009      SUB      R0,R0,R9
   \   000000FE   0x42B8             CMP      R0,R7
   \   00000100   0xD3D5             BCC.N    ??CrossCallReturnLabel_32
   \   00000102   0xE03B             B.N      ??HAL_SPI_TransmitReceive_9
    923                {
    924                  errorcode = HAL_TIMEOUT;
    925                  goto error;
    926                }
    927              }
    928            }
    929            /* Transmit and Receive data in 8 Bit mode */
    930            else
    931            {
    932              if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01U))
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xBF1C             ITT      NE 
   \   00000108   0x8EE0             LDRHNE   R0,[R4, #+54]
   \   0000010A   0x2801             CMPNE    R0,#+1
   \   0000010C   0xD105             BNE.N    ??CrossCallReturnLabel_33
    933              {
    934                *((__IO uint8_t*)&hspi->Instance->DR) = (*pTxData);
   \   0000010E   0x6821             LDR      R1,[R4, #+0]
   \   00000110   0xF818 0x0B01      LDRB     R0,[R8], #+1
   \   00000114   0x7308             STRB     R0,[R1, #+12]
    935                pTxData += sizeof(uint8_t);
    936                hspi->TxXferCount--;
   \   00000116   0x.... 0x....      BL       ??Subroutine19_0
    937              }
    938              while((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   \                     ??CrossCallReturnLabel_33: (+1)
   \   0000011A   0x8EE0             LDRH     R0,[R4, #+54]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xBF04             ITT      EQ 
   \   00000120   0x8FE0             LDRHEQ   R0,[R4, #+62]
   \   00000122   0x2800             CMPEQ    R0,#+0
   \   00000124   0xD024             BEQ.N    ??HAL_SPI_TransmitReceive_7
    939              {
    940                /* check TXE flag */
    941                if(txallowed && (hspi->TxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)))
   \   00000126   0x2E00             CMP      R6,#+0
   \   00000128   0xBF1C             ITT      NE 
   \   0000012A   0x8EE0             LDRHNE   R0,[R4, #+54]
   \   0000012C   0x2800             CMPNE    R0,#+0
   \   0000012E   0xD008             BEQ.N    ??CrossCallReturnLabel_31
   \   00000130   0x6820             LDR      R0,[R4, #+0]
   \   00000132   0x6881             LDR      R1,[R0, #+8]
   \   00000134   0x0789             LSLS     R1,R1,#+30
   \   00000136   0xD504             BPL.N    ??CrossCallReturnLabel_31
    942                {
    943                  *(__IO uint8_t *)&hspi->Instance->DR = (*pTxData++);
   \   00000138   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   0000013C   0x7301             STRB     R1,[R0, #+12]
   \   0000013E   0x.... 0x....      BL       ?Subroutine19
    944                  hspi->TxXferCount--;
    945                  /* Next Data is a reception (Rx). Tx not allowed */ 
    946                  txallowed = 0U;
    947          
    948          #if (USE_SPI_CRC != 0U)
    949                  /* Enable CRC Transmission */
    950                  if((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
    951                  {
    952                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    953                  }
    954          #endif /* USE_SPI_CRC */
    955                }
    956          
    957                /* Wait until RXNE flag is reset */
    958                if((hspi->RxXferCount > 0U) && (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)))
   \                     ??CrossCallReturnLabel_31: (+1)
   \   00000142   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000144   0xB150             CBZ.N    R0,??HAL_SPI_TransmitReceive_10
   \   00000146   0x6820             LDR      R0,[R4, #+0]
   \   00000148   0x6881             LDR      R1,[R0, #+8]
   \   0000014A   0x07C9             LSLS     R1,R1,#+31
   \   0000014C   0xD506             BPL.N    ??HAL_SPI_TransmitReceive_10
    959                {
    960                  (*(uint8_t *)pRxData++) = hspi->Instance->DR;
   \   0000014E   0x68C0             LDR      R0,[R0, #+12]
   \   00000150   0xF80A 0x0B01      STRB     R0,[R10], #+1
   \   00000154   0x2601             MOVS     R6,#+1
    961                  hspi->RxXferCount--;
   \   00000156   0x8FE0             LDRH     R0,[R4, #+62]
   \   00000158   0x1E40             SUBS     R0,R0,#+1
   \   0000015A   0x87E0             STRH     R0,[R4, #+62]
    962                  /* Next Data is a Transmission (Tx). Tx is allowed */ 
    963                  txallowed = 1U;
    964                }
    965                if((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout))
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \   0000015C   0xF117 0x0F01      CMN      R7,#+1
   \   00000160   0xD0DB             BEQ.N    ??CrossCallReturnLabel_33
   \   00000162   0x.... 0x....      BL       HAL_GetTick
   \   00000166   0xEBA0 0x0009      SUB      R0,R0,R9
   \   0000016A   0x42B8             CMP      R0,R7
   \   0000016C   0xD3D5             BCC.N    ??CrossCallReturnLabel_33
   \   0000016E   0xE005             B.N      ??HAL_SPI_TransmitReceive_9
    966                {
    967                  errorcode = HAL_TIMEOUT;
    968                  goto error;
    969                }
    970              }
    971            }
    972          
    973          #if (USE_SPI_CRC != 0U)
    974            /* Read CRC from DR to close CRC calculation process */
    975            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    976            {
    977              /* Wait until TXE flag */
    978              if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
    979              {
    980                /* Error on the CRC reception */
    981                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    982                errorcode = HAL_TIMEOUT;
    983                goto error;
    984              }
    985              /* Read CRC */
    986              tmpreg1 = hspi->Instance->DR;
    987              /* To avoid GCC warning */
    988              UNUSED(tmpreg1);
    989            }
    990          
    991            /* Check if CRC error occurred */
    992            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
    993            {
    994              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    995              /* Clear CRC Flag */
    996              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    997          
    998              errorcode = HAL_ERROR;
    999            }
   1000          #endif /* USE_SPI_CRC */
   1001          
   1002            /* Wait until TXE flag */
   1003            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \   00000170   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000174   0x463B             MOV      R3,R7
   \   00000176   0x.... 0x....      BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_28: (+1)
   \   0000017A   0xB108             CBZ.N    R0,??HAL_SPI_TransmitReceive_11
   1004            {
   1005              errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \   0000017C   0x2503             MOVS     R5,#+3
   1006              goto error;
   \   0000017E   0xE011             B.N      ??HAL_SPI_TransmitReceive_2
   1007            }
   1008            
   1009            /* Check Busy flag */
   1010            if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \   00000180   0x464A             MOV      R2,R9
   \   00000182   0x4639             MOV      R1,R7
   \   00000184   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_16: (+1)
   \   00000188   0xB118             CBZ.N    R0,??HAL_SPI_TransmitReceive_12
   1011            {
   1012              errorcode = HAL_ERROR;
   1013              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \   0000018A   0x2020             MOVS     R0,#+32
   \   0000018C   0x2501             MOVS     R5,#+1
   \   0000018E   0x6560             STR      R0,[R4, #+84]
   1014              goto error;
   \   00000190   0xE008             B.N      ??HAL_SPI_TransmitReceive_2
   1015            }
   1016          
   1017            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   1018            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \   00000192   0x68A0             LDR      R0,[R4, #+8]
   \   00000194   0xB930             CBNZ.N   R0,??HAL_SPI_TransmitReceive_2
   1019            {
   1020              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000196   0x9000             STR      R0,[SP, #+0]
   \   00000198   0x6820             LDR      R0,[R4, #+0]
   \   0000019A   0x68C1             LDR      R1,[R0, #+12]
   \   0000019C   0x9100             STR      R1,[SP, #+0]
   \   0000019E   0x6880             LDR      R0,[R0, #+8]
   \   000001A0   0x9000             STR      R0,[SP, #+0]
   \   000001A2   0x9800             LDR      R0,[SP, #+0]
   1021            }
   1022            
   1023          error :
   1024            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \   000001A4   0x2001             MOVS     R0,#+1
   \   000001A6   0xF884 0x0051      STRB     R0,[R4, #+81]
   1025            __HAL_UNLOCK(hspi);
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0xF884 0x0050      STRB     R0,[R4, #+80]
   1026            return errorcode;
   \   000001B0   0x4628             MOV      R0,R5
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \   000001B2   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1027          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \   00000000   0x2600             MOVS     R6,#+0
   \                     ??Subroutine19_0: (+1)
   \   00000002   0x8EE0             LDRH     R0,[R4, #+54]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x86E0             STRH     R0,[R4, #+54]
   \   00000008   0x4770             BX       LR
   1028          
   1029          /**
   1030            * @brief  Transmit an amount of data in non-blocking mode with Interrupt.
   1031            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1032            *               the configuration information for SPI module.
   1033            * @param  pData pointer to data buffer
   1034            * @param  Size amount of data to be sent
   1035            * @retval HAL status
   1036            */

   \                                 In section .text, align 2, keep-with-next
   1037          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1038          {
   \                     HAL_SPI_Transmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4613             MOV      R3,R2
   1039            HAL_StatusTypeDef errorcode = HAL_OK;
   1040          
   1041            /* Check Direction parameter */
   1042            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1043          
   1044            /* Process Locked */
   1045            __HAL_LOCK(hspi);
   \   00000004   0xF890 0x4050      LDRB     R4,[R0, #+80]
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD10             POP      {R4,PC}
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \   00000012   0x2401             MOVS     R4,#+1
   \   00000014   0xF880 0x4050      STRB     R4,[R0, #+80]
   1046          
   1047            if((pData == NULL) || (Size == 0))
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xBF14             ITE      NE 
   \   0000001C   0x2B00             CMPNE    R3,#+0
   1048            {
   1049              errorcode = HAL_ERROR;
   \   0000001E   0x2201             MOVEQ    R2,#+1
   1050              goto error;
   \   00000020   0xD033             BEQ.N    ??HAL_SPI_Transmit_IT_1
   1051            }
   1052          
   1053            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000022   0xF890 0x4051      LDRB     R4,[R0, #+81]
   \   00000026   0x2C01             CMP      R4,#+1
   \   00000028   0xBF18             IT       NE 
   1054            {
   1055              errorcode = HAL_BUSY;
   \   0000002A   0x2202             MOVNE    R2,#+2
   1056              goto error;
   \   0000002C   0xD12D             BNE.N    ??HAL_SPI_Transmit_IT_1
   1057            }
   1058          
   1059            /* Set the transaction information */
   1060            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   0000002E   0x2403             MOVS     R4,#+3
   \   00000030   0xF880 0x4051      STRB     R4,[R0, #+81]
   1061            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000034   0x6542             STR      R2,[R0, #+84]
   1062            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \   00000036   0x6301             STR      R1,[R0, #+48]
   1063            hspi->TxXferSize  = Size;
   \   00000038   0x8683             STRH     R3,[R0, #+52]
   1064            hspi->TxXferCount = Size;
   \   0000003A   0x86C3             STRH     R3,[R0, #+54]
   1065          
   1066            /* Init field not used in handle to zero */
   1067            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   0000003C   0x6382             STR      R2,[R0, #+56]
   1068            hspi->RxXferSize  = 0U;
   \   0000003E   0x8782             STRH     R2,[R0, #+60]
   1069            hspi->RxXferCount = 0U;
   \   00000040   0x87C2             STRH     R2,[R0, #+62]
   1070            hspi->RxISR       = NULL;
   \   00000042   0x6402             STR      R2,[R0, #+64]
   1071          
   1072            /* Set the function for IT treatment */
   1073            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000044   0x68C1             LDR      R1,[R0, #+12]
   \   00000046   0x2900             CMP      R1,#+0
   \   00000048   0xBF14             ITE      NE 
   1074            {
   1075              hspi->TxISR = SPI_TxISR_16BIT;
   \   0000004A   0x.... 0x....      ADRNE.W  R1,SPI_TxISR_16BIT
   1076            }
   1077            else
   1078            {
   1079              hspi->TxISR = SPI_TxISR_8BIT;
   \   0000004E   0x.... 0x....      ADREQ.W  R1,SPI_TxISR_8BIT
   \   00000052   0x6441             STR      R1,[R0, #+68]
   1080            }
   1081          
   1082            /* Configure communication direction : 1Line */
   1083            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000054   0x6881             LDR      R1,[R0, #+8]
   \   00000056   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000005A   0xD104             BNE.N    ??HAL_SPI_Transmit_IT_2
   1084            {
   1085              SPI_1LINE_TX(hspi);
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x680B             LDR      R3,[R1, #+0]
   \   00000060   0xF443 0x4380      ORR      R3,R3,#0x4000
   \   00000064   0x600B             STR      R3,[R1, #+0]
   1086            }
   1087          
   1088          #if (USE_SPI_CRC != 0U)
   1089            /* Reset CRC Calculation */
   1090            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1091            {
   1092              SPI_RESET_CRC(hspi);
   1093            }
   1094          #endif /* USE_SPI_CRC */
   1095          
   1096            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \   00000066   0x6881             LDR      R1,[R0, #+8]
   \   00000068   0x2900             CMP      R1,#+0
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x684B             LDR      R3,[R1, #+4]
   \   0000006E   0xBF0C             ITE      EQ 
   1097            {
   1098              /* Enable TXE interrupt */
   1099              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE));
   \   00000070   0xF043 0x0380      ORREQ    R3,R3,#0x80
   1100            }
   1101            else
   1102            {
   1103              /* Enable TXE and ERR interrupt */
   1104              __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \   00000074   0xF043 0x03A0      ORRNE    R3,R3,#0xA0
   \   00000078   0x604B             STR      R3,[R1, #+4]
   1105            }
   1106          
   1107            /* Check if the SPI is already enabled */
   1108            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0x680B             LDR      R3,[R1, #+0]
   \   0000007E   0x065B             LSLS     R3,R3,#+25
   \   00000080   0xD403             BMI.N    ??HAL_SPI_Transmit_IT_1
   1109            {
   1110              /* Enable SPI peripheral */
   1111              __HAL_SPI_ENABLE(hspi);
   \   00000082   0x680B             LDR      R3,[R1, #+0]
   \   00000084   0xF043 0x0340      ORR      R3,R3,#0x40
   \   00000088   0x600B             STR      R3,[R1, #+0]
   1112            }
   1113          
   1114          error :
   1115            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0xF880 0x1050      STRB     R1,[R0, #+80]
   1116            return errorcode;
   \   00000090   0x4610             MOV      R0,R2
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
   1117          }
   1118          
   1119          /**
   1120            * @brief  Receive an amount of data in non-blocking mode with Interrupt.
   1121            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1122            *               the configuration information for SPI module.
   1123            * @param  pData pointer to data buffer
   1124            * @param  Size amount of data to be sent
   1125            * @retval HAL status
   1126            */

   \                                 In section .text, align 2, keep-with-next
   1127          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1128          {
   \                     HAL_SPI_Receive_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1129            HAL_StatusTypeDef errorcode = HAL_OK;
   1130          
   1131            if((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   \   00000002   0x6884             LDR      R4,[R0, #+8]
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xBF04             ITT      EQ 
   \   0000000A   0x6845             LDREQ    R5,[R0, #+4]
   \   0000000C   0xF5B5 0x7F82      CMPEQ    R5,#+260
   \   00000010   0xD108             BNE.N    ??HAL_SPI_Receive_IT_0
   1132            {
   1133               hspi->State = HAL_SPI_STATE_BUSY_RX;
   \   00000012   0x2304             MOVS     R3,#+4
   \   00000014   0xF880 0x3051      STRB     R3,[R0, #+81]
   1134               /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1135               return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
   \   00000018   0xB001             ADD      SP,SP,#+4
   \   0000001A   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   0000001E   0x4613             MOV      R3,R2
   \   00000020   0x460A             MOV      R2,R1
   \   00000022   0x....             B.N      HAL_SPI_TransmitReceive_IT
   1136            }
   1137          
   1138            /* Process Locked */
   1139            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \   00000024   0xF890 0x5050      LDRB     R5,[R0, #+80]
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD101             BNE.N    ??HAL_SPI_Receive_IT_1
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \   00000030   0x2501             MOVS     R5,#+1
   \   00000032   0xF880 0x5050      STRB     R5,[R0, #+80]
   1140          
   1141            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000036   0xF890 0x5051      LDRB     R5,[R0, #+81]
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xBF18             IT       NE 
   1142            {
   1143              errorcode = HAL_BUSY;
   \   0000003E   0x2302             MOVNE    R3,#+2
   1144              goto error;
   \   00000040   0xD12C             BNE.N    ??HAL_SPI_Receive_IT_2
   1145            }
   1146          
   1147            if((pData == NULL) || (Size == 0))
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xBF14             ITE      NE 
   \   00000046   0x2A00             CMPNE    R2,#+0
   1148            {
   1149              errorcode = HAL_ERROR;
   \   00000048   0x2301             MOVEQ    R3,#+1
   1150              goto error;
   \   0000004A   0xD027             BEQ.N    ??HAL_SPI_Receive_IT_2
   1151            }
   1152          
   1153            /* Set the transaction information */
   1154            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   0000004C   0x2504             MOVS     R5,#+4
   \   0000004E   0xF880 0x5051      STRB     R5,[R0, #+81]
   1155            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000052   0x6543             STR      R3,[R0, #+84]
   1156            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \   00000054   0x6381             STR      R1,[R0, #+56]
   1157            hspi->RxXferSize  = Size;
   \   00000056   0x8782             STRH     R2,[R0, #+60]
   1158            hspi->RxXferCount = Size;
   \   00000058   0x87C2             STRH     R2,[R0, #+62]
   1159          
   1160            /* Init field not used in handle to zero */
   1161            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \   0000005A   0x6303             STR      R3,[R0, #+48]
   1162            hspi->TxXferSize  = 0U;
   \   0000005C   0x8683             STRH     R3,[R0, #+52]
   1163            hspi->TxXferCount = 0U;
   \   0000005E   0x86C3             STRH     R3,[R0, #+54]
   1164            hspi->TxISR       = NULL;
   \   00000060   0x6443             STR      R3,[R0, #+68]
   1165          
   1166            /* Set the function for IT treatment */
   1167            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   00000062   0x68C1             LDR      R1,[R0, #+12]
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xBF14             ITE      NE 
   1168            {
   1169              hspi->RxISR = SPI_RxISR_16BIT;
   \   00000068   0x.... 0x....      ADRNE.W  R1,SPI_RxISR_16BIT
   1170            }
   1171            else
   1172            {
   1173              hspi->RxISR = SPI_RxISR_8BIT;
   \   0000006C   0x.... 0x....      ADREQ.W  R1,SPI_RxISR_8BIT
   \   00000070   0x6401             STR      R1,[R0, #+64]
   1174            }
   1175          
   1176            /* Configure communication direction : 1Line */
   1177            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000072   0xF5B4 0x4F00      CMP      R4,#+32768
   \   00000076   0xD104             BNE.N    ??HAL_SPI_Receive_IT_3
   1178            {
   1179              SPI_1LINE_RX(hspi);
   \   00000078   0x6801             LDR      R1,[R0, #+0]
   \   0000007A   0x680A             LDR      R2,[R1, #+0]
   \   0000007C   0xF422 0x4280      BIC      R2,R2,#0x4000
   \   00000080   0x600A             STR      R2,[R1, #+0]
   1180            }
   1181          
   1182          #if (USE_SPI_CRC != 0U)
   1183            /* Reset CRC Calculation */
   1184            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1185            {
   1186              SPI_RESET_CRC(hspi);
   1187            }
   1188          #endif /* USE_SPI_CRC */
   1189          
   1190            /* Enable TXE and ERR interrupt */
   1191            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \   00000082   0x6801             LDR      R1,[R0, #+0]
   \   00000084   0x684A             LDR      R2,[R1, #+4]
   \   00000086   0xF042 0x0260      ORR      R2,R2,#0x60
   \   0000008A   0x604A             STR      R2,[R1, #+4]
   1192          
   1193            /* Note : The SPI must be enabled after unlocking current process
   1194                      to avoid the risk of SPI interrupt handle execution before current
   1195                      process unlock */
   1196          
   1197            /* Check if the SPI is already enabled */
   1198            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0x680A             LDR      R2,[R1, #+0]
   \   00000090   0x0652             LSLS     R2,R2,#+25
   \   00000092   0xD403             BMI.N    ??HAL_SPI_Receive_IT_2
   1199            {
   1200              /* Enable SPI peripheral */
   1201              __HAL_SPI_ENABLE(hspi);
   \   00000094   0x680A             LDR      R2,[R1, #+0]
   \   00000096   0xF042 0x0240      ORR      R2,R2,#0x40
   \   0000009A   0x600A             STR      R2,[R1, #+0]
   1202            }
   1203          
   1204          error :
   1205            /* Process Unlocked */
   1206            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xF880 0x1050      STRB     R1,[R0, #+80]
   1207            return errorcode;
   \   000000A2   0x4618             MOV      R0,R3
   \   000000A4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1208          }
   1209          
   1210          /**
   1211            * @brief  Transmit and Receive an amount of data in non-blocking mode with Interrupt.
   1212            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1213            *               the configuration information for SPI module.
   1214            * @param  pTxData pointer to transmission data buffer
   1215            * @param  pRxData pointer to reception data buffer
   1216            * @param  Size amount of data to be sent and received
   1217            * @retval HAL status
   1218            */

   \                                 In section .text, align 2, keep-with-next
   1219          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1220          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x461C             MOV      R4,R3
   1221            uint32_t tmp = 0U, tmp1 = 0U;
   1222            HAL_StatusTypeDef errorcode = HAL_OK;
   1223          
   1224            /* Check Direction parameter */
   1225            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1226          
   1227            /* Process locked */
   1228            __HAL_LOCK(hspi);
   \   00000004   0xF890 0x5050      LDRB     R5,[R0, #+80]
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x2D01             CMP      R5,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \   00000012   0x2501             MOVS     R5,#+1
   \   00000014   0xF880 0x5050      STRB     R5,[R0, #+80]
   1229          
   1230            tmp  = hspi->State;
   \   00000018   0xF890 0x5051      LDRB     R5,[R0, #+81]
   1231            tmp1 = hspi->Init.Mode;
   1232            
   1233            if(!((tmp == HAL_SPI_STATE_READY) || \
   1234              ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD009             BEQ.N    ??HAL_SPI_TransmitReceive_IT_1
   \   00000020   0x6846             LDR      R6,[R0, #+4]
   \   00000022   0xF5B6 0x7F82      CMP      R6,#+260
   \   00000026   0xBF02             ITTT     EQ 
   \   00000028   0x6886             LDREQ    R6,[R0, #+8]
   \   0000002A   0x2E00             CMPEQ    R6,#+0
   \   0000002C   0x2D04             CMPEQ    R5,#+4
   \   0000002E   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_IT_1
   1235            {
   1236              errorcode = HAL_BUSY;
   \   00000030   0x2302             MOVS     R3,#+2
   1237              goto error;
   \   00000032   0xE02F             B.N      ??HAL_SPI_TransmitReceive_IT_2
   1238            }
   1239          
   1240            if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xBF18             IT       NE 
   \   00000038   0x2A00             CMPNE    R2,#+0
   \   0000003A   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_IT_3
   \   0000003C   0xB90C             CBNZ.N   R4,??HAL_SPI_TransmitReceive_IT_4
   1241            {
   1242              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \   0000003E   0x2301             MOVS     R3,#+1
   1243              goto error;
   \   00000040   0xE028             B.N      ??HAL_SPI_TransmitReceive_IT_2
   1244            }
   1245          
   1246            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1247            if(hspi->State == HAL_SPI_STATE_READY)
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \   00000042   0xF890 0x5051      LDRB     R5,[R0, #+81]
   \   00000046   0x2D01             CMP      R5,#+1
   \   00000048   0xBF04             ITT      EQ 
   1248            {
   1249              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   0000004A   0x2505             MOVEQ    R5,#+5
   \   0000004C   0xF880 0x5051      STRBEQ   R5,[R0, #+81]
   1250            }
   1251          
   1252            /* Set the transaction information */
   1253            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000050   0x6543             STR      R3,[R0, #+84]
   1254            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \   00000052   0x6301             STR      R1,[R0, #+48]
   1255            hspi->TxXferSize  = Size;
   \   00000054   0x8684             STRH     R4,[R0, #+52]
   1256            hspi->TxXferCount = Size;
   \   00000056   0x86C4             STRH     R4,[R0, #+54]
   1257            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \   00000058   0x6382             STR      R2,[R0, #+56]
   1258            hspi->RxXferSize  = Size;
   \   0000005A   0x8784             STRH     R4,[R0, #+60]
   1259            hspi->RxXferCount = Size;
   \   0000005C   0x87C4             STRH     R4,[R0, #+62]
   1260          
   1261            /* Set the function for IT treatment */
   1262            if(hspi->Init.DataSize > SPI_DATASIZE_8BIT )
   \   0000005E   0x68C1             LDR      R1,[R0, #+12]
   \   00000060   0xB129             CBZ.N    R1,??HAL_SPI_TransmitReceive_IT_5
   1263            {
   1264              hspi->RxISR     = SPI_2linesRxISR_16BIT;
   \   00000062   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_16BIT
   \   00000066   0x6401             STR      R1,[R0, #+64]
   1265              hspi->TxISR     = SPI_2linesTxISR_16BIT;
   \   00000068   0x.... 0x....      ADR.W    R1,SPI_2linesTxISR_16BIT
   \   0000006C   0xE004             B.N      ??HAL_SPI_TransmitReceive_IT_6
   1266            }
   1267            else
   1268            {
   1269              hspi->RxISR     = SPI_2linesRxISR_8BIT;
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \   0000006E   0x.... 0x....      ADR.W    R1,SPI_2linesRxISR_8BIT
   \   00000072   0x6401             STR      R1,[R0, #+64]
   1270              hspi->TxISR     = SPI_2linesTxISR_8BIT;
   \   00000074   0x.... 0x....      ADR.W    R1,SPI_2linesTxISR_8BIT
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \   00000078   0x6441             STR      R1,[R0, #+68]
   1271            }
   1272          
   1273          #if (USE_SPI_CRC != 0U)
   1274            /* Reset CRC Calculation */
   1275            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1276            {
   1277              SPI_RESET_CRC(hspi);
   1278            }
   1279          #endif /* USE_SPI_CRC */
   1280          
   1281            /* Enable TXE, RXNE and ERR interrupt */
   1282            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \   0000007A   0x6801             LDR      R1,[R0, #+0]
   \   0000007C   0x684A             LDR      R2,[R1, #+4]
   \   0000007E   0xF042 0x02E0      ORR      R2,R2,#0xE0
   \   00000082   0x604A             STR      R2,[R1, #+4]
   1283          
   1284            /* Check if the SPI is already enabled */
   1285            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \   00000084   0x6801             LDR      R1,[R0, #+0]
   \   00000086   0x680A             LDR      R2,[R1, #+0]
   \   00000088   0x0652             LSLS     R2,R2,#+25
   \   0000008A   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_IT_2
   1286            {
   1287              /* Enable SPI peripheral */
   1288              __HAL_SPI_ENABLE(hspi);
   \   0000008C   0x680A             LDR      R2,[R1, #+0]
   \   0000008E   0xF042 0x0240      ORR      R2,R2,#0x40
   \   00000092   0x600A             STR      R2,[R1, #+0]
   1289            }
   1290          
   1291          error :
   1292            /* Process Unlocked */
   1293            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0xF880 0x1050      STRB     R1,[R0, #+80]
   1294            return errorcode;
   \   0000009A   0x4618             MOV      R0,R3
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
   1295          }
   1296          
   1297          /**
   1298            * @brief  Transmit an amount of data in non-blocking mode with DMA.
   1299            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1300            *               the configuration information for SPI module.
   1301            * @param  pData pointer to data buffer
   1302            * @param  Size amount of data to be sent
   1303            * @retval HAL status
   1304            */

   \                                 In section .text, align 2, keep-with-next
   1305          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1306          {
   \                     HAL_SPI_Transmit_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1307            HAL_StatusTypeDef errorcode = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1308          
   1309            /* Check Direction parameter */
   1310            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1311          
   1312            /* Process Locked */
   1313            __HAL_LOCK(hspi);
   \   00000006   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0050      STRB     R0,[R4, #+80]
   1314          
   1315            if(hspi->State != HAL_SPI_STATE_READY)
   \   00000018   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xBF18             IT       NE 
   1316            {
   1317              errorcode = HAL_BUSY;
   \   00000020   0x2502             MOVNE    R5,#+2
   1318              goto error;
   \   00000022   0xD139             BNE.N    ??HAL_SPI_Transmit_DMA_1
   1319            }
   1320          
   1321            if((pData == NULL) || (Size == 0))
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xBF14             ITE      NE 
   \   00000028   0x2A00             CMPNE    R2,#+0
   1322            {
   1323              errorcode = HAL_ERROR;
   \   0000002A   0x2501             MOVEQ    R5,#+1
   1324              goto error;
   \   0000002C   0xD034             BEQ.N    ??HAL_SPI_Transmit_DMA_1
   1325            }
   1326          
   1327            /* Set the transaction information */
   1328            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xF884 0x0051      STRB     R0,[R4, #+81]
   1329            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000034   0x6565             STR      R5,[R4, #+84]
   1330            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \   00000036   0x6321             STR      R1,[R4, #+48]
   1331            hspi->TxXferSize  = Size;
   \   00000038   0x86A2             STRH     R2,[R4, #+52]
   1332            hspi->TxXferCount = Size;
   \   0000003A   0x86E2             STRH     R2,[R4, #+54]
   1333          
   1334            /* Init field not used in handle to zero */
   1335            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \   0000003C   0x63A5             STR      R5,[R4, #+56]
   1336            hspi->TxISR       = NULL;
   \   0000003E   0x6465             STR      R5,[R4, #+68]
   1337            hspi->RxISR       = NULL;
   \   00000040   0x6425             STR      R5,[R4, #+64]
   1338            hspi->RxXferSize  = 0U;
   \   00000042   0x87A5             STRH     R5,[R4, #+60]
   1339            hspi->RxXferCount = 0U;
   \   00000044   0x87E5             STRH     R5,[R4, #+62]
   1340          
   1341            /* Configure communication direction : 1Line */
   1342            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000046   0x68A0             LDR      R0,[R4, #+8]
   \   00000048   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004C   0xD104             BNE.N    ??HAL_SPI_Transmit_DMA_2
   1343            {
   1344              SPI_1LINE_TX(hspi);
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   00000056   0x6001             STR      R1,[R0, #+0]
   1345            }
   1346          
   1347          #if (USE_SPI_CRC != 0U)
   1348            /* Reset CRC Calculation */
   1349            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1350            {
   1351              SPI_RESET_CRC(hspi);
   1352            }
   1353          #endif /* USE_SPI_CRC */
   1354          
   1355            /* Set the SPI TxDMA Half transfer complete callback */
   1356            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \   00000058   0x6CA1             LDR      R1,[R4, #+72]
   \   0000005A   0x.... 0x....      ADR.W    R0,SPI_DMAHalfTransmitCplt
   \   0000005E   0x6408             STR      R0,[R1, #+64]
   1357          
   1358            /* Set the SPI TxDMA transfer complete callback */
   1359            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \   00000060   0x6CA1             LDR      R1,[R4, #+72]
   \   00000062   0x.... 0x....      ADR.W    R0,SPI_DMATransmitCplt
   \   00000066   0x63C8             STR      R0,[R1, #+60]
   1360          
   1361            /* Set the DMA error callback */
   1362            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \   00000068   0x6CA1             LDR      R1,[R4, #+72]
   \   0000006A   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   0000006E   0x64C8             STR      R0,[R1, #+76]
   1363          
   1364            /* Set the DMA AbortCpltCallback */
   1365            hspi->hdmatx->XferAbortCallback = NULL;
   \   00000070   0x.... 0x....      BL       ?Subroutine9
   1366          
   1367            /* Enable the Tx DMA Stream */
   1368            HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   1369          
   1370            /* Check if the SPI is already enabled */
   1371            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??CrossCallReturnLabel_8: (+1)
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x0649             LSLS     R1,R1,#+25
   \   0000007A   0xD403             BMI.N    ??HAL_SPI_Transmit_DMA_3
   1372            {
   1373              /* Enable SPI peripheral */
   1374              __HAL_SPI_ENABLE(hspi);
   \   0000007C   0x6801             LDR      R1,[R0, #+0]
   \   0000007E   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000082   0x6001             STR      R1,[R0, #+0]
   1375            }
   1376          
   1377            /* Enable the SPI Error Interrupt Bit */
   1378            SET_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6841             LDR      R1,[R0, #+4]
   \   00000088   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000008C   0x6041             STR      R1,[R0, #+4]
   1379          
   1380            /* Enable Tx DMA Request */
   1381            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x6841             LDR      R1,[R0, #+4]
   \   00000092   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000096   0x6041             STR      R1,[R0, #+4]
   1382          
   1383          error :
   1384            /* Process Unlocked */
   1385            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \   00000098   0x....             B.N      ?Subroutine1
   1386            return errorcode;
   1387          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF884 0x0050      STRB     R0,[R4, #+80]
   \   00000006   0x4628             MOV      R0,R5
   \   00000008   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \   00000000   0x6CA1             LDR      R1,[R4, #+72]
   \   00000002   0x650D             STR      R5,[R1, #+80]
   \   00000004   0x8EE3             LDRH     R3,[R4, #+54]
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6B21             LDR      R1,[R4, #+48]
   \   0000000A   0xF100 0x020C      ADD      R2,R0,#+12
   \   0000000E   0x6CA0             LDR      R0,[R4, #+72]
   \   00000010   0x.... 0x....      B.W      HAL_DMA_Start_IT
   1388          
   1389          /**
   1390            * @brief  Receive an amount of data in non-blocking mode with DMA.
   1391            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1392            *               the configuration information for SPI module.
   1393            * @param  pData pointer to data buffer
   1394            * @note   When the CRC feature is enabled the pData Length must be Size + 1.
   1395            * @param  Size amount of data to be sent
   1396            * @retval HAL status
   1397            */

   \                                 In section .text, align 2, keep-with-next
   1398          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1399          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1400            HAL_StatusTypeDef errorcode = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1401          
   1402            if((hspi->Init.Direction == SPI_DIRECTION_2LINES)&&(hspi->Init.Mode == SPI_MODE_MASTER))
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xBF04             ITT      EQ 
   \   0000000C   0x6863             LDREQ    R3,[R4, #+4]
   \   0000000E   0xF5B3 0x7F82      CMPEQ    R3,#+260
   \   00000012   0xD109             BNE.N    ??HAL_SPI_Receive_DMA_0
   1403            {
   1404               hspi->State = HAL_SPI_STATE_BUSY_RX;
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0xF884 0x0051      STRB     R0,[R4, #+81]
   1405               /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1406               return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000022   0x4613             MOV      R3,R2
   \   00000024   0x460A             MOV      R2,R1
   \   00000026   0x....             B.N      HAL_SPI_TransmitReceive_DMA
   1407            }
   1408          
   1409            /* Process Locked */
   1410            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \   00000028   0xF894 0x3050      LDRB     R3,[R4, #+80]
   \   0000002C   0x2B01             CMP      R3,#+1
   \   0000002E   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_1
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \   00000034   0x2301             MOVS     R3,#+1
   \   00000036   0xF884 0x3050      STRB     R3,[R4, #+80]
   1411          
   1412            if(hspi->State != HAL_SPI_STATE_READY)
   \   0000003A   0xF894 0x3051      LDRB     R3,[R4, #+81]
   \   0000003E   0x2B01             CMP      R3,#+1
   \   00000040   0xBF18             IT       NE 
   1413            {
   1414              errorcode = HAL_BUSY;
   \   00000042   0x2502             MOVNE    R5,#+2
   1415              goto error;
   \   00000044   0xD132             BNE.N    ??HAL_SPI_Receive_DMA_2
   1416            }
   1417          
   1418            if((pData == NULL) || (Size == 0))
   \   00000046   0x2900             CMP      R1,#+0
   \   00000048   0xBF14             ITE      NE 
   \   0000004A   0x2A00             CMPNE    R2,#+0
   1419            {
   1420              errorcode = HAL_ERROR;
   \   0000004C   0x2501             MOVEQ    R5,#+1
   1421              goto error;
   \   0000004E   0xD02D             BEQ.N    ??HAL_SPI_Receive_DMA_2
   1422            }
   1423          
   1424            /* Set the transaction information */
   1425            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \   00000050   0x2304             MOVS     R3,#+4
   \   00000052   0xF884 0x3051      STRB     R3,[R4, #+81]
   1426            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000056   0x6565             STR      R5,[R4, #+84]
   1427            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \   00000058   0x63A1             STR      R1,[R4, #+56]
   1428            hspi->RxXferSize  = Size;
   \   0000005A   0x87A2             STRH     R2,[R4, #+60]
   1429            hspi->RxXferCount = Size;
   \   0000005C   0x87E2             STRH     R2,[R4, #+62]
   1430          
   1431            /*Init field not used in handle to zero */
   1432            hspi->RxISR       = NULL;
   \   0000005E   0x6425             STR      R5,[R4, #+64]
   1433            hspi->TxISR       = NULL;
   \   00000060   0x6465             STR      R5,[R4, #+68]
   1434            hspi->TxXferSize  = 0U;
   \   00000062   0x86A5             STRH     R5,[R4, #+52]
   1435            hspi->TxXferCount = 0U;
   \   00000064   0x86E5             STRH     R5,[R4, #+54]
   1436          
   1437            /* Configure communication direction : 1Line */
   1438            if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \   00000066   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000006A   0xD104             BNE.N    ??HAL_SPI_Receive_DMA_3
   1439            {
   1440              SPI_1LINE_RX(hspi);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x6801             LDR      R1,[R0, #+0]
   \   00000070   0xF421 0x4180      BIC      R1,R1,#0x4000
   \   00000074   0x6001             STR      R1,[R0, #+0]
   1441            }
   1442          
   1443          #if (USE_SPI_CRC != 0U)
   1444            /* Reset CRC Calculation */
   1445            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1446            {
   1447              SPI_RESET_CRC(hspi);
   1448            }
   1449          #endif /* USE_SPI_CRC */
   1450          
   1451            /* Set the SPI RxDMA Half transfer complete callback */
   1452            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \   00000076   0x6CE1             LDR      R1,[R4, #+76]
   \   00000078   0x.... 0x....      ADR.W    R0,SPI_DMAHalfReceiveCplt
   \   0000007C   0x6408             STR      R0,[R1, #+64]
   1453          
   1454            /* Set the SPI Rx DMA transfer complete callback */
   1455            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \   0000007E   0x6CE1             LDR      R1,[R4, #+76]
   \   00000080   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   00000084   0x.... 0x....      BL       ?Subroutine10
   1456          
   1457            /* Set the DMA error callback */
   1458            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   1459          
   1460           /* Set the DMA AbortCpltCallback */
   1461            hspi->hdmarx->XferAbortCallback = NULL;
   1462          
   1463            /* Enable the Rx DMA Stream */
   1464            HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   1465          
   1466            /* Check if the SPI is already enabled */
   1467            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??CrossCallReturnLabel_10: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6801             LDR      R1,[R0, #+0]
   \   0000008C   0x0649             LSLS     R1,R1,#+25
   \   0000008E   0xD403             BMI.N    ??HAL_SPI_Receive_DMA_4
   1468            {
   1469              /* Enable SPI peripheral */
   1470              __HAL_SPI_ENABLE(hspi);
   \   00000090   0x6801             LDR      R1,[R0, #+0]
   \   00000092   0xF041 0x0140      ORR      R1,R1,#0x40
   \   00000096   0x6001             STR      R1,[R0, #+0]
   1471            }
   1472          
   1473            /* Enable the SPI Error Interrupt Bit */
   1474            SET_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0x6841             LDR      R1,[R0, #+4]
   \   0000009C   0xF041 0x0120      ORR      R1,R1,#0x20
   \   000000A0   0x6041             STR      R1,[R0, #+4]
   1475          
   1476            /* Enable Rx DMA Request */
   1477            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6841             LDR      R1,[R0, #+4]
   \   000000A6   0xF041 0x0101      ORR      R1,R1,#0x1
   \   000000AA   0x6041             STR      R1,[R0, #+4]
   1478          
   1479          error:
   1480            /* Process Unlocked */
   1481            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \   000000AC                      REQUIRE ?Subroutine1
   \   000000AC                      ;; // Fall through to label ?Subroutine1
   1482            return errorcode;
   1483          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \   00000000   0x63C8             STR      R0,[R1, #+60]
   \   00000002   0x6CE1             LDR      R1,[R4, #+76]
   \   00000004   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \   00000008   0x64C8             STR      R0,[R1, #+76]
   \   0000000A   0x6CE1             LDR      R1,[R4, #+76]
   \   0000000C   0x650D             STR      R5,[R1, #+80]
   \   0000000E   0x8FE3             LDRH     R3,[R4, #+62]
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6BA2             LDR      R2,[R4, #+56]
   \   00000014   0xF100 0x010C      ADD      R1,R0,#+12
   \   00000018   0x6CE0             LDR      R0,[R4, #+76]
   \   0000001A   0x.... 0x....      B.W      HAL_DMA_Start_IT
   1484          
   1485          /**
   1486            * @brief  Transmit and Receive an amount of data in non-blocking mode with DMA.
   1487            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1488            *               the configuration information for SPI module.
   1489            * @param  pTxData pointer to transmission data buffer
   1490            * @param  pRxData pointer to reception data buffer
   1491            * @note   When the CRC feature is enabled the pRxData Length must be Size + 1
   1492            * @param  Size amount of data to be sent
   1493            * @retval HAL status
   1494            */

   \                                 In section .text, align 2, keep-with-next
   1495          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1496          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1497            uint32_t tmp = 0U, tmp1 = 0U;
   1498            HAL_StatusTypeDef errorcode = HAL_OK;
   \   00000004   0x2500             MOVS     R5,#+0
   1499          
   1500            /* Check Direction parameter */
   1501            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1502          
   1503            /* Process locked */
   1504            __HAL_LOCK(hspi);
   \   00000006   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0xF884 0x0050      STRB     R0,[R4, #+80]
   1505          
   1506            tmp  = hspi->State;
   \   00000018   0xF894 0x0051      LDRB     R0,[R4, #+81]
   1507            tmp1 = hspi->Init.Mode;
   1508            if(!((tmp == HAL_SPI_STATE_READY) ||
   1509                ((tmp1 == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp == HAL_SPI_STATE_BUSY_RX))))
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD009             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_1
   \   00000020   0x6866             LDR      R6,[R4, #+4]
   \   00000022   0xF5B6 0x7F82      CMP      R6,#+260
   \   00000026   0xBF02             ITTT     EQ 
   \   00000028   0x68A6             LDREQ    R6,[R4, #+8]
   \   0000002A   0x2E00             CMPEQ    R6,#+0
   \   0000002C   0x2804             CMPEQ    R0,#+4
   \   0000002E   0xD001             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_1
   1510            {
   1511              errorcode = HAL_BUSY;
   \   00000030   0x2502             MOVS     R5,#+2
   1512              goto error;
   \   00000032   0xE048             B.N      ??HAL_SPI_TransmitReceive_DMA_2
   1513            }
   1514          
   1515            if((pTxData == NULL ) || (pRxData == NULL ) || (Size == 0))
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xBF18             IT       NE 
   \   00000038   0x2A00             CMPNE    R2,#+0
   \   0000003A   0xD000             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_3
   \   0000003C   0xB90B             CBNZ.N   R3,??HAL_SPI_TransmitReceive_DMA_4
   1516            {
   1517              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \   0000003E   0x2501             MOVS     R5,#+1
   1518              goto error;
   \   00000040   0xE041             B.N      ??HAL_SPI_TransmitReceive_DMA_2
   1519            }
   1520          
   1521            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1522            if(hspi->State == HAL_SPI_STATE_READY)
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \   00000042   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xBF04             ITT      EQ 
   1523            {
   1524              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \   0000004A   0x2005             MOVEQ    R0,#+5
   \   0000004C   0xF884 0x0051      STRBEQ   R0,[R4, #+81]
   1525            }
   1526          
   1527            /* Set the transaction information */
   1528            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \   00000050   0x6565             STR      R5,[R4, #+84]
   1529            hspi->pTxBuffPtr  = (uint8_t*)pTxData;
   \   00000052   0x6321             STR      R1,[R4, #+48]
   1530            hspi->TxXferSize  = Size;
   \   00000054   0x86A3             STRH     R3,[R4, #+52]
   1531            hspi->TxXferCount = Size;
   \   00000056   0x86E3             STRH     R3,[R4, #+54]
   1532            hspi->pRxBuffPtr  = (uint8_t*)pRxData;
   \   00000058   0x63A2             STR      R2,[R4, #+56]
   1533            hspi->RxXferSize  = Size;
   \   0000005A   0x87A3             STRH     R3,[R4, #+60]
   1534            hspi->RxXferCount = Size;
   \   0000005C   0x87E3             STRH     R3,[R4, #+62]
   1535          
   1536            /* Init field not used in handle to zero */
   1537            hspi->RxISR       = NULL;
   \   0000005E   0x6425             STR      R5,[R4, #+64]
   1538            hspi->TxISR       = NULL;
   \   00000060   0x6465             STR      R5,[R4, #+68]
   1539          
   1540          #if (USE_SPI_CRC != 0U)
   1541            /* Reset CRC Calculation */
   1542            if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1543            {
   1544              SPI_RESET_CRC(hspi);
   1545            }
   1546          #endif /* USE_SPI_CRC */
   1547          
   1548            /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
   1549            if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \   00000062   0x6CE0             LDR      R0,[R4, #+76]
   \   00000064   0xF894 0x1051      LDRB     R1,[R4, #+81]
   \   00000068   0x2904             CMP      R1,#+4
   \   0000006A   0xD105             BNE.N    ??HAL_SPI_TransmitReceive_DMA_5
   1550            {
   1551              /* Set the SPI Rx DMA Half transfer complete callback */
   1552              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \   0000006C   0x.... 0x....      ADR.W    R1,SPI_DMAHalfReceiveCplt
   \   00000070   0x6401             STR      R1,[R0, #+64]
   1553              hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
   \   00000072   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \   00000076   0xE004             B.N      ??HAL_SPI_TransmitReceive_DMA_6
   1554            }
   1555            else
   1556            {
   1557              /* Set the SPI Tx/Rx DMA Half transfer complete callback */
   1558              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \   00000078   0x.... 0x....      ADR.W    R1,SPI_DMAHalfTransmitReceiveCplt
   \   0000007C   0x6401             STR      R1,[R0, #+64]
   1559              hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
   \   0000007E   0x.... 0x....      ADR.W    R0,SPI_DMATransmitReceiveCplt
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \   00000082   0x6CE1             LDR      R1,[R4, #+76]
   1560            }
   \   00000084   0x.... 0x....      BL       ?Subroutine10
   1561          
   1562            /* Set the DMA error callback */
   1563            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   1564          
   1565            /* Set the DMA AbortCpltCallback */
   1566            hspi->hdmarx->XferAbortCallback = NULL;
   1567          
   1568            /* Enable the Rx DMA Stream */
   1569            HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr, hspi->RxXferCount);
   1570          
   1571            /* Enable Rx DMA Request */
   1572            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \                     ??CrossCallReturnLabel_9: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6841             LDR      R1,[R0, #+4]
   \   0000008C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000090   0x6041             STR      R1,[R0, #+4]
   1573          
   1574            /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1575            is performed in DMA reception complete callback  */
   1576            hspi->hdmatx->XferHalfCpltCallback = NULL;
   \   00000092   0x6CA1             LDR      R1,[R4, #+72]
   \   00000094   0x640D             STR      R5,[R1, #+64]
   1577            hspi->hdmatx->XferCpltCallback     = NULL;
   \   00000096   0x6CA1             LDR      R1,[R4, #+72]
   \   00000098   0x63CD             STR      R5,[R1, #+60]
   1578            hspi->hdmatx->XferErrorCallback    = NULL;
   \   0000009A   0x6CA1             LDR      R1,[R4, #+72]
   \   0000009C   0x64CD             STR      R5,[R1, #+76]
   1579            hspi->hdmatx->XferAbortCallback    = NULL;
   \   0000009E   0x.... 0x....      BL       ?Subroutine9
   1580          
   1581            /* Enable the Tx DMA Stream */
   1582            HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR, hspi->TxXferCount);
   1583          
   1584            /* Check if the SPI is already enabled */
   1585            if((hspi->Instance->CR1 &SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??CrossCallReturnLabel_7: (+1)
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0x0649             LSLS     R1,R1,#+25
   \   000000A8   0xD403             BMI.N    ??HAL_SPI_TransmitReceive_DMA_7
   1586            {
   1587              /* Enable SPI peripheral */
   1588              __HAL_SPI_ENABLE(hspi);
   \   000000AA   0x6801             LDR      R1,[R0, #+0]
   \   000000AC   0xF041 0x0140      ORR      R1,R1,#0x40
   \   000000B0   0x6001             STR      R1,[R0, #+0]
   1589            }
   1590            /* Enable the SPI Error Interrupt Bit */
   1591            SET_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x6841             LDR      R1,[R0, #+4]
   \   000000B6   0xF041 0x0120      ORR      R1,R1,#0x20
   \   000000BA   0x6041             STR      R1,[R0, #+4]
   1592          
   1593            /* Enable Tx DMA Request */
   1594            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x6841             LDR      R1,[R0, #+4]
   \   000000C0   0xF041 0x0102      ORR      R1,R1,#0x2
   \   000000C4   0x6041             STR      R1,[R0, #+4]
   1595          
   1596          error :
   1597            /* Process Unlocked */
   1598            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xF884 0x0050      STRB     R0,[R4, #+80]
   1599            return errorcode;
   \   000000CC   0x4628             MOV      R0,R5
   \   000000CE   0xBD70             POP      {R4-R6,PC}       ;; return
   1600          }
   1601          
   1602          /**
   1603            * @brief  Abort ongoing transfer (blocking mode).
   1604            * @param  hspi SPI handle.
   1605            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   1606            *         started in Interrupt or DMA mode.
   1607            *         This procedure performs following operations :
   1608            *           - Disable SPI Interrupts (depending of transfer direction)
   1609            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1610            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1611            *           - Set handle State to READY
   1612            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1613            * @note   Once transfer is aborted, the __HAL_SPI_CLEAR_OVRFLAG() macro must be called in user application 
   1614            *         before starting new SPI receive process.
   1615            * @retval HAL status
   1616          */

   \                                 In section .text, align 2, keep-with-next
   1617          HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
   1618          {
   \                     HAL_SPI_Abort: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1619            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2118             MOVS     R1,#+24
   \   0000000C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000010   0xF44F 0x717A      MOV      R1,#+1000
   \   00000014   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000018   0xB082             SUB      SP,SP,#+8
   \   0000001A   0x2164             MOVS     R1,#+100
   \   0000001C   0x4348             MULS     R0,R1,R0
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   1620          
   1621            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   1622            if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6841             LDR      R1,[R0, #+4]
   \   00000024   0x0609             LSLS     R1,R1,#+24
   \   00000026   0xBF44             ITT      MI 
   1623            {
   1624              hspi->TxISR = SPI_AbortTx_ISR;
   \   00000028   0x.... 0x....      ADRMI.W  R1,SPI_AbortTx_ISR
   \   0000002C   0x6461             STRMI    R1,[R4, #+68]
   1625            }
   1626          
   1627            if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   \   0000002E   0x6841             LDR      R1,[R0, #+4]
   \   00000030   0x0649             LSLS     R1,R1,#+25
   \   00000032   0xBF44             ITT      MI 
   1628            {
   1629              hspi->RxISR = SPI_AbortRx_ISR;
   \   00000034   0x.... 0x....      ADRMI.W  R1,SPI_AbortRx_ISR
   \   00000038   0x6421             STRMI    R1,[R4, #+64]
   1630            }
   1631          
   1632            /* Clear ERRIE interrupts in case of DMA Mode */
   1633            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \   0000003A   0x6841             LDR      R1,[R0, #+4]
   \   0000003C   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000040   0x6041             STR      R1,[R0, #+4]
   1634          
   1635            /* Disable the SPI DMA Tx or SPI DMA Rx request if enabled */
   1636            if ((HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN)))
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x6841             LDR      R1,[R0, #+4]
   \   00000046   0x0789             LSLS     R1,R1,#+30
   \   00000048   0xD402             BMI.N    ??HAL_SPI_Abort_0
   \   0000004A   0x6840             LDR      R0,[R0, #+4]
   \   0000004C   0x07C0             LSLS     R0,R0,#+31
   \   0000004E   0xD529             BPL.N    ??HAL_SPI_Abort_1
   1637            {
   1638              /* Abort the SPI DMA Tx channel : use blocking DMA Abort API (no callback) */  
   1639              if(hspi->hdmatx != NULL)
   \                     ??HAL_SPI_Abort_0: (+1)
   \   00000050   0x6CA0             LDR      R0,[R4, #+72]
   \   00000052   0xB1B0             CBZ.N    R0,??HAL_SPI_Abort_2
   1640              {
   1641                /* Set the SPI DMA Abort callback :
   1642                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   1643                hspi->hdmatx->XferAbortCallback = NULL;
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6501             STR      R1,[R0, #+80]
   1644                
   1645                /* Abort DMA Tx Handle linked to SPI Peripheral */
   1646                HAL_DMA_Abort(hspi->hdmatx);
   \   00000058   0x6CA0             LDR      R0,[R4, #+72]
   \   0000005A   0x.... 0x....      BL       HAL_DMA_Abort
   1647          
   1648                /* Disable Tx DMA Request */
   1649                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6841             LDR      R1,[R0, #+4]
   \   00000062   0xF021 0x0102      BIC      R1,R1,#0x2
   \   00000066   0x6041             STR      R1,[R0, #+4]
   1650          
   1651                /* Wait until TXE flag is set */
   1652                do
   1653                {
   1654                  if(count-- == 0U)
   \                     ??HAL_SPI_Abort_3: (+1)
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x1E41             SUBS     R1,R0,#+1
   \   0000006C   0x9100             STR      R1,[SP, #+0]
   \   0000006E   0xB920             CBNZ.N   R0,??HAL_SPI_Abort_4
   1655                  {
   1656                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000070   0x6D60             LDR      R0,[R4, #+84]
   \   00000072   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000076   0x6560             STR      R0,[R4, #+84]
   1657                    break;
   \   00000078   0xE003             B.N      ??HAL_SPI_Abort_2
   1658                  }
   1659                }
   1660                while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);       
   \                     ??HAL_SPI_Abort_4: (+1)
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x6880             LDR      R0,[R0, #+8]
   \   0000007E   0x0780             LSLS     R0,R0,#+30
   \   00000080   0xD5F2             BPL.N    ??HAL_SPI_Abort_3
   1661              }
   1662              /* Abort the SPI DMA Rx channel : use blocking DMA Abort API (no callback) */
   1663              if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_Abort_2: (+1)
   \   00000082   0x6CE0             LDR      R0,[R4, #+76]
   \   00000084   0xB170             CBZ.N    R0,??HAL_SPI_Abort_1
   1664              {
   1665                /* Set the SPI DMA Abort callback :
   1666                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   1667                hspi->hdmarx->XferAbortCallback = NULL;
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6501             STR      R1,[R0, #+80]
   1668                
   1669                /* Abort DMA Rx Handle linked to SPI Peripheral */
   1670                HAL_DMA_Abort(hspi->hdmarx);
   \   0000008A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000008C   0x.... 0x....      BL       HAL_DMA_Abort
   1671          
   1672                /* Disable peripheral */
   1673                __HAL_SPI_DISABLE(hspi); 
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x6801             LDR      R1,[R0, #+0]
   \   00000094   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000098   0x6001             STR      R1,[R0, #+0]
   1674          
   1675                /* Disable Rx DMA Request */
   1676                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6841             LDR      R1,[R0, #+4]
   \   0000009E   0x0849             LSRS     R1,R1,#+1
   \   000000A0   0x0049             LSLS     R1,R1,#+1
   \   000000A2   0x6041             STR      R1,[R0, #+4]
   1677                
   1678              }
   1679            }
   1680            /* Reset Tx and Rx transfer counters */
   1681            hspi->RxXferCount = 0U;
   \                     ??HAL_SPI_Abort_1: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x87E0             STRH     R0,[R4, #+62]
   1682            hspi->TxXferCount = 0U;
   \   000000A8   0x86E0             STRH     R0,[R4, #+54]
   1683          
   1684            /* Reset errorCode */
   1685            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   000000AA   0x6560             STR      R0,[R4, #+84]
   1686          
   1687            /* Clear the Error flags in the SR register */
   1688            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   000000AC   0x9000             STR      R0,[SP, #+0]
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x68C1             LDR      R1,[R0, #+12]
   \   000000B2   0x9100             STR      R1,[SP, #+0]
   \   000000B4   0x6881             LDR      R1,[R0, #+8]
   \   000000B6   0x9100             STR      R1,[SP, #+0]
   \   000000B8   0x9900             LDR      R1,[SP, #+0]
   1689            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0x9100             STR      R1,[SP, #+0]
   \   000000BE   0x6880             LDR      R0,[R0, #+8]
   \   000000C0   0x9000             STR      R0,[SP, #+0]
   \   000000C2   0x9800             LDR      R0,[SP, #+0]
   1690          
   1691            /* Restore hspi->state to ready */
   1692            hspi->State = HAL_SPI_STATE_READY;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xF884 0x0051      STRB     R0,[R4, #+81]
   1693          
   1694            return HAL_OK;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1695          }
   1696          
   1697          /**
   1698            * @brief  Abort ongoing transfer (Interrupt mode).
   1699            * @param  hspi SPI handle.
   1700            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   1701            *         started in Interrupt or DMA mode.
   1702            *         This procedure performs following operations :
   1703            *           - Disable SPI Interrupts (depending of transfer direction)
   1704            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1705            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1706            *           - Set handle State to READY
   1707            *           - At abort completion, call user abort complete callback
   1708            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1709            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1710            * @note   Once transfer is aborted, the __HAL_SPI_CLEAR_OVRFLAG() macro must be called in user application 
   1711            *         before starting new SPI receive process.
   1712            * @retval HAL status
   1713          */

   \                                 In section .text, align 2, keep-with-next
   1714          HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
   1715          {
   \                     HAL_SPI_Abort_IT: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1716            uint32_t abortcplt;
   1717          
   1718            /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
   1719            if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x0609             LSLS     R1,R1,#+24
   \   0000000A   0xBF44             ITT      MI 
   1720            {
   1721              hspi->TxISR = SPI_AbortTx_ISR;
   \   0000000C   0x.... 0x....      ADRMI.W  R1,SPI_AbortTx_ISR
   \   00000010   0x6461             STRMI    R1,[R4, #+68]
   1722            }
   1723          
   1724            if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x0649             LSLS     R1,R1,#+25
   \   00000016   0xBF44             ITT      MI 
   1725            {
   1726              hspi->RxISR = SPI_AbortRx_ISR;
   \   00000018   0x.... 0x....      ADRMI.W  R1,SPI_AbortRx_ISR
   \   0000001C   0x6421             STRMI    R1,[R4, #+64]
   1727            }
   1728          
   1729            /* Clear ERRIE interrupts in case of DMA Mode */
   1730            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \   0000001E   0x6841             LDR      R1,[R0, #+4]
   \   00000020   0xF021 0x0120      BIC      R1,R1,#0x20
   \   00000024   0x6041             STR      R1,[R0, #+4]
   1731          
   1732            abortcplt = 1U;
   \   00000026   0x2501             MOVS     R5,#+1
   1733            
   1734            /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
   1735               before any call to DMA Abort functions */  
   1736            /* DMA Tx Handle is valid */
   1737            if(hspi->hdmatx != NULL)
   \   00000028   0x6CA0             LDR      R0,[R4, #+72]
   \   0000002A   0xB138             CBZ.N    R0,??HAL_SPI_Abort_IT_0
   1738            {
   1739              /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
   1740                 Otherwise, set it to NULL */
   1741              if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6849             LDR      R1,[R1, #+4]
   \   00000030   0x0789             LSLS     R1,R1,#+30
   \   00000032   0xBF4C             ITE      MI 
   1742              {
   1743                hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
   \   00000034   0x.... 0x....      ADRMI.W  R1,SPI_DMATxAbortCallback
   1744              }
   1745              else
   1746              {
   1747                hspi->hdmatx->XferAbortCallback = NULL;
   \   00000038   0x2100             MOVPL    R1,#+0
   \   0000003A   0x6501             STR      R1,[R0, #+80]
   1748              }
   1749            }  
   1750            /* DMA Rx Handle is valid */
   1751            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_Abort_IT_0: (+1)
   \   0000003C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000003E   0xB138             CBZ.N    R0,??HAL_SPI_Abort_IT_1
   1752            {
   1753              /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
   1754                 Otherwise, set it to NULL */
   1755              if(HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6849             LDR      R1,[R1, #+4]
   \   00000044   0x07C9             LSLS     R1,R1,#+31
   \   00000046   0xBF4C             ITE      MI 
   1756              {
   1757                hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
   \   00000048   0x.... 0x....      ADRMI.W  R1,SPI_DMARxAbortCallback
   1758              }
   1759              else
   1760              {
   1761                hspi->hdmarx->XferAbortCallback = NULL;
   \   0000004C   0x2100             MOVPL    R1,#+0
   \   0000004E   0x6501             STR      R1,[R0, #+80]
   1762              }
   1763            }
   1764          
   1765            /* Disable the SPI DMA Tx or the SPI Rx request if enabled */
   1766            if((HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN)) && (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN)))
   \                     ??HAL_SPI_Abort_IT_1: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6841             LDR      R1,[R0, #+4]
   \   00000054   0x0789             LSLS     R1,R1,#+30
   \   00000056   0xD517             BPL.N    ??HAL_SPI_Abort_IT_2
   \   00000058   0x6840             LDR      R0,[R0, #+4]
   \   0000005A   0x07C0             LSLS     R0,R0,#+31
   \   0000005C   0xD514             BPL.N    ??HAL_SPI_Abort_IT_2
   1767            {
   1768              /* Abort the SPI DMA Tx channel */
   1769              if(hspi->hdmatx != NULL)
   \   0000005E   0x6CA0             LDR      R0,[R4, #+72]
   \   00000060   0xB138             CBZ.N    R0,??HAL_SPI_Abort_IT_3
   1770              {
   1771                /* Abort DMA Tx Handle linked to SPI Peripheral */
   1772                if(HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
   \   00000062   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xBF1D             ITTTE    NE 
   1773                {
   1774                  hspi->hdmatx->XferAbortCallback = NULL;
   \   0000006A   0x2000             MOVNE    R0,#+0
   \   0000006C   0x6CA1             LDRNE    R1,[R4, #+72]
   \   0000006E   0x6508             STRNE    R0,[R1, #+80]
   1775                }
   1776                else
   1777                {
   1778                  abortcplt = 0U;
   \   00000070   0x2500             MOVEQ    R5,#+0
   1779                }
   1780              }
   1781              /* Abort the SPI DMA Rx channel */
   1782              if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_Abort_IT_3: (+1)
   \   00000072   0x6CE0             LDR      R0,[R4, #+76]
   \   00000074   0xB140             CBZ.N    R0,??HAL_SPI_Abort_IT_2
   1783              {
   1784                /* Abort DMA Rx Handle linked to SPI Peripheral */
   1785                if(HAL_DMA_Abort_IT(hspi->hdmarx)!=  HAL_OK)
   \   00000076   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   0000007A   0xB120             CBZ.N    R0,??HAL_SPI_Abort_IT_4
   1786                {
   1787                  hspi->hdmarx->XferAbortCallback = NULL;
   \   0000007C   0x6CE1             LDR      R1,[R4, #+76]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x6508             STR      R0,[R1, #+80]
   1788                  abortcplt = 1U;
   \   00000082   0x2501             MOVS     R5,#+1
   \   00000084   0xE000             B.N      ??HAL_SPI_Abort_IT_2
   1789                }
   1790                else
   1791                {
   1792                  abortcplt = 0U;
   \                     ??HAL_SPI_Abort_IT_4: (+1)
   \   00000086   0x2500             MOVS     R5,#+0
   1793                }
   1794              }
   1795            }
   1796          
   1797            /* Disable the SPI DMA Tx or the SPI Rx request if enabled */
   1798            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \                     ??HAL_SPI_Abort_IT_2: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x6840             LDR      R0,[R0, #+4]
   \   0000008C   0x0780             LSLS     R0,R0,#+30
   \   0000008E   0xD509             BPL.N    ??HAL_SPI_Abort_IT_5
   1799            {
   1800              /* Abort the SPI DMA Tx channel */
   1801              if(hspi->hdmatx != NULL)
   \   00000090   0x6CA0             LDR      R0,[R4, #+72]
   \   00000092   0xB138             CBZ.N    R0,??HAL_SPI_Abort_IT_5
   1802              {
   1803                /* Abort DMA Tx Handle linked to SPI Peripheral */
   1804                if(HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
   \   00000094   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xBF1D             ITTTE    NE 
   1805                {
   1806                  hspi->hdmatx->XferAbortCallback = NULL;
   \   0000009C   0x2000             MOVNE    R0,#+0
   \   0000009E   0x6CA1             LDRNE    R1,[R4, #+72]
   \   000000A0   0x6508             STRNE    R0,[R1, #+80]
   1807                }
   1808                else
   1809                {
   1810                  abortcplt = 0U;
   \   000000A2   0x2500             MOVEQ    R5,#+0
   1811                }
   1812              }
   1813            }
   1814            /* Disable the SPI DMA Tx or the SPI Rx request if enabled */
   1815            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \                     ??HAL_SPI_Abort_IT_5: (+1)
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x6840             LDR      R0,[R0, #+4]
   \   000000A8   0x07C0             LSLS     R0,R0,#+31
   \   000000AA   0xD507             BPL.N    ??HAL_SPI_Abort_IT_6
   1816            {
   1817              /* Abort the SPI DMA Rx channel */
   1818              if(hspi->hdmarx != NULL)
   \   000000AC   0x6CE0             LDR      R0,[R4, #+76]
   \   000000AE   0xB128             CBZ.N    R0,??HAL_SPI_Abort_IT_6
   1819              {
   1820                /* Abort DMA Rx Handle linked to SPI Peripheral */
   1821                if(HAL_DMA_Abort_IT(hspi->hdmarx)!=  HAL_OK)
   \   000000B0   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \   000000B4   0xB1B8             CBZ.N    R0,??HAL_SPI_Abort_IT_7
   1822                {
   1823                  hspi->hdmarx->XferAbortCallback = NULL;
   \   000000B6   0x6CE1             LDR      R1,[R4, #+76]
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x6508             STR      R0,[R1, #+80]
   1824                }
   1825                else
   1826                {
   1827                  abortcplt = 0U;
   1828                }
   1829              }
   1830            }
   1831          
   1832            if(abortcplt == 1U)
   \                     ??HAL_SPI_Abort_IT_6: (+1)
   \   000000BC   0xB19D             CBZ.N    R5,??HAL_SPI_Abort_IT_7
   1833            {
   1834              /* Reset Tx and Rx transfer counters */
   1835              hspi->RxXferCount = 0U;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x87E0             STRH     R0,[R4, #+62]
   1836              hspi->TxXferCount = 0U;
   \   000000C2   0x86E0             STRH     R0,[R4, #+54]
   1837          
   1838              /* Reset errorCode */
   1839              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \   000000C4   0x6560             STR      R0,[R4, #+84]
   1840          
   1841              /* Clear the Error flags in the SR register */
   1842              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   000000C6   0x9000             STR      R0,[SP, #+0]
   \   000000C8   0x6820             LDR      R0,[R4, #+0]
   \   000000CA   0x68C1             LDR      R1,[R0, #+12]
   \   000000CC   0x9100             STR      R1,[SP, #+0]
   \   000000CE   0x6881             LDR      R1,[R0, #+8]
   \   000000D0   0x9100             STR      R1,[SP, #+0]
   \   000000D2   0x9900             LDR      R1,[SP, #+0]
   1843              __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x9100             STR      R1,[SP, #+0]
   \   000000D8   0x6880             LDR      R0,[R0, #+8]
   \   000000DA   0x9000             STR      R0,[SP, #+0]
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
   1844          
   1845              /* Restore hspi->State to Ready */
   1846              hspi->State = HAL_SPI_STATE_READY;
   \   000000DE   0x.... 0x....      BL       ?Subroutine8
   1847          
   1848              /* As no DMA to be aborted, call directly user Abort complete callback */
   1849              HAL_SPI_AbortCpltCallback(hspi);
   1850            }
   \                     ??CrossCallReturnLabel_3: (+1)
   \   000000E2   0x.... 0x....      BL       HAL_SPI_AbortCpltCallback
   1851            return HAL_OK;
   \                     ??HAL_SPI_Abort_IT_7: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1852          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF884 0x0051      STRB     R0,[R4, #+81]
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x4770             BX       LR
   1853          
   1854          /**
   1855            * @brief  Pause the DMA Transfer.
   1856            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1857            *               the configuration information for the specified SPI module.
   1858            * @retval HAL status
   1859            */

   \                                 In section .text, align 2, keep-with-next
   1860          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   1861          {
   1862            /* Process Locked */
   1863            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAPause: (+1)
   \   00000000   0xF890 0x1050      LDRB     R1,[R0, #+80]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1050      STRB     R1,[R0, #+80]
   1864          
   1865            /* Disable the SPI DMA Tx & Rx requests */
   1866            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0x0892             LSRS     R2,R2,#+2
   \   00000018   0x0092             LSLS     R2,R2,#+2
   \   0000001A   0x....             B.N      ?Subroutine2
   1867          
   1868            /* Process Unlocked */
   1869            __HAL_UNLOCK(hspi);
   1870          
   1871            return HAL_OK;
   1872          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \   00000000   0x604A             STR      R2,[R1, #+4]
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0xF880 0x1050      STRB     R1,[R0, #+80]
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x4770             BX       LR               ;; return
   1873          
   1874          /**
   1875            * @brief  Resume the DMA Transfer.
   1876            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1877            *               the configuration information for the specified SPI module.
   1878            * @retval HAL status
   1879            */

   \                                 In section .text, align 2, keep-with-next
   1880          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   1881          {
   1882            /* Process Locked */
   1883            __HAL_LOCK(hspi);
   \                     HAL_SPI_DMAResume: (+1)
   \   00000000   0xF890 0x1050      LDRB     R1,[R0, #+80]
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x4770             BX       LR
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF880 0x1050      STRB     R1,[R0, #+80]
   1884          
   1885            /* Enable the SPI DMA Tx & Rx requests */
   1886            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF042 0x0203      ORR      R2,R2,#0x3
   \   0000001A                      REQUIRE ?Subroutine2
   \   0000001A                      ;; // Fall through to label ?Subroutine2
   1887          
   1888            /* Process Unlocked */
   1889            __HAL_UNLOCK(hspi);
   1890          
   1891            return HAL_OK;
   1892          }
   1893          
   1894          /**
   1895            * @brief Stop the DMA Transfer.
   1896            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1897            *               the configuration information for the specified SPI module.
   1898            * @retval HAL status
   1899            */

   \                                 In section .text, align 2, keep-with-next
   1900          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   1901          {
   \                     HAL_SPI_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1902            /* The Lock is not implemented on this API to allow the user application
   1903               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   1904               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1905               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   1906               */
   1907          
   1908            /* Abort the SPI DMA tx Stream */
   1909            if(hspi->hdmatx != NULL)
   \   00000004   0x6CA0             LDR      R0,[R4, #+72]
   \   00000006   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_0
   1910            {
   1911              HAL_DMA_Abort(hspi->hdmatx);
   \   00000008   0x.... 0x....      BL       HAL_DMA_Abort
   1912            }
   1913            /* Abort the SPI DMA rx Stream */
   1914            if(hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \   0000000C   0x6CE0             LDR      R0,[R4, #+76]
   \   0000000E   0xB108             CBZ.N    R0,??HAL_SPI_DMAStop_1
   1915            {
   1916              HAL_DMA_Abort(hspi->hdmarx);
   \   00000010   0x.... 0x....      BL       HAL_DMA_Abort
   1917            }
   1918          
   1919            /* Disable the SPI DMA Tx & Rx requests */
   1920            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6841             LDR      R1,[R0, #+4]
   \   00000018   0x0889             LSRS     R1,R1,#+2
   \   0000001A   0x0089             LSLS     R1,R1,#+2
   \   0000001C   0x6041             STR      R1,[R0, #+4]
   1921            hspi->State = HAL_SPI_STATE_READY;
   \   0000001E                      REQUIRE ?Subroutine0
   \   0000001E                      ;; // Fall through to label ?Subroutine0
   1922            return HAL_OK;
   1923          }
   1924          
   1925          /**
   1926            * @brief  Handle SPI interrupt request.
   1927            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1928            *               the configuration information for the specified SPI module.
   1929            * @retval None
   1930            */

   \                                 In section .text, align 2, keep-with-next
   1931          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   1932          {
   \                     HAL_SPI_IRQHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1933            uint32_t itsource = hspi->Instance->CR2;
   \   00000004   0x6821             LDR      R1,[R4, #+0]
   \   00000006   0x6848             LDR      R0,[R1, #+4]
   1934            uint32_t itflag   = hspi->Instance->SR;
   \   00000008   0x688A             LDR      R2,[R1, #+8]
   1935          
   1936            /* SPI in mode Receiver ----------------------------------------------------*/
   1937            if(((itflag & SPI_FLAG_OVR) == RESET) &&
   1938               ((itflag & SPI_FLAG_RXNE) != RESET) && ((itsource & SPI_IT_RXNE) != RESET))
   \   0000000A   0xF002 0x0341      AND      R3,R2,#0x41
   \   0000000E   0x2B01             CMP      R3,#+1
   \   00000010   0xD106             BNE.N    ??HAL_SPI_IRQHandler_0
   \   00000012   0x0643             LSLS     R3,R0,#+25
   \   00000014   0xD504             BPL.N    ??HAL_SPI_IRQHandler_0
   1939            {
   1940              hspi->RxISR(hspi);
   \   00000016   0x6C21             LDR      R1,[R4, #+64]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001E   0x4708             BX       R1
   1941              return;
   1942            }
   1943          
   1944            /* SPI in mode Transmitter -------------------------------------------------*/
   1945            if(((itflag & SPI_FLAG_TXE) != RESET) && ((itsource & SPI_IT_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \   00000020   0x0793             LSLS     R3,R2,#+30
   \   00000022   0xD506             BPL.N    ??HAL_SPI_IRQHandler_1
   \   00000024   0x0603             LSLS     R3,R0,#+24
   \   00000026   0xD504             BPL.N    ??HAL_SPI_IRQHandler_1
   1946            {
   1947              hspi->TxISR(hspi);
   \   00000028   0x6C61             LDR      R1,[R4, #+68]
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000030   0x4708             BX       R1
   1948              return;
   1949            }
   1950          
   1951            /* SPI in Error Treatment --------------------------------------------------*/
   1952            if(((itflag & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE)) != RESET) && ((itsource & SPI_IT_ERR) != RESET))
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \   00000032   0xF412 0x7FB0      TST      R2,#0x160
   \   00000036   0xD05A             BEQ.N    ??HAL_SPI_IRQHandler_2
   \   00000038   0x0683             LSLS     R3,R0,#+26
   \   0000003A   0xD558             BPL.N    ??HAL_SPI_IRQHandler_2
   1953            {
   1954              /* SPI Overrun error interrupt occurred ----------------------------------*/
   1955              if((itflag & SPI_FLAG_OVR) != RESET)
   \   0000003C   0x0653             LSLS     R3,R2,#+25
   \   0000003E   0xD50E             BPL.N    ??HAL_SPI_IRQHandler_3
   1956              {
   1957                if(hspi->State != HAL_SPI_STATE_BUSY_TX)
   \   00000040   0xF894 0x3051      LDRB     R3,[R4, #+81]
   \   00000044   0x2B03             CMP      R3,#+3
   \   00000046   0xD047             BEQ.N    ??HAL_SPI_IRQHandler_4
   1958                {
   1959                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
   \   00000048   0x6D63             LDR      R3,[R4, #+84]
   \   0000004A   0xF043 0x0304      ORR      R3,R3,#0x4
   \   0000004E   0x6563             STR      R3,[R4, #+84]
   1960                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   00000050   0x2300             MOVS     R3,#+0
   \   00000052   0x9300             STR      R3,[SP, #+0]
   \   00000054   0x68CB             LDR      R3,[R1, #+12]
   \   00000056   0x9300             STR      R3,[SP, #+0]
   \   00000058   0x688B             LDR      R3,[R1, #+8]
   \   0000005A   0x9300             STR      R3,[SP, #+0]
   \   0000005C   0x9B00             LDR      R3,[SP, #+0]
   1961                }
   1962                else
   1963                {
   1964                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   1965                  return;
   1966                }
   1967              }
   1968          
   1969              /* SPI Mode Fault error interrupt occurred -------------------------------*/
   1970              if((itflag & SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \   0000005E   0x0693             LSLS     R3,R2,#+26
   \   00000060   0xD50C             BPL.N    ??HAL_SPI_IRQHandler_5
   1971              {
   1972                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
   \   00000062   0x6D63             LDR      R3,[R4, #+84]
   \   00000064   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000068   0x6563             STR      R3,[R4, #+84]
   1973                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x9300             STR      R3,[SP, #+0]
   \   0000006E   0x688B             LDR      R3,[R1, #+8]
   \   00000070   0x9300             STR      R3,[SP, #+0]
   \   00000072   0x680B             LDR      R3,[R1, #+0]
   \   00000074   0xF023 0x0340      BIC      R3,R3,#0x40
   \   00000078   0x600B             STR      R3,[R1, #+0]
   \   0000007A   0x9900             LDR      R1,[SP, #+0]
   1974              }
   1975          
   1976              /* SPI Frame error interrupt occurred ------------------------------------*/
   1977              if((itflag & SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \   0000007C   0x05D1             LSLS     R1,R2,#+23
   \   0000007E   0xD509             BPL.N    ??HAL_SPI_IRQHandler_6
   1978              {
   1979                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
   \   00000080   0x6D61             LDR      R1,[R4, #+84]
   \   00000082   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000086   0x6561             STR      R1,[R4, #+84]
   1980                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x9100             STR      R1,[SP, #+0]
   \   0000008C   0x6821             LDR      R1,[R4, #+0]
   \   0000008E   0x6889             LDR      R1,[R1, #+8]
   \   00000090   0x9100             STR      R1,[SP, #+0]
   \   00000092   0x9900             LDR      R1,[SP, #+0]
   1981              }
   1982          
   1983              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_IRQHandler_6: (+1)
   \   00000094   0x6D61             LDR      R1,[R4, #+84]
   \   00000096   0xB351             CBZ.N    R1,??HAL_SPI_IRQHandler_2
   1984              {
   1985                /* Disable all interrupts */
   1986                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x684A             LDR      R2,[R1, #+4]
   \   0000009C   0xF022 0x02E0      BIC      R2,R2,#0xE0
   \   000000A0   0x604A             STR      R2,[R1, #+4]
   1987          
   1988                hspi->State = HAL_SPI_STATE_READY;
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0xF884 0x1051      STRB     R1,[R4, #+81]
   1989                /* Disable the SPI DMA requests if enabled */
   1990                if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN))||(HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
   \   000000A8   0xF010 0x0F03      TST      R0,#0x3
   \   000000AC   0xD01C             BEQ.N    ??HAL_SPI_IRQHandler_7
   1991                {
   1992                  CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   1993          
   1994                  /* Abort the SPI DMA Rx channel */
   1995                  if(hspi->hdmarx != NULL)
   \   000000B0   0x.... 0x....      ADR.W    R5,SPI_DMAAbortOnError
   \   000000B4   0x6841             LDR      R1,[R0, #+4]
   \   000000B6   0x0889             LSRS     R1,R1,#+2
   \   000000B8   0x0089             LSLS     R1,R1,#+2
   \   000000BA   0x6041             STR      R1,[R0, #+4]
   \   000000BC   0x6CE0             LDR      R0,[R4, #+76]
   \   000000BE   0xB118             CBZ.N    R0,??HAL_SPI_IRQHandler_8
   1996                  {
   1997                    /* Set the SPI DMA Abort callback :
   1998                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   1999                    hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
   \   000000C0   0x6505             STR      R5,[R0, #+80]
   2000                    HAL_DMA_Abort_IT(hspi->hdmarx);
   \   000000C2   0x6CE0             LDR      R0,[R4, #+76]
   \   000000C4   0x.... 0x....      BL       HAL_DMA_Abort_IT
   2001                  }
   2002                  /* Abort the SPI DMA Tx channel */
   2003                  if(hspi->hdmatx != NULL)
   \                     ??HAL_SPI_IRQHandler_8: (+1)
   \   000000C8   0x6CA0             LDR      R0,[R4, #+72]
   \   000000CA   0xB180             CBZ.N    R0,??HAL_SPI_IRQHandler_2
   2004                  {
   2005                    /* Set the SPI DMA Abort callback :
   2006                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   2007                    hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
   \   000000CC   0x6505             STR      R5,[R0, #+80]
   2008                    HAL_DMA_Abort_IT(hspi->hdmatx);
   \   000000CE   0x6CA0             LDR      R0,[R4, #+72]
   \   000000D0   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   000000D4   0x.... 0x....      B.W      HAL_DMA_Abort_IT
   2009                  }
   2010                }
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x9000             STR      R0,[SP, #+0]
   \   000000DC   0x68C8             LDR      R0,[R1, #+12]
   \   000000DE   0x9000             STR      R0,[SP, #+0]
   \   000000E0   0x6888             LDR      R0,[R1, #+8]
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0xBD31             POP      {R0,R4,R5,PC}
   2011                else
   2012                {
   2013                  /* Call user error callback */
   2014                  HAL_SPI_ErrorCallback(hspi);
   \                     ??HAL_SPI_IRQHandler_7: (+1)
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2015                }
   2016              }
   2017              return;
   2018            }
   2019          }
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \   000000EE   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2020          
   2021          /**
   2022            * @brief Tx Transfer completed callback.
   2023            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2024            *               the configuration information for SPI module.
   2025            * @retval None
   2026            */

   \                                 In section .text, align 2, keep-with-next
   2027          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   2028          {
   2029            /* Prevent unused argument(s) compilation warning */
   2030            UNUSED(hspi);
   2031            /* NOTE : This function should not be modified, when the callback is needed,
   2032                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   2033            */
   2034          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2035          
   2036          /**
   2037            * @brief Rx Transfer completed callback.
   2038            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2039            *               the configuration information for SPI module.
   2040            * @retval None
   2041            */

   \                                 In section .text, align 2, keep-with-next
   2042          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   2043          {
   2044            /* Prevent unused argument(s) compilation warning */
   2045            UNUSED(hspi);
   2046            /* NOTE : This function should not be modified, when the callback is needed,
   2047                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   2048            */
   2049          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2050          
   2051          /**
   2052            * @brief Tx and Rx Transfer completed callback.
   2053            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2054            *               the configuration information for SPI module.
   2055            * @retval None
   2056            */

   \                                 In section .text, align 2, keep-with-next
   2057          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   2058          {
   2059            /* Prevent unused argument(s) compilation warning */
   2060            UNUSED(hspi);
   2061            /* NOTE : This function should not be modified, when the callback is needed,
   2062                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   2063            */
   2064          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2065          
   2066          /**
   2067            * @brief Tx Half Transfer completed callback.
   2068            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2069            *               the configuration information for SPI module.
   2070            * @retval None
   2071            */

   \                                 In section .text, align 2, keep-with-next
   2072          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2073          {
   2074            /* Prevent unused argument(s) compilation warning */
   2075            UNUSED(hspi);
   2076            /* NOTE : This function should not be modified, when the callback is needed,
   2077                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   2078            */
   2079          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2080          
   2081          /**
   2082            * @brief Rx Half Transfer completed callback.
   2083            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2084            *               the configuration information for SPI module.
   2085            * @retval None
   2086            */

   \                                 In section .text, align 2, keep-with-next
   2087          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2088          {
   2089            /* Prevent unused argument(s) compilation warning */
   2090            UNUSED(hspi);
   2091            /* NOTE : This function should not be modified, when the callback is needed,
   2092                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   2093            */
   2094          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2095          
   2096          /**
   2097            * @brief Tx and Rx Half Transfer callback.
   2098            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2099            *               the configuration information for SPI module.
   2100            * @retval None
   2101            */

   \                                 In section .text, align 2, keep-with-next
   2102          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2103          {
   2104            /* Prevent unused argument(s) compilation warning */
   2105            UNUSED(hspi);
   2106            /* NOTE : This function should not be modified, when the callback is needed,
   2107                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   2108            */
   2109          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2110          
   2111          /**
   2112            * @brief SPI error callback.
   2113            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2114            *               the configuration information for SPI module.
   2115            * @retval None
   2116            */

   \                                 In section .text, align 2, keep-with-next
   2117           __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   2118          {
   2119            /* Prevent unused argument(s) compilation warning */
   2120            UNUSED(hspi);
   2121            /* NOTE : This function should not be modified, when the callback is needed,
   2122                      the HAL_SPI_ErrorCallback should be implemented in the user file
   2123             */
   2124            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   2125                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   2126            */
   2127          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2128          
   2129          /**
   2130            * @brief  SPI Abort Complete callback.
   2131            * @param  hspi SPI handle.
   2132            * @retval None
   2133            */

   \                                 In section .text, align 2, keep-with-next
   2134          __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
   2135          {
   2136            /* Prevent unused argument(s) compilation warning */
   2137            UNUSED(hspi);
   2138          
   2139            /* NOTE : This function should not be modified, when the callback is needed,
   2140                      the HAL_SPI_AbortCpltCallback can be implemented in the user file.
   2141             */
   2142          }
   \                     HAL_SPI_AbortCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2143          
   2144          /**
   2145            * @}
   2146            */
   2147          
   2148          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   2149            * @brief   SPI control functions
   2150            *
   2151          @verbatim
   2152           ===============================================================================
   2153                                ##### Peripheral State and Errors functions #####
   2154           ===============================================================================
   2155              [..]
   2156              This subsection provides a set of functions allowing to control the SPI.
   2157               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   2158               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   2159          @endverbatim
   2160            * @{
   2161            */
   2162          
   2163          /**
   2164            * @brief  Return the SPI handle state.
   2165            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2166            *               the configuration information for SPI module.
   2167            * @retval SPI state
   2168            */

   \                                 In section .text, align 2, keep-with-next
   2169          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   2170          {
   2171            /* Return SPI handle state */
   2172            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \   00000000   0xF890 0x0051      LDRB     R0,[R0, #+81]
   \   00000004   0x4770             BX       LR               ;; return
   2173          }
   2174          
   2175          /**
   2176            * @brief  Return the SPI error code.
   2177            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2178            *               the configuration information for SPI module.
   2179            * @retval SPI error code in bitmap format
   2180            */

   \                                 In section .text, align 2, keep-with-next
   2181          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   2182          {
   2183            /* Return SPI ErrorCode */
   2184            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \   00000000   0x6D40             LDR      R0,[R0, #+84]
   \   00000002   0x4770             BX       LR               ;; return
   2185          }
   2186          
   2187          /**
   2188            * @}
   2189            */
   2190          
   2191          /**
   2192            * @}
   2193            */
   2194          
   2195          /** @addtogroup SPI_Private_Functions
   2196            * @brief   Private functions
   2197            * @{
   2198            */
   2199          
   2200          /**
   2201            * @brief DMA SPI transmit process complete callback.
   2202            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2203            *               the configuration information for the specified DMA module.
   2204            * @retval None
   2205            */

   \                                 In section .text, align 4, keep-with-next
   2206          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   2207          {
   \                     SPI_DMATransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   2208            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BAC             LDR      R4,[R5, #+56]
   2209            uint32_t tickstart = 0U;
   2210          
   2211            /* Init tickstart for timeout managment*/
   2212            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   2213          
   2214            /* DMA Normal Mode */
   2215            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \   0000000A   0x6829             LDR      R1,[R5, #+0]
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x05C9             LSLS     R1,R1,#+23
   \   00000010   0xD413             BMI.N    ??SPI_DMATransmitCplt_0
   2216            {
   2217              /* Disable Tx DMA Request */
   2218              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x684A             LDR      R2,[R1, #+4]
   \   00000016   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000001A   0x604A             STR      R2,[R1, #+4]
   2219          
   2220              /* Check the end of the transaction */
   2221              if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \   0000001C   0x2164             MOVS     R1,#+100
   \   0000001E   0x4602             MOV      R2,R0
   \   00000020   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_15: (+1)
   \   00000024   0x.... 0x....      BL       ?Subroutine20
   2222              {
   2223                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   2224              }
   2225          
   2226              /* Clear overrun flag in 2 Lines communication mode because received data is not read */
   2227              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??CrossCallReturnLabel_34: (+1)
   \   00000028   0xB908             CBNZ.N   R0,??CrossCallReturnLabel_0
   2228              {
   2229                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000002A   0x.... 0x....      BL       ?Subroutine7
   2230              }
   2231          
   2232              hspi->TxXferCount = 0U;
   \                     ??CrossCallReturnLabel_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x86E0             STRH     R0,[R4, #+54]
   2233              hspi->State = HAL_SPI_STATE_READY;
   \   00000032   0x.... 0x....      BL       ?Subroutine11
   2234          
   2235              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??CrossCallReturnLabel_11: (+1)
   \   00000036   0xB100             CBZ.N    R0,??SPI_DMATransmitCplt_0
   2236              {
   2237                HAL_SPI_ErrorCallback(hspi);
   \   00000038   0x....             B.N      ?Subroutine3
   2238                return;
   2239              }
   2240            }
   2241            HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   2242          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF884 0x0051      STRB     R0,[R4, #+81]
   \   00000006   0x6D60             LDR      R0,[R4, #+84]
   \   00000008   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \   00000000   0x4620             MOV      R0,R4
   \   00000002   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000006   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \   00000000   0xB118             CBZ.N    R0,??Subroutine20_0
   \   00000002   0x6D60             LDR      R0,[R4, #+84]
   \   00000004   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000008   0x6560             STR      R0,[R4, #+84]
   \                     ??Subroutine20_0: (+1)
   \   0000000A   0x68A0             LDR      R0,[R4, #+8]
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \   00000000   0x9000             STR      R0,[SP, #+0]
   \   00000002   0x6820             LDR      R0,[R4, #+0]
   \   00000004   0x68C1             LDR      R1,[R0, #+12]
   \   00000006   0x9100             STR      R1,[SP, #+0]
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0x9800             LDR      R0,[SP, #+0]
   \   0000000E   0x4770             BX       LR
   2243          
   2244          /**
   2245            * @brief DMA SPI receive process complete callback.
   2246            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2247            *               the configuration information for the specified DMA module.
   2248            * @retval None
   2249            */

   \                                 In section .text, align 4, keep-with-next
   2250          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2251          {
   \                     SPI_DMAReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4601             MOV      R1,R0
   2252            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6B88             LDR      R0,[R1, #+56]
   2253          #if (USE_SPI_CRC != 0U)
   2254            uint32_t tickstart = 0U;
   2255            __IO uint16_t tmpreg = 0U;
   2256          
   2257            /* Init tickstart for timeout management*/
   2258            tickstart = HAL_GetTick();
   2259          #endif /* USE_SPI_CRC */
   2260           
   2261            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x05C9             LSLS     R1,R1,#+23
   \   0000000C   0xD416             BMI.N    ??SPI_DMAReceiveCplt_0
   2262            {
   2263          #if (USE_SPI_CRC != 0U)
   2264              /* CRC handling */
   2265              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2266              {
   2267                /* Wait until RXNE flag */
   2268                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SPI_FLAG_RXNE, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   2269                {
   2270                  /* Error on the CRC reception */
   2271                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2272                }
   2273                /* Read CRC */
   2274                tmpreg = hspi->Instance->DR;
   2275                /* To avoid GCC warning */
   2276                UNUSED(tmpreg);
   2277              }
   2278          #endif /* USE_SPI_CRC */
   2279          
   2280              /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   2281              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   0000000E   0x.... 0x....      BL       ?Subroutine14
   2282          
   2283              /* Check the end of the transaction */
   2284              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \                     ??CrossCallReturnLabel_20: (+1)
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000018   0xD108             BNE.N    ??CrossCallReturnLabel_22
   \   0000001A   0x6881             LDR      R1,[R0, #+8]
   \   0000001C   0xF5B1 0x4F00      CMP      R1,#+32768
   \   00000020   0xBF18             IT       NE 
   \   00000022   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000026   0xD101             BNE.N    ??CrossCallReturnLabel_22
   2285              {
   2286                /* Disable SPI peripheral */
   2287                __HAL_SPI_DISABLE(hspi);
   \   00000028   0x.... 0x....      BL       ?Subroutine15
   2288              }
   2289          
   2290              hspi->RxXferCount = 0U;
   \                     ??CrossCallReturnLabel_22: (+1)
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x87C1             STRH     R1,[R0, #+62]
   2291              hspi->State = HAL_SPI_STATE_READY;
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xF880 0x1051      STRB     R1,[R0, #+81]
   2292          
   2293          #if (USE_SPI_CRC != 0U)
   2294              /* Check if CRC error occurred */
   2295              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   2296              {
   2297                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2298                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2299              }
   2300          #endif /* USE_SPI_CRC */
   2301          
   2302              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \   00000036   0x6D41             LDR      R1,[R0, #+84]
   \   00000038   0xB101             CBZ.N    R1,??SPI_DMAReceiveCplt_0
   2303              {
   2304                HAL_SPI_ErrorCallback(hspi);
   \   0000003A   0x....             B.N      ?Subroutine5
   2305                return;
   2306              }
   2307            }
   2308            HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \   0000003C                      REQUIRE ?Subroutine4
   \   0000003C                      ;; // Fall through to label ?Subroutine4
   2309          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   00000004   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000004   0xBD01             POP      {R0,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x0892             LSRS     R2,R2,#+2
   \   00000006   0x0092             LSLS     R2,R2,#+2
   \   00000008   0x604A             STR      R2,[R1, #+4]
   \   0000000A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000008   0x600A             STR      R2,[R1, #+0]
   \   0000000A   0x4770             BX       LR
   2310          
   2311          /**
   2312            * @brief  DMA SPI transmit receive process complete callback.
   2313            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2314            *               the configuration information for the specified DMA module.
   2315            * @retval None
   2316            */

   \                                 In section .text, align 4, keep-with-next
   2317          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2318          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   2319            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6BAC             LDR      R4,[R5, #+56]
   2320            uint32_t tickstart = 0U;
   2321          #if (USE_SPI_CRC != 0U)
   2322            __IO int16_t tmpreg = 0U;
   2323          #endif /* USE_SPI_CRC */
   2324            /* Init tickstart for timeout management*/
   2325            tickstart = HAL_GetTick();
   \   00000006   0x.... 0x....      BL       HAL_GetTick
   2326          
   2327            if((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \   0000000A   0x6829             LDR      R1,[R5, #+0]
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x05C9             LSLS     R1,R1,#+23
   \   00000010   0xD414             BMI.N    ??SPI_DMATransmitReceiveCplt_0
   2328            {
   2329          #if (USE_SPI_CRC != 0U)
   2330              /* CRC handling */
   2331              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2332              {
   2333                /* Wait the CRC data */
   2334                if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   2335                {
   2336                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2337                }
   2338                /* Read CRC to Flush DR and RXNE flag */
   2339                tmpreg = hspi->Instance->DR;
   2340                /* To avoid GCC warning */
   2341                UNUSED(tmpreg);
   2342              }
   2343          #endif /* USE_SPI_CRC */
   2344              /* Check the end of the transaction */
   2345              if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \   00000012   0x4602             MOV      R2,R0
   \   00000014   0x2164             MOVS     R1,#+100
   \   00000016   0x.... 0x....      BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_14: (+1)
   \   0000001A   0xB118             CBZ.N    R0,??SPI_DMATransmitReceiveCplt_1
   2346              {
   2347                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   0000001C   0x6D60             LDR      R0,[R4, #+84]
   \   0000001E   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000022   0x6560             STR      R0,[R4, #+84]
   2348              }
   2349          
   2350              /* Disable Rx/Tx DMA Request */
   2351              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x6841             LDR      R1,[R0, #+4]
   \   00000028   0x0889             LSRS     R1,R1,#+2
   \   0000002A   0x0089             LSLS     R1,R1,#+2
   \   0000002C   0x6041             STR      R1,[R0, #+4]
   2352          
   2353              hspi->TxXferCount = 0U;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x86E0             STRH     R0,[R4, #+54]
   2354              hspi->RxXferCount = 0U;
   \   00000032   0x87E0             STRH     R0,[R4, #+62]
   2355              hspi->State = HAL_SPI_STATE_READY;
   \   00000034   0x.... 0x....      BL       ?Subroutine11
   2356          
   2357          #if (USE_SPI_CRC != 0U)
   2358              /* Check if CRC error occurred */
   2359              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   2360              {
   2361                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2362                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2363              }
   2364          #endif /* USE_SPI_CRC */
   2365          
   2366              if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??CrossCallReturnLabel_12: (+1)
   \   00000038   0xB100             CBZ.N    R0,??SPI_DMATransmitReceiveCplt_0
   2367              {
   2368                HAL_SPI_ErrorCallback(hspi);
   \   0000003A   0x....             B.N      ?Subroutine3
   2369                return;
   2370              }
   2371            }
   2372            HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   2373          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2374          
   2375          /**
   2376            * @brief  DMA SPI half transmit process complete callback.
   2377            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2378            *               the configuration information for the specified DMA module.
   2379            * @retval None
   2380            */

   \                                 In section .text, align 4, keep-with-next
   2381          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2382          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2383            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2384          
   2385            HAL_SPI_TxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2386          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2387          
   2388          /**
   2389            * @brief  DMA SPI half receive process complete callback
   2390            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2391            *               the configuration information for the specified DMA module.
   2392            * @retval None
   2393            */

   \                                 In section .text, align 4, keep-with-next
   2394          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2395          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2396            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2397          
   2398            HAL_SPI_RxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2399          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2400          
   2401          /**
   2402            * @brief  DMA SPI half transmit receive process complete callback.
   2403            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2404            *               the configuration information for the specified DMA module.
   2405            * @retval None
   2406            */

   \                                 In section .text, align 4, keep-with-next
   2407          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2408          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2409            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2410          
   2411            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   \   00000004   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2412          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
   2413          
   2414          /**
   2415            * @brief  DMA SPI communication error callback.
   2416            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2417            *               the configuration information for the specified DMA module.
   2418            * @retval None
   2419            */

   \                                 In section .text, align 4, keep-with-next
   2420          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2421          {
   \                     SPI_DMAError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2422            SPI_HandleTypeDef* hspi = (SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2423          
   2424          /* Stop the disable DMA transfer on SPI side */
   2425            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \   00000004   0x.... 0x....      BL       ?Subroutine14
   2426          
   2427            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \                     ??CrossCallReturnLabel_21: (+1)
   \   00000008   0x6D41             LDR      R1,[R0, #+84]
   \   0000000A   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000000E   0x6541             STR      R1,[R0, #+84]
   2428            hspi->State = HAL_SPI_STATE_READY;
   \   00000010   0xF05F 0x0101      MOVS.W   R1,#+1
   \   00000014   0xF880 0x1051      STRB     R1,[R0, #+81]
   2429            HAL_SPI_ErrorCallback(hspi);
   \   00000018                      REQUIRE ?Subroutine5
   \   00000018                      ;; // Fall through to label ?Subroutine5
   2430          }
   2431          
   2432          /**
   2433            * @brief  DMA SPI communication abort callback, when initiated by HAL services on Error
   2434            *         (To be called at end of DMA Abort procedure following error occurrence).
   2435            * @param  hdma DMA handle.
   2436            * @retval None
   2437            */

   \                                 In section .text, align 4, keep-with-next
   2438          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   2439          {
   \                     SPI_DMAAbortOnError: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2440            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2441            hspi->RxXferCount = 0U;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x87C1             STRH     R1,[R0, #+62]
   2442            hspi->TxXferCount = 0U;
   \   00000008   0x86C1             STRH     R1,[R0, #+54]
   2443          
   2444            HAL_SPI_ErrorCallback(hspi);
   \   0000000A   0x....             B.N      ?Subroutine5
   2445          }
   2446          
   2447          /**
   2448            * @brief  DMA SPI Tx communication abort callback, when initiated by user
   2449            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   2450            * @note   When this callback is executed, User Abort complete call back is called only if no
   2451            *         Abort still ongoing for Rx DMA Handle.
   2452            * @param  hdma DMA handle.
   2453            * @retval None
   2454            */

   \                                 In section .text, align 4, keep-with-next
   2455          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   2456          {
   \                     SPI_DMATxAbortCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2457            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable3
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x2218             MOVS     R2,#+24
   \   0000000A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000000E   0xF44F 0x727A      MOV      R2,#+1000
   \   00000012   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000016   0x2264             MOVS     R2,#+100
   \   00000018   0x4351             MULS     R1,R2,R1
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   2458            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2459          
   2460            hspi->hdmatx->XferAbortCallback = NULL;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6B80             LDR      R0,[R0, #+56]
   \   00000020   0x6C82             LDR      R2,[R0, #+72]
   \   00000022   0x6511             STR      R1,[R2, #+80]
   2461          
   2462            /* Disable Tx DMA Request */
   2463            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN );
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x684A             LDR      R2,[R1, #+4]
   \   00000028   0xF022 0x0202      BIC      R2,R2,#0x2
   \   0000002C   0x604A             STR      R2,[R1, #+4]
   2464          
   2465            /* Wait until TXE flag is set */
   2466            do
   2467            {
   2468              if(count-- == 0U)
   \                     ??SPI_DMATxAbortCallback_0: (+1)
   \   0000002E   0x9900             LDR      R1,[SP, #+0]
   \   00000030   0x1E4A             SUBS     R2,R1,#+1
   \   00000032   0x9200             STR      R2,[SP, #+0]
   \   00000034   0xB921             CBNZ.N   R1,??SPI_DMATxAbortCallback_1
   2469              {
   2470                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000036   0x6D41             LDR      R1,[R0, #+84]
   \   00000038   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000003C   0x6541             STR      R1,[R0, #+84]
   2471                break;
   \   0000003E   0xE003             B.N      ??SPI_DMATxAbortCallback_2
   2472              }
   2473            }
   2474            while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \                     ??SPI_DMATxAbortCallback_1: (+1)
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0x6889             LDR      R1,[R1, #+8]
   \   00000044   0x0789             LSLS     R1,R1,#+30
   \   00000046   0xD5F2             BPL.N    ??SPI_DMATxAbortCallback_0
   2475          
   2476            /* Check if an Abort process is still ongoing */
   2477            if(hspi->hdmarx != NULL)
   \                     ??SPI_DMATxAbortCallback_2: (+1)
   \   00000048   0x6CC1             LDR      R1,[R0, #+76]
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xBF1C             ITT      NE 
   2478            {
   2479              if(hspi->hdmarx->XferAbortCallback != NULL)
   \   0000004E   0x6D09             LDRNE    R1,[R1, #+80]
   \   00000050   0x2900             CMPNE    R1,#+0
   \   00000052   0xD105             BNE.N    ??SPI_DMATxAbortCallback_3
   2480              {
   2481                return;
   2482              }
   2483            }
   2484            
   2485            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   2486            hspi->RxXferCount = 0U;
   \   00000054   0x.... 0x....      BL       ?Subroutine21
   2487            hspi->TxXferCount = 0U;
   2488          
   2489            /* Reset errorCode */
   2490            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   2491          
   2492            /* Clear the Error flags in the SR register */
   2493            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \                     ??CrossCallReturnLabel_37: (+1)
   \   00000058   0x.... 0x....      BL       ?Subroutine22
   2494          
   2495            /* Restore hspi->State to Ready */
   2496            hspi->State  = HAL_SPI_STATE_READY;
   2497          
   2498            /* Call user Abort complete callback */
   2499            HAL_SPI_AbortCpltCallback(hspi);
   \                     ??CrossCallReturnLabel_39: (+1)
   \   0000005C   0x.... 0x....      BL       HAL_SPI_AbortCpltCallback
   2500          }
   \                     ??SPI_DMATxAbortCallback_3: (+1)
   \   00000060   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \   00000000   0x6889             LDR      R1,[R1, #+8]
   \   00000002   0x9100             STR      R1,[SP, #+0]
   \   00000004   0x9900             LDR      R1,[SP, #+0]
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0xF880 0x1051      STRB     R1,[R0, #+81]
   \   0000000C   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x87C1             STRH     R1,[R0, #+62]
   \   00000004   0x86C1             STRH     R1,[R0, #+54]
   \   00000006   0x6541             STR      R1,[R0, #+84]
   \   00000008   0x9100             STR      R1,[SP, #+0]
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x4770             BX       LR
   2501          
   2502          /**
   2503            * @brief  DMA SPI Rx communication abort callback, when initiated by user
   2504            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   2505            * @note   When this callback is executed, User Abort complete call back is called only if no
   2506            *         Abort still ongoing for Tx DMA Handle.
   2507            * @param  hdma DMA handle.
   2508            * @retval None
   2509            */

   \                                 In section .text, align 4, keep-with-next
   2510          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   2511          {
   \                     SPI_DMARxAbortCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2512            SPI_HandleTypeDef* hspi = ( SPI_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000002   0x6B80             LDR      R0,[R0, #+56]
   2513          
   2514            /* Disable SPI Peripheral */
   2515            __HAL_SPI_DISABLE(hspi);
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0xF022 0x0240      BIC      R2,R2,#0x40
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   2516          
   2517            hspi->hdmarx->XferAbortCallback = NULL;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6CC2             LDR      R2,[R0, #+76]
   \   00000012   0x6511             STR      R1,[R2, #+80]
   2518          
   2519            /* Disable Rx DMA Request */
   2520            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x684A             LDR      R2,[R1, #+4]
   \   00000018   0x0852             LSRS     R2,R2,#+1
   \   0000001A   0x0052             LSLS     R2,R2,#+1
   \   0000001C   0x604A             STR      R2,[R1, #+4]
   2521          
   2522            /* Check if an Abort process is still ongoing */
   2523            if(hspi->hdmatx != NULL)
   \   0000001E   0x6C81             LDR      R1,[R0, #+72]
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xBF1C             ITT      NE 
   2524            {
   2525              if(hspi->hdmatx->XferAbortCallback != NULL)
   \   00000024   0x6D09             LDRNE    R1,[R1, #+80]
   \   00000026   0x2900             CMPNE    R1,#+0
   \   00000028   0xD10C             BNE.N    ??SPI_DMARxAbortCallback_0
   2526              {
   2527                return;
   2528              }
   2529            }
   2530          
   2531            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   2532            hspi->RxXferCount = 0U;
   \   0000002A   0x.... 0x....      BL       ?Subroutine21
   2533            hspi->TxXferCount = 0U;
   2534          
   2535            /* Reset errorCode */
   2536            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   2537          
   2538            /* Clear the Error flags in the SR register */
   2539            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??CrossCallReturnLabel_38: (+1)
   \   0000002E   0x68CA             LDR      R2,[R1, #+12]
   \   00000030   0x9200             STR      R2,[SP, #+0]
   \   00000032   0x688A             LDR      R2,[R1, #+8]
   \   00000034   0x9200             STR      R2,[SP, #+0]
   \   00000036   0x9A00             LDR      R2,[SP, #+0]
   2540            __HAL_SPI_CLEAR_FREFLAG(hspi);  
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x9200             STR      R2,[SP, #+0]
   \   0000003C   0x.... 0x....      BL       ?Subroutine22
   2541          
   2542            /* Restore hspi->State to Ready */
   2543            hspi->State  = HAL_SPI_STATE_READY;
   2544          
   2545            /* Call user Abort complete callback */
   2546            HAL_SPI_AbortCpltCallback(hspi);
   \                     ??CrossCallReturnLabel_40: (+1)
   \   00000040   0x.... 0x....      BL       HAL_SPI_AbortCpltCallback
   2547          }
   \                     ??SPI_DMARxAbortCallback_0: (+1)
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
   2548          
   2549          /**
   2550            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   2551            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2552            *               the configuration information for SPI module.
   2553            * @retval None
   2554            */

   \                                 In section .text, align 4, keep-with-next
   2555          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2556          {
   2557            /* Receive data in 8bit mode */
   2558            *hspi->pRxBuffPtr++ = *((__IO uint8_t *)&hspi->Instance->DR);
   \                     SPI_2linesRxISR_8BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6382             STR      R2,[R0, #+56]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7B12             LDRB     R2,[R2, #+12]
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   2559            hspi->RxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2560          
   2561            /* check end of the reception */
   2562            if(hspi->RxXferCount == 0U)
   \   00000012   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000014   0xB949             CBNZ.N   R1,??SPI_2linesRxISR_8BIT_0
   2563            {
   2564          #if (USE_SPI_CRC != 0U)
   2565              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2566              {
   2567                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   2568                return;
   2569              }
   2570          #endif /* USE_SPI_CRC */
   2571          
   2572              /* Disable RXNE interrupt */
   2573              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x684A             LDR      R2,[R1, #+4]
   \   0000001A   0xF022 0x0260      BIC      R2,R2,#0x60
   \   0000001E   0x604A             STR      R2,[R1, #+4]
   2574          
   2575              if(hspi->TxXferCount == 0U)
   \   00000020   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xBF08             IT       EQ 
   2576              {
   2577                SPI_CloseRxTx_ISR(hspi);
   \   00000026   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2578              }
   2579            }
   2580          }
   \                     ??SPI_2linesRxISR_8BIT_0: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
   2581          
   2582          #if (USE_SPI_CRC != 0U)
   2583          /**
   2584            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   2585            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2586            *               the configuration information for SPI module.
   2587            * @retval None
   2588            */
   2589          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2590          {
   2591            __IO uint8_t tmpreg = 0U;
   2592          
   2593            /* Read data register to flush CRC */
   2594            tmpreg = *((__IO uint8_t *)&hspi->Instance->DR);
   2595          
   2596            /* To avoid GCC warning */
   2597          
   2598            UNUSED(tmpreg);
   2599          
   2600             /* Disable RXNE interrupt */
   2601            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   2602          
   2603            if(hspi->TxXferCount == 0U)
   2604            {
   2605              SPI_CloseRxTx_ISR(hspi);
   2606            }
   2607          }
   2608          #endif /* USE_SPI_CRC */
   2609          
   2610          /**
   2611            * @brief  Tx 8-bit handler for Transmit and Receive in Interrupt mode.
   2612            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2613            *               the configuration information for SPI module.
   2614            * @retval None
   2615            */

   \                                 In section .text, align 4, keep-with-next
   2616          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2617          {
   2618            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     SPI_2linesTxISR_8BIT: (+1)
   \   00000000   0x6B01             LDR      R1,[R0, #+48]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6302             STR      R2,[R0, #+48]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x7311             STRB     R1,[R2, #+12]
   2619            hspi->TxXferCount--;
   \   0000000C   0x8EC1             LDRH     R1,[R0, #+54]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x86C1             STRH     R1,[R0, #+54]
   2620          
   2621            /* check the end of the transmission */
   2622            if(hspi->TxXferCount == 0U)
   \   00000012   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000014   0xB949             CBNZ.N   R1,??SPI_2linesTxISR_8BIT_0
   2623            {
   2624          #if (USE_SPI_CRC != 0U)
   2625              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2626              {
   2627                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   2628                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   2629                return;
   2630              }
   2631          #endif /* USE_SPI_CRC */
   2632          
   2633              /* Disable TXE interrupt */
   2634              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x684A             LDR      R2,[R1, #+4]
   \   0000001A   0xF022 0x0280      BIC      R2,R2,#0x80
   \   0000001E   0x604A             STR      R2,[R1, #+4]
   2635          
   2636              if(hspi->RxXferCount == 0U)
   \   00000020   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xBF08             IT       EQ 
   2637              {
   2638                SPI_CloseRxTx_ISR(hspi);
   \   00000026   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2639              }
   2640            }
   2641          }
   \                     ??SPI_2linesTxISR_8BIT_0: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
   2642          
   2643          /**
   2644            * @brief  Rx 16-bit handler for Transmit and Receive in Interrupt mode.
   2645            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2646            *               the configuration information for SPI module.
   2647            * @retval None
   2648            */

   \                                 In section .text, align 4, keep-with-next
   2649          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2650          {
   2651            /* Receive data in 16 Bit mode */
   2652            *((uint16_t*)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_2linesRxISR_16BIT: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68C9             LDR      R1,[R1, #+12]
   \   00000004   0x6B82             LDR      R2,[R0, #+56]
   \   00000006   0x8011             STRH     R1,[R2, #+0]
   2653            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6B81             LDR      R1,[R0, #+56]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6381             STR      R1,[R0, #+56]
   2654            hspi->RxXferCount--;
   \   0000000E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x87C1             STRH     R1,[R0, #+62]
   2655          
   2656            if(hspi->RxXferCount == 0U)
   \   00000014   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000016   0xB949             CBNZ.N   R1,??SPI_2linesRxISR_16BIT_0
   2657            {
   2658          #if (USE_SPI_CRC != 0U)
   2659              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2660              {
   2661                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   2662                return;
   2663              }
   2664          #endif /* USE_SPI_CRC */
   2665          
   2666              /* Disable RXNE interrupt */
   2667              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x684A             LDR      R2,[R1, #+4]
   \   0000001C   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000020   0x604A             STR      R2,[R1, #+4]
   2668          
   2669              if(hspi->TxXferCount == 0U)
   \   00000022   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xBF08             IT       EQ 
   2670              {
   2671                SPI_CloseRxTx_ISR(hspi);
   \   00000028   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2672              }
   2673            }
   2674          }
   \                     ??SPI_2linesRxISR_16BIT_0: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   2675          
   2676          #if (USE_SPI_CRC != 0U)
   2677          /**
   2678            * @brief  Manage the CRC 16-bit receive for Transmit and Receive in Interrupt mode.
   2679            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2680            *               the configuration information for SPI module.
   2681            * @retval None
   2682            */
   2683          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2684          {
   2685            /* Receive data in 16 Bit mode */
   2686            __IO uint16_t tmpreg = 0U;
   2687          
   2688            /* Read data register to flush CRC */
   2689            tmpreg = hspi->Instance->DR;
   2690          
   2691            /* To avoid GCC warning */
   2692            UNUSED(tmpreg);
   2693          
   2694            /* Disable RXNE interrupt */
   2695            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   2696          
   2697            SPI_CloseRxTx_ISR(hspi);
   2698          }
   2699          #endif /* USE_SPI_CRC */
   2700          
   2701          /**
   2702            * @brief  Tx 16-bit handler for Transmit and Receive in Interrupt mode.
   2703            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2704            *               the configuration information for SPI module.
   2705            * @retval None
   2706            */

   \                                 In section .text, align 4, keep-with-next
   2707          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2708          {
   2709            /* Transmit data in 16 Bit mode */
   2710            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_2linesTxISR_16BIT: (+1)
   \   00000000   0x6B01             LDR      R1,[R0, #+48]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x8809             LDRH     R1,[R1, #+0]
   \   00000006   0x60D1             STR      R1,[R2, #+12]
   2711            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6B01             LDR      R1,[R0, #+48]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6301             STR      R1,[R0, #+48]
   2712            hspi->TxXferCount--;
   \   0000000E   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x86C1             STRH     R1,[R0, #+54]
   2713          
   2714            /* Enable CRC Transmission */
   2715            if(hspi->TxXferCount == 0U)
   \   00000014   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000016   0xB949             CBNZ.N   R1,??SPI_2linesTxISR_16BIT_0
   2716            {
   2717          #if (USE_SPI_CRC != 0U)
   2718              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2719              {
   2720                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   2721                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   2722                return;
   2723              }
   2724          #endif /* USE_SPI_CRC */
   2725          
   2726              /* Disable TXE interrupt */
   2727              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x684A             LDR      R2,[R1, #+4]
   \   0000001C   0xF022 0x0280      BIC      R2,R2,#0x80
   \   00000020   0x604A             STR      R2,[R1, #+4]
   2728          
   2729              if(hspi->RxXferCount == 0U)
   \   00000022   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xBF08             IT       EQ 
   2730              {
   2731                SPI_CloseRxTx_ISR(hspi);
   \   00000028   0x.... 0x....      BEQ.W    SPI_CloseRxTx_ISR
   2732              }
   2733            }
   2734          }
   \                     ??SPI_2linesTxISR_16BIT_0: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   2735          
   2736          #if (USE_SPI_CRC != 0U)
   2737          /**
   2738            * @brief  Manage the CRC 8-bit receive in Interrupt context.
   2739            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2740            *               the configuration information for SPI module.
   2741            * @retval None
   2742            */
   2743          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   2744          {
   2745            __IO uint8_t tmpreg = 0U;
   2746          
   2747            /* Read data register to flush CRC */
   2748            tmpreg = *((__IO uint8_t*)&hspi->Instance->DR);
   2749          
   2750            /* To avoid GCC warning */
   2751            UNUSED(tmpreg);
   2752          
   2753            SPI_CloseRx_ISR(hspi);
   2754          }
   2755          #endif /* USE_SPI_CRC */
   2756          
   2757          /**
   2758            * @brief  Manage the receive 8-bit in Interrupt context.
   2759            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2760            *               the configuration information for SPI module.
   2761            * @retval None
   2762            */

   \                                 In section .text, align 4, keep-with-next
   2763          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2764          {
   2765            *hspi->pRxBuffPtr++ = (*(__IO uint8_t *)&hspi->Instance->DR);
   \                     SPI_RxISR_8BIT: (+1)
   \   00000000   0x6B81             LDR      R1,[R0, #+56]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6382             STR      R2,[R0, #+56]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7B12             LDRB     R2,[R2, #+12]
   \   0000000A   0x700A             STRB     R2,[R1, #+0]
   2766            hspi->RxXferCount--;
   \   0000000C   0x8FC1             LDRH     R1,[R0, #+62]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x87C1             STRH     R1,[R0, #+62]
   2767          
   2768          #if (USE_SPI_CRC != 0U)
   2769            /* Enable CRC Transmission */
   2770            if((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   2771            {
   2772              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   2773            }
   2774          #endif /* USE_SPI_CRC */
   2775          
   2776            if(hspi->RxXferCount == 0U)
   \   00000012   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xBF08             IT       EQ 
   2777            {
   2778          #if (USE_SPI_CRC != 0U)
   2779              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2780              {
   2781                hspi->RxISR =  SPI_RxISR_8BITCRC;
   2782                return;
   2783              }
   2784          #endif /* USE_SPI_CRC */
   2785              SPI_CloseRx_ISR(hspi);
   \   00000018   0x.... 0x....      BEQ.W    SPI_CloseRx_ISR
   2786            }
   2787          }
   \   0000001C   0x4770             BX       LR               ;; return
   2788          
   2789          #if (USE_SPI_CRC != 0U)
   2790          /**
   2791            * @brief  Manage the CRC 16-bit receive in Interrupt context.
   2792            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2793            *               the configuration information for SPI module.
   2794            * @retval None
   2795            */
   2796          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   2797          {
   2798            __IO uint16_t tmpreg = 0U;
   2799          
   2800            /* Read data register to flush CRC */
   2801            tmpreg = hspi->Instance->DR;
   2802          
   2803            /* To avoid GCC warning */
   2804            UNUSED(tmpreg);
   2805          
   2806            /* Disable RXNE and ERR interrupt */
   2807            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   2808          
   2809            SPI_CloseRx_ISR(hspi);
   2810          }
   2811          #endif /* USE_SPI_CRC */
   2812          
   2813          /**
   2814            * @brief  Manage the 16-bit receive in Interrupt context.
   2815            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2816            *               the configuration information for SPI module.
   2817            * @retval None
   2818            */

   \                                 In section .text, align 4, keep-with-next
   2819          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2820          {
   2821            *((uint16_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \                     SPI_RxISR_16BIT: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x68C9             LDR      R1,[R1, #+12]
   \   00000004   0x6B82             LDR      R2,[R0, #+56]
   \   00000006   0x8011             STRH     R1,[R2, #+0]
   2822            hspi->pRxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6B81             LDR      R1,[R0, #+56]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6381             STR      R1,[R0, #+56]
   2823            hspi->RxXferCount--;
   \   0000000E   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x87C1             STRH     R1,[R0, #+62]
   2824          
   2825          #if (USE_SPI_CRC != 0U)
   2826            /* Enable CRC Transmission */
   2827            if((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   2828            {
   2829              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   2830            }
   2831          #endif /* USE_SPI_CRC */
   2832          
   2833            if(hspi->RxXferCount == 0U)
   \   00000014   0x8FC1             LDRH     R1,[R0, #+62]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xBF08             IT       EQ 
   2834            {
   2835          #if (USE_SPI_CRC != 0U)
   2836              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2837              {
   2838                hspi->RxISR = SPI_RxISR_16BITCRC;
   2839                return;
   2840              }
   2841          #endif /* USE_SPI_CRC */
   2842              SPI_CloseRx_ISR(hspi);
   \   0000001A   0x.... 0x....      BEQ.W    SPI_CloseRx_ISR
   2843            }
   2844          }
   \   0000001E   0x4770             BX       LR               ;; return
   2845          
   2846          /**
   2847            * @brief  Handle the data 8-bit transmit in Interrupt mode.
   2848            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2849            *               the configuration information for SPI module.
   2850            * @retval None
   2851            */

   \                                 In section .text, align 4, keep-with-next
   2852          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   2853          {
   2854            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr++);
   \                     SPI_TxISR_8BIT: (+1)
   \   00000000   0x6B01             LDR      R1,[R0, #+48]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6302             STR      R2,[R0, #+48]
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x7311             STRB     R1,[R2, #+12]
   2855            hspi->TxXferCount--;
   \   0000000C   0x8EC1             LDRH     R1,[R0, #+54]
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x86C1             STRH     R1,[R0, #+54]
   2856          
   2857            if(hspi->TxXferCount == 0U)
   \   00000012   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xBF08             IT       EQ 
   2858            {
   2859          #if (USE_SPI_CRC != 0U)
   2860              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2861              {
   2862                /* Enable CRC Transmission */
   2863                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   2864              }
   2865          #endif /* USE_SPI_CRC */
   2866              SPI_CloseTx_ISR(hspi);
   \   00000018   0x.... 0x....      BEQ.W    SPI_CloseTx_ISR
   2867            }
   2868          }
   \   0000001C   0x4770             BX       LR               ;; return
   2869          
   2870          /**
   2871            * @brief  Handle the data 16-bit transmit in Interrupt mode.
   2872            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2873            *               the configuration information for SPI module.
   2874            * @retval None
   2875            */

   \                                 In section .text, align 4, keep-with-next
   2876          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   2877          {
   2878            /* Transmit data in 16 Bit mode */
   2879            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     SPI_TxISR_16BIT: (+1)
   \   00000000   0x6B01             LDR      R1,[R0, #+48]
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0x8809             LDRH     R1,[R1, #+0]
   \   00000006   0x60D1             STR      R1,[R2, #+12]
   2880            hspi->pTxBuffPtr += sizeof(uint16_t);
   \   00000008   0x6B01             LDR      R1,[R0, #+48]
   \   0000000A   0x1C89             ADDS     R1,R1,#+2
   \   0000000C   0x6301             STR      R1,[R0, #+48]
   2881            hspi->TxXferCount--;
   \   0000000E   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000010   0x1E49             SUBS     R1,R1,#+1
   \   00000012   0x86C1             STRH     R1,[R0, #+54]
   2882          
   2883            if(hspi->TxXferCount == 0U)
   \   00000014   0x8EC1             LDRH     R1,[R0, #+54]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xBF08             IT       EQ 
   2884            {
   2885          #if (USE_SPI_CRC != 0U)
   2886              if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2887              {
   2888                /* Enable CRC Transmission */
   2889                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   2890              }
   2891          #endif /* USE_SPI_CRC */
   2892              SPI_CloseTx_ISR(hspi);
   \   0000001A   0x.... 0x....      BEQ.W    SPI_CloseTx_ISR
   2893            }
   2894          }
   \   0000001E   0x4770             BX       LR               ;; return
   2895          
   2896          /**
   2897            * @brief Handle SPI Communication Timeout.
   2898            * @param hspi pointer to a SPI_HandleTypeDef structure that contains
   2899            *              the configuration information for SPI module.
   2900            * @param Flag SPI flag to check
   2901            * @param State flag state to check
   2902            * @param Timeout Timeout duration
   2903            * @param Tickstart tick start value
   2904            * @retval HAL status
   2905            */

   \                                 In section .text, align 2, keep-with-next
   2906          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout, uint32_t Tickstart)
   2907          {
   \                     SPI_WaitFlagStateUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x9E06             LDR      R6,[SP, #+24]
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x461F             MOV      R7,R3
   2908            while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
   \                     ??SPI_WaitFlagStateUntilTimeout_0: (+1)
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x6880             LDR      R0,[R0, #+8]
   \   00000012   0x4028             ANDS     R0,R5,R0
   \   00000014   0x42A8             CMP      R0,R5
   \   00000016   0xBF0C             ITE      EQ 
   \   00000018   0x2001             MOVEQ    R0,#+1
   \   0000001A   0x2000             MOVNE    R0,#+0
   \   0000001C   0x4540             CMP      R0,R8
   \   0000001E   0xD034             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_1
   2909            {
   2910              if(Timeout != HAL_MAX_DELAY)
   \   00000020   0xF117 0x0F01      CMN      R7,#+1
   \   00000024   0xD0F3             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_0
   2911              {
   2912                if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
   \   00000026   0xB127             CBZ.N    R7,??SPI_WaitFlagStateUntilTimeout_2
   \   00000028   0x.... 0x....      BL       HAL_GetTick
   \   0000002C   0x1B80             SUBS     R0,R0,R6
   \   0000002E   0x42B8             CMP      R0,R7
   \   00000030   0xD3ED             BCC.N    ??SPI_WaitFlagStateUntilTimeout_0
   2913                {
   2914                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   2915                  on both master and slave sides in order to resynchronize the master
   2916                  and slave for their respective CRC calculation */
   2917          
   2918                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   2919                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFlagStateUntilTimeout_2: (+1)
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6841             LDR      R1,[R0, #+4]
   \   00000036   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   0000003A   0x6041             STR      R1,[R0, #+4]
   2920          
   2921                  if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0xF5B0 0x7F82      CMP      R0,#+260
   \   00000042   0xD10B             BNE.N    ??SPI_WaitFlagStateUntilTimeout_3
   \   00000044   0x68A0             LDR      R0,[R4, #+8]
   \   00000046   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0xF5B0 0x6F80      CMPNE    R0,#+1024
   \   00000050   0xD104             BNE.N    ??SPI_WaitFlagStateUntilTimeout_3
   2922                  {
   2923                    /* Disable SPI peripheral */
   2924                    __HAL_SPI_DISABLE(hspi);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF021 0x0140      BIC      R1,R1,#0x40
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   2925                  }
   2926          
   2927                  /* Reset CRC Calculation */
   2928                  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??SPI_WaitFlagStateUntilTimeout_3: (+1)
   \   0000005C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000005E   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000062   0xD10A             BNE.N    ??SPI_WaitFlagStateUntilTimeout_4
   2929                  {
   2930                    SPI_RESET_CRC(hspi);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x6801             LDR      R1,[R0, #+0]
   \   00000068   0xF64D 0x72FF      MOVW     R2,#+57343
   \   0000006C   0x4011             ANDS     R1,R2,R1
   \   0000006E   0x6001             STR      R1,[R0, #+0]
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000078   0x6001             STR      R1,[R0, #+0]
   2931                  }
   2932          
   2933                  hspi->State= HAL_SPI_STATE_READY;
   \                     ??SPI_WaitFlagStateUntilTimeout_4: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xF884 0x0051      STRB     R0,[R4, #+81]
   2934          
   2935                  /* Process Unlocked */
   2936                  __HAL_UNLOCK(hspi);
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xF884 0x0050      STRB     R0,[R4, #+80]
   2937          
   2938                  return HAL_TIMEOUT;
   \   00000086   0x2003             MOVS     R0,#+3
   \   00000088   0xE000             B.N      ??SPI_WaitFlagStateUntilTimeout_5
   2939                }
   2940              }
   2941            }
   2942          
   2943            return HAL_OK;
   \                     ??SPI_WaitFlagStateUntilTimeout_1: (+1)
   \   0000008A   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFlagStateUntilTimeout_5: (+1)
   \   0000008C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2944          }
   2945          /**
   2946            * @brief Handle to check BSY flag before start a new transaction.
   2947            * @param hspi pointer to a SPI_HandleTypeDef structure that contains
   2948            *              the configuration information for SPI module.
   2949            * @param Timeout Timeout duration
   2950            * @param Tickstart tick start value
   2951            * @retval HAL status
   2952            */

   \                                 In section .text, align 2, keep-with-next
   2953          static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
   2954          {
   \                     SPI_CheckFlag_BSY: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   2955            /* Control the BSY flag */
   2956            if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0x9200             STR      R2,[SP, #+0]
   \   00000008   0x4604             MOV      R4,R0
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \   00000012   0xB120             CBZ.N    R0,??SPI_CheckFlag_BSY_0
   2957            {
   2958              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000014   0x6D60             LDR      R0,[R4, #+84]
   \   00000016   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000001A   0x6560             STR      R0,[R4, #+84]
   2959              return HAL_TIMEOUT;
   \   0000001C   0x2003             MOVS     R0,#+3
   2960            }
   2961            return HAL_OK;
   \                     ??SPI_CheckFlag_BSY_0: (+1)
   \   0000001E   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2962          }
   2963          
   2964          /**
   2965            * @brief  Handle the end of the RXTX transaction.
   2966            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2967            *               the configuration information for SPI module.
   2968            * @retval None
   2969            */

   \                                 In section .text, align 2, keep-with-next
   2970          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   2971          {
   \                     SPI_CloseRxTx_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine23
   2972            uint32_t tickstart = 0U;
   2973            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \                     ??CrossCallReturnLabel_41: (+1)
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x.... 0x....      BL       ?Subroutine16
   2974            /* Init tickstart for timeout managment*/
   2975            tickstart = HAL_GetTick();
   2976          
   2977            /* Disable ERR interrupt */
   2978            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \                     ??CrossCallReturnLabel_25: (+1)
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x684A             LDR      R2,[R1, #+4]
   \   00000010   0xF022 0x0220      BIC      R2,R2,#0x20
   \   00000014   0x604A             STR      R2,[R1, #+4]
   \   00000016   0x.... 0x....      BL       ?Subroutine17
   2979          
   2980            /* Wait until TXE flag is set */
   2981            do
   2982            {
   2983              if(count-- == 0U)
   2984              {
   2985                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   2986                break;
   2987              }
   2988            }
   2989            while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   2990            
   2991            /* Check the end of the transaction */
   2992            if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart)!=HAL_OK)
   \                     ??CrossCallReturnLabel_26: (+1)
   \   0000001A   0x4602             MOV      R2,R0
   \   0000001C   0x2164             MOVS     R1,#+100
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       SPI_CheckFlag_BSY
   \   00000024   0x.... 0x....      BL       ?Subroutine20
   2993            {
   2994              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   2995            }
   2996          
   2997            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   2998            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??CrossCallReturnLabel_35: (+1)
   \   00000028   0xB908             CBNZ.N   R0,??CrossCallReturnLabel_1
   2999            {
   3000              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000002A   0x.... 0x....      BL       ?Subroutine7
   3001            }
   3002          
   3003          #if (USE_SPI_CRC != 0U)
   3004            /* Check if CRC error occurred */
   3005            if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   3006            {
   3007              hspi->State = HAL_SPI_STATE_READY;
   3008              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3009              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3010              HAL_SPI_ErrorCallback(hspi);
   3011            }
   3012            else
   3013            {
   3014          #endif /* USE_SPI_CRC */
   3015              if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??CrossCallReturnLabel_1: (+1)
   \   0000002E   0x6D60             LDR      R0,[R4, #+84]
   \   00000030   0xB968             CBNZ.N   R0,??SPI_CloseRxTx_ISR_0
   3016              {
   3017                if(hspi->State == HAL_SPI_STATE_BUSY_RX)
   \   00000032   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \   00000036   0x2804             CMP      R0,#+4
   \   00000038   0xD104             BNE.N    ??SPI_CloseRxTx_ISR_1
   3018                {
   3019                	hspi->State = HAL_SPI_STATE_READY;
   \   0000003A   0x.... 0x....      BL       ?Subroutine8
   3020                  HAL_SPI_RxCpltCallback(hspi);
   3021                }
   \                     ??CrossCallReturnLabel_4: (+1)
   \   0000003E   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \   00000042   0xBD13             POP      {R0,R1,R4,PC}
   3022                else
   3023                {
   3024                	hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_1: (+1)
   \   00000044   0x.... 0x....      BL       ?Subroutine8
   3025                  HAL_SPI_TxRxCpltCallback(hspi);
   3026                }
   3027              }
   \                     ??CrossCallReturnLabel_5: (+1)
   \   00000048   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \   0000004C   0xBD13             POP      {R0,R1,R4,PC}
   3028              else
   3029              {
   3030                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_0: (+1)
   \   0000004E   0x.... 0x....      BL       ?Subroutine8
   3031                HAL_SPI_ErrorCallback(hspi);
   3032              }
   \                     ??CrossCallReturnLabel_6: (+1)
   \   00000052                      REQUIRE ?Subroutine6
   \   00000052                      ;; // Fall through to label ?Subroutine6
   3033          #if (USE_SPI_CRC != 0U)
   3034            }
   3035          #endif /* USE_SPI_CRC */
   3036          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \   00000000   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \   00000004   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \   00000000   0x4604             MOV      R4,R0
   \   00000002   0x....             LDR.N    R0,??DataTable3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2118             MOVS     R1,#+24
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000010   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000014   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \   00000000   0x9900             LDR      R1,[SP, #+0]
   \   00000002   0x1E4A             SUBS     R2,R1,#+1
   \   00000004   0x9200             STR      R2,[SP, #+0]
   \   00000006   0xB921             CBNZ.N   R1,??Subroutine17_0
   \   00000008   0x6D61             LDR      R1,[R4, #+84]
   \   0000000A   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000000E   0x6561             STR      R1,[R4, #+84]
   \   00000010   0x4770             BX       LR
   \                     ??Subroutine17_0: (+1)
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x6889             LDR      R1,[R1, #+8]
   \   00000016   0x0789             LSLS     R1,R1,#+30
   \   00000018   0xD5F2             BPL.N    ?Subroutine17
   \                     ??Subroutine17_1: (+1)
   \   0000001A   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \   00000000   0x2164             MOVS     R1,#+100
   \   00000002   0x4348             MULS     R0,R1,R0
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x.... 0x....      B.W      HAL_GetTick
   3037          
   3038          /**
   3039            * @brief  Handle the end of the RX transaction.
   3040            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3041            *               the configuration information for SPI module.
   3042            * @retval None
   3043            */

   \                                 In section .text, align 2, keep-with-next
   3044          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   3045          {
   \                     SPI_CloseRx_ISR: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3046              /* Disable RXNE and ERR interrupt */
   3047              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x684A             LDR      R2,[R1, #+4]
   \   00000006   0xF022 0x0260      BIC      R2,R2,#0x60
   \   0000000A   0x604A             STR      R2,[R1, #+4]
   3048          
   3049              /* Check the end of the transaction */
   3050              if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \   0000000C   0x6841             LDR      R1,[R0, #+4]
   \   0000000E   0xF5B1 0x7F82      CMP      R1,#+260
   \   00000012   0xD108             BNE.N    ??CrossCallReturnLabel_23
   \   00000014   0x6881             LDR      R1,[R0, #+8]
   \   00000016   0xF5B1 0x4F00      CMP      R1,#+32768
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0xF5B1 0x6F80      CMPNE    R1,#+1024
   \   00000020   0xD101             BNE.N    ??CrossCallReturnLabel_23
   3051              {
   3052                /* Disable SPI peripheral */
   3053                __HAL_SPI_DISABLE(hspi);
   \   00000022   0x.... 0x....      BL       ?Subroutine15
   3054              }
   3055          
   3056              /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3057              if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??CrossCallReturnLabel_23: (+1)
   \   00000026   0x6881             LDR      R1,[R0, #+8]
   \   00000028   0xB931             CBNZ.N   R1,??SPI_CloseRx_ISR_0
   3058              {
   3059                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000002A   0x9100             STR      R1,[SP, #+0]
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x68CA             LDR      R2,[R1, #+12]
   \   00000030   0x9200             STR      R2,[SP, #+0]
   \   00000032   0x6889             LDR      R1,[R1, #+8]
   \   00000034   0x9100             STR      R1,[SP, #+0]
   \   00000036   0x9900             LDR      R1,[SP, #+0]
   3060              }
   3061              hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRx_ISR_0: (+1)
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0xF880 0x1051      STRB     R1,[R0, #+81]
   3062          
   3063          #if (USE_SPI_CRC != 0U)
   3064              /* Check if CRC error occurred */
   3065              if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   3066              {
   3067                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3068                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3069                HAL_SPI_ErrorCallback(hspi);
   3070              }
   3071              else
   3072              {
   3073          #endif /* USE_SPI_CRC */
   3074                if(hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \   0000003E   0x6D41             LDR      R1,[R0, #+84]
   \   00000040   0xB901             CBNZ.N   R1,??SPI_CloseRx_ISR_1
   3075                {
   3076                  HAL_SPI_RxCpltCallback(hspi);
   \   00000042   0x....             B.N      ?Subroutine4
   3077                }
   3078                else
   3079                {
   3080                  HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_CloseRx_ISR_1: (+1)
   \   00000044   0x....             B.N      ?Subroutine5
   3081                }
   3082          #if (USE_SPI_CRC != 0U)
   3083              }
   3084          #endif /* USE_SPI_CRC */
   3085          }
   3086          
   3087          /**
   3088            * @brief  Handle the end of the TX transaction.
   3089            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3090            *               the configuration information for SPI module.
   3091            * @retval None
   3092            */

   \                                 In section .text, align 2, keep-with-next
   3093          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   3094          {
   \                     SPI_CloseTx_ISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      BL       ?Subroutine23
   3095            uint32_t tickstart = 0U;
   3096            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \                     ??CrossCallReturnLabel_42: (+1)
   \   00000006   0xB082             SUB      SP,SP,#+8
   \   00000008   0x.... 0x....      BL       ?Subroutine16
   3097          
   3098            /* Init tickstart for timeout management*/
   3099            tickstart = HAL_GetTick();
   \                     ??CrossCallReturnLabel_24: (+1)
   \   0000000C   0x.... 0x....      BL       ?Subroutine17
   3100          
   3101            /* Wait until TXE flag is set */
   3102            do
   3103            {
   3104              if(count-- == 0U)
   3105              {
   3106                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3107                break;
   3108              }
   3109            }
   3110            while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   3111          
   3112            /* Disable TXE and ERR interrupt */
   3113            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \                     ??CrossCallReturnLabel_27: (+1)
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x684A             LDR      R2,[R1, #+4]
   \   00000014   0xF022 0x02A0      BIC      R2,R2,#0xA0
   \   00000018   0x604A             STR      R2,[R1, #+4]
   3114          
   3115            /* Check Busy flag */
   3116            if(SPI_CheckFlag_BSY(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \   0000001A   0x2164             MOVS     R1,#+100
   \   0000001C   0x4602             MOV      R2,R0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       SPI_CheckFlag_BSY
   \   00000024   0x.... 0x....      BL       ?Subroutine20
   3117            {
   3118              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   3119            }
   3120          
   3121            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3122            if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??CrossCallReturnLabel_36: (+1)
   \   00000028   0xB908             CBNZ.N   R0,??CrossCallReturnLabel_2
   3123            {
   3124              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \   0000002A   0x.... 0x....      BL       ?Subroutine7
   3125            }
   3126          
   3127            hspi->State = HAL_SPI_STATE_READY;
   \                     ??CrossCallReturnLabel_2: (+1)
   \   0000002E   0x.... 0x....      BL       ?Subroutine11
   3128            if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??CrossCallReturnLabel_13: (+1)
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xD000             BEQ.N    ??SPI_CloseTx_ISR_0
   3129            {
   3130              HAL_SPI_ErrorCallback(hspi);
   \   00000038   0x....             B.N      ?Subroutine6
   3131            }
   3132            else
   3133            {
   3134              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_CloseTx_ISR_0: (+1)
   \   0000003A   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   3135            }
   3136          }
   \   0000003E   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   3137          
   3138          /**
   3139            * @}
   3140            */
   3141          
   3142          /**
   3143            * @brief  Handle abort a Tx or Rx transaction.
   3144            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3145            *               the configuration information for SPI module.
   3146            * @retval None
   3147            */

   \                                 In section .text, align 4, keep-with-next
   3148          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
   3149          {
   \                     SPI_AbortRx_ISR: (+1)
   \   00000000   0xB082             SUB      SP,SP,#+8
   3150            __IO uint32_t tmpreg = 0U;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9101             STR      R1,[SP, #+4]
   3151            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \   00000006   0x2218             MOVS     R2,#+24
   \   00000008   0x....             LDR.N    R1,??DataTable3
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000010   0xF44F 0x727A      MOV      R2,#+1000
   \   00000014   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000018   0x2264             MOVS     R2,#+100
   \   0000001A   0x4351             MULS     R1,R2,R1
   \   0000001C   0x9100             STR      R1,[SP, #+0]
   3152          
   3153            /* Wait until TXE flag is set */
   3154            do
   3155            {
   3156              if(count-- == 0U)
   \                     ??SPI_AbortRx_ISR_0: (+1)
   \   0000001E   0x9900             LDR      R1,[SP, #+0]
   \   00000020   0x1E4A             SUBS     R2,R1,#+1
   \   00000022   0x9200             STR      R2,[SP, #+0]
   \   00000024   0xB921             CBNZ.N   R1,??SPI_AbortRx_ISR_1
   3157              {
   3158                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \   00000026   0x6D41             LDR      R1,[R0, #+84]
   \   00000028   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000002C   0x6541             STR      R1,[R0, #+84]
   3159                break;
   \   0000002E   0xE003             B.N      ??SPI_AbortRx_ISR_2
   3160              }
   3161            }
   3162            while((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \                     ??SPI_AbortRx_ISR_1: (+1)
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x6889             LDR      R1,[R1, #+8]
   \   00000034   0x0789             LSLS     R1,R1,#+30
   \   00000036   0xD5F2             BPL.N    ??SPI_AbortRx_ISR_0
   3163          
   3164            /* Disable SPI Peripheral */
   3165            __HAL_SPI_DISABLE(hspi);    
   \                     ??SPI_AbortRx_ISR_2: (+1)
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0xF022 0x0240      BIC      R2,R2,#0x40
   \   00000040   0x600A             STR      R2,[R1, #+0]
   3166          
   3167            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   3168            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x684A             LDR      R2,[R1, #+4]
   \   00000046   0xF022 0x02E0      BIC      R2,R2,#0xE0
   \   0000004A   0x604A             STR      R2,[R1, #+4]
   3169          
   3170            /* Flush DR Register */
   3171            tmpreg = (*(__IO uint32_t *)&hspi->Instance->DR);
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x68C0             LDR      R0,[R0, #+12]
   \   00000050   0x9001             STR      R0,[SP, #+4]
   3172          
   3173            /* To avoid GCC warning */
   3174            UNUSED(tmpreg);
   \   00000052   0x9801             LDR      R0,[SP, #+4]
   3175          }
   \   00000054   0xB002             ADD      SP,SP,#+8
   \   00000056   0x4770             BX       LR               ;; return
   3176          
   3177          /**
   3178            * @brief  Handle abort a Tx or Rx transaction.
   3179            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3180            *               the configuration information for SPI module.
   3181            * @retval None
   3182            */

   \                                 In section .text, align 4, keep-with-next
   3183          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
   3184          {
   3185            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   3186            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
   \                     SPI_AbortTx_ISR: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0xF021 0x01E0      BIC      R1,R1,#0xE0
   \   00000008   0x6041             STR      R1,[R0, #+4]
   3187          
   3188            /* Disable SPI Peripheral */
   3189            __HAL_SPI_DISABLE(hspi);
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000010   0x6001             STR      R1,[R0, #+0]
   3190          }
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     SystemCoreClock
   3191          /**
   3192            * @}
   3193            */
   3194          #endif /* HAL_SPI_MODULE_ENABLED */
   3195          
   3196          /**
   3197            * @}
   3198            */
   3199          
   3200          /**
   3201            * @}
   3202            */
   3203          
   3204          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_SPI_Abort
        16   -> HAL_DMA_Abort
       0   HAL_SPI_AbortCpltCallback
      16   HAL_SPI_Abort_IT
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_SPI_AbortCpltCallback
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
       8   HAL_SPI_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_SPI_DeInit
         8   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
      16   HAL_SPI_IRQHandler
         0   -- Indirect call
         0   -> HAL_DMA_Abort_IT
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_SPI_ErrorCallback
       8   HAL_SPI_Init
         8   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      32   HAL_SPI_Receive
        32   -> HAL_GetTick
        32   -> HAL_SPI_TransmitReceive
      16   HAL_SPI_Receive_DMA
        16   -> HAL_DMA_Start_IT
         0   -> HAL_SPI_TransmitReceive_DMA
      16   HAL_SPI_Receive_IT
         0   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      32   HAL_SPI_Transmit
        32   -> HAL_GetTick
        32   -> SPI_CheckFlag_BSY
        32   -> SPI_WaitFlagStateUntilTimeout
      40   HAL_SPI_TransmitReceive
        40   -> HAL_GetTick
        40   -> SPI_CheckFlag_BSY
        40   -> SPI_WaitFlagStateUntilTimeout
      16   HAL_SPI_TransmitReceive_DMA
        16   -> HAL_DMA_Start_IT
      16   HAL_SPI_TransmitReceive_IT
      16   HAL_SPI_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       8   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       0   SPI_2linesRxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesRxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_16BIT
         0   -> SPI_CloseRxTx_ISR
       0   SPI_2linesTxISR_8BIT
         0   -> SPI_CloseRxTx_ISR
       8   SPI_AbortRx_ISR
       0   SPI_AbortTx_ISR
      16   SPI_CheckFlag_BSY
        16   -> SPI_WaitFlagStateUntilTimeout
      16   SPI_CloseRxTx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_CheckFlag_BSY
       8   SPI_CloseRx_ISR
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
      16   SPI_CloseTx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> SPI_CheckFlag_BSY
       8   SPI_DMAAbortOnError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAError
         8   -> HAL_SPI_ErrorCallback
       8   SPI_DMAHalfReceiveCplt
         8   -> HAL_SPI_RxHalfCpltCallback
       8   SPI_DMAHalfTransmitCplt
         8   -> HAL_SPI_TxHalfCpltCallback
       8   SPI_DMAHalfTransmitReceiveCplt
         8   -> HAL_SPI_TxRxHalfCpltCallback
       8   SPI_DMAReceiveCplt
         8   -> HAL_SPI_ErrorCallback
         8   -> HAL_SPI_RxCpltCallback
       8   SPI_DMARxAbortCallback
         8   -> HAL_SPI_AbortCpltCallback
      16   SPI_DMATransmitCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxCpltCallback
        16   -> SPI_CheckFlag_BSY
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_CheckFlag_BSY
       8   SPI_DMATxAbortCallback
         8   -> HAL_SPI_AbortCpltCallback
       0   SPI_RxISR_16BIT
         0   -> SPI_CloseRx_ISR
       0   SPI_RxISR_8BIT
         0   -> SPI_CloseRx_ISR
       0   SPI_TxISR_16BIT
         0   -> SPI_CloseTx_ISR
       0   SPI_TxISR_8BIT
         0   -> SPI_CloseTx_ISR
      24   SPI_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
      10  ?Subroutine0
      10  ?Subroutine1
      30  ?Subroutine10
      10  ?Subroutine11
       4  ?Subroutine12
      10  ?Subroutine13
      12  ?Subroutine14
      12  ?Subroutine15
      10  ?Subroutine16
      28  ?Subroutine17
      10  ?Subroutine18
      10  ?Subroutine19
      12  ?Subroutine2
      14  ?Subroutine20
      14  ?Subroutine21
      14  ?Subroutine22
      22  ?Subroutine23
       8  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
      16  ?Subroutine7
      10  ?Subroutine8
      20  ?Subroutine9
     206  HAL_SPI_Abort
       2  HAL_SPI_AbortCpltCallback
     234  HAL_SPI_Abort_IT
      28  HAL_SPI_DMAPause
      26  HAL_SPI_DMAResume
      30  HAL_SPI_DMAStop
      46  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     240  HAL_SPI_IRQHandler
     122  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     304  HAL_SPI_Receive
     172  HAL_SPI_Receive_DMA
     166  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     338  HAL_SPI_Transmit
     438  HAL_SPI_TransmitReceive
     208  HAL_SPI_TransmitReceive_DMA
     158  HAL_SPI_TransmitReceive_IT
     154  HAL_SPI_Transmit_DMA
     148  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      46  SPI_2linesRxISR_16BIT
      44  SPI_2linesRxISR_8BIT
      46  SPI_2linesTxISR_16BIT
      44  SPI_2linesTxISR_8BIT
      88  SPI_AbortRx_ISR
      20  SPI_AbortTx_ISR
      32  SPI_CheckFlag_BSY
      82  SPI_CloseRxTx_ISR
      70  SPI_CloseRx_ISR
      64  SPI_CloseTx_ISR
      12  SPI_DMAAbortOnError
      24  SPI_DMAError
      10  SPI_DMAHalfReceiveCplt
      10  SPI_DMAHalfTransmitCplt
      10  SPI_DMAHalfTransmitReceiveCplt
      60  SPI_DMAReceiveCplt
      70  SPI_DMARxAbortCallback
      66  SPI_DMATransmitCplt
      68  SPI_DMATransmitReceiveCplt
      98  SPI_DMATxAbortCallback
      32  SPI_RxISR_16BIT
      30  SPI_RxISR_8BIT
      32  SPI_TxISR_16BIT
      30  SPI_TxISR_8BIT
     144  SPI_WaitFlagStateUntilTimeout

 
 4 588 bytes in section .text
 
 4 588 bytes of CODE memory

Errors: none
Warnings: none
