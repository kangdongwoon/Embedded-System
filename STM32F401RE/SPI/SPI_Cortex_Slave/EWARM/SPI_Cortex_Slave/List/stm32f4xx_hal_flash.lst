###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.3.6832/W32 for ARM        19/Mar/2020  00:44:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash.c
#    Command line =  
#        C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32F401xE -lC
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\
#        --diag_suppress Pa050 -o
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\ --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Inc\ -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:/CubeMX_Project/STM32Cube_FW_F4_V1.19.0/Drivers/CMSIS/Include\ -I
#        C:\CubeMX_Project\SPI_Cortex_Slave\Debug\Drivers\u8glib_arm_v1.18.1\src\
#        -I C:\CubeMX_Project\SPI_Cortex_Slave\EWARM/../Inc\ -Ohz -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/List\stm32f4xx_hal_flash.lst
#    Object file  =  
#        C:\CubeMX_Project\SPI_Cortex_Slave\EWARM\SPI_Cortex_Slave/Obj\stm32f4xx_hal_flash.o
#
###############################################################################

C:\CubeMX_Project\STM32Cube_FW_F4_V1.19.0\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions 
     10            *           + Peripheral Errors functions
     11            *         
     12            @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16                     
     17            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     18                 to the Flash memory. It implements the erase and program Flash memory operations 
     19                 and the read and write protection mechanisms.
     20                
     21            [..] The Flash memory interface accelerates code execution with a system of instruction
     22                 prefetch and cache lines. 
     23          
     24            [..] The FLASH main features are:
     25                (+) Flash memory read operations
     26                (+) Flash memory program/erase operations
     27                (+) Read / write protections
     28                (+) Prefetch on I-Code
     29                (+) 64 cache lines of 128 bits on I-Code
     30                (+) 8 cache lines of 128 bits on D-Code
     31                
     32                
     33                               ##### How to use this driver #####
     34            ==============================================================================
     35              [..]                             
     36                This driver provides functions and macros to configure and program the FLASH 
     37                memory of all STM32F4xx devices.
     38              
     39                (#) FLASH Memory IO Programming functions: 
     40                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and 
     41                          HAL_FLASH_Lock() functions
     42                     (++) Program functions: byte, half word, word and double word
     43                     (++) There Two modes of programming :
     44                      (+++) Polling mode using HAL_FLASH_Program() function
     45                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     46              
     47                (#) Interrupts and flags management functions : 
     48                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     49                     (++) Wait for last FLASH operation according to its status
     50                     (++) Get error flag status by calling HAL_SetErrorCode()          
     51          
     52              [..] 
     53                In addition to these functions, this driver includes a set of macros allowing
     54                to handle the following operations:
     55                 (+) Set the latency
     56                 (+) Enable/Disable the prefetch buffer
     57                 (+) Enable/Disable the Instruction cache and the Data cache
     58                 (+) Reset the Instruction cache and the Data cache
     59                 (+) Enable/Disable the FLASH interrupts
     60                 (+) Monitor the FLASH flags status
     61                    
     62            @endverbatim
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT(c) 2017 STMicroelectronics</center></h2>
     67            *
     68            * Redistribution and use in source and binary forms, with or without modification,
     69            * are permitted provided that the following conditions are met:
     70            *   1. Redistributions of source code must retain the above copyright notice,
     71            *      this list of conditions and the following disclaimer.
     72            *   2. Redistributions in binary form must reproduce the above copyright notice,
     73            *      this list of conditions and the following disclaimer in the documentation
     74            *      and/or other materials provided with the distribution.
     75            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     76            *      may be used to endorse or promote products derived from this software
     77            *      without specific prior written permission.
     78            *
     79            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     80            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     81            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     82            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     83            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     84            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     85            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     86            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     87            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     88            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     89            *
     90            ******************************************************************************
     91            */ 
     92          
     93          /* Includes ------------------------------------------------------------------*/
     94          #include "stm32f4xx_hal.h"
     95          
     96          /** @addtogroup STM32F4xx_HAL_Driver
     97            * @{
     98            */
     99          
    100          /** @defgroup FLASH FLASH
    101            * @brief FLASH HAL module driver
    102            * @{
    103            */
    104          
    105          #ifdef HAL_FLASH_MODULE_ENABLED
    106          
    107          /* Private typedef -----------------------------------------------------------*/
    108          /* Private define ------------------------------------------------------------*/
    109          /** @addtogroup FLASH_Private_Constants
    110            * @{
    111            */
    112          #define FLASH_TIMEOUT_VALUE       50000U /* 50 s */
    113          /**
    114            * @}
    115            */         
    116          /* Private macro -------------------------------------------------------------*/
    117          /* Private variables ---------------------------------------------------------*/
    118          /** @addtogroup FLASH_Private_Variables
    119            * @{
    120            */
    121          /* Variable used for Erase sectors under interruption */

   \                                 In section .bss, align 4
    122          FLASH_ProcessTypeDef pFlash;
   \                     pFlash:
   \   00000000                      DS8 32
    123          /**
    124            * @}
    125            */
    126          
    127          /* Private function prototypes -----------------------------------------------*/
    128          /** @addtogroup FLASH_Private_Functions
    129            * @{
    130            */
    131          /* Program operations */
    132          static void   FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);
    133          static void   FLASH_Program_Word(uint32_t Address, uint32_t Data);
    134          static void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    135          static void   FLASH_Program_Byte(uint32_t Address, uint8_t Data);
    136          static void   FLASH_SetErrorCode(void);
    137          
    138          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout);
    139          /**
    140            * @}
    141            */
    142          
    143          /* Exported functions --------------------------------------------------------*/
    144          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    145            * @{
    146            */
    147            
    148          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    149           *  @brief   Programming operation functions 
    150           *
    151          @verbatim   
    152           ===============================================================================
    153                            ##### Programming operation functions #####
    154           ===============================================================================  
    155              [..]
    156              This subsection provides a set of functions allowing to manage the FLASH 
    157              program operations.
    158          
    159          @endverbatim
    160            * @{
    161            */
    162          
    163          /**
    164            * @brief  Program byte, halfword, word or double word at a specified address
    165            * @param  TypeProgram  Indicate the way to program at a specified address.
    166            *                           This parameter can be a value of @ref FLASH_Type_Program
    167            * @param  Address  specifies the address to be programmed.
    168            * @param  Data specifies the data to be programmed
    169            * 
    170            * @retval HAL_StatusTypeDef HAL Status
    171            */

   \                                 In section .text, align 2, keep-with-next
    172          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    173          {
   \                     HAL_FLASH_Program: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
    174            HAL_StatusTypeDef status = HAL_ERROR;
    175            
    176            /* Process Locked */
    177            __HAL_LOCK(&pFlash);
   \   00000004   0x....             LDR.N    R6,??DataTable13
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x7E30             LDRB     R0,[R6, #+24]
   \   0000000A   0x4688             MOV      R8,R1
   \   0000000C   0x4614             MOV      R4,R2
   \   0000000E   0x461D             MOV      R5,R3
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xBF08             IT       EQ 
   \   00000014   0x2002             MOVEQ    R0,#+2
   \   00000016   0xD02A             BEQ.N    ??HAL_FLASH_Program_0
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x7630             STRB     R0,[R6, #+24]
    178            
    179            /* Check the parameters */
    180            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    181            
    182            /* Wait for last operation to be completed */
    183            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \   0000001C   0xF24C 0x3950      MOVW     R9,#+50000
   \   00000020   0x4648             MOV      R0,R9
   \   00000022   0x.... 0x....      BL       FLASH_WaitForLastOperation
    184            
    185            if(status == HAL_OK)
   \   00000026   0xBB00             CBNZ.N   R0,??HAL_FLASH_Program_1
    186            {
    187              if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
   \   00000028   0xB927             CBNZ.N   R7,??HAL_FLASH_Program_2
    188              {
    189                /*Program byte (8-bit) at a specified address.*/
    190                FLASH_Program_Byte(Address, (uint8_t) Data);
   \   0000002A   0xB2E1             UXTB     R1,R4
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x.... 0x....      BL       FLASH_Program_Byte
   \   00000032   0xE012             B.N      ??HAL_FLASH_Program_3
    191              }
    192              else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
   \                     ??HAL_FLASH_Program_2: (+1)
   \   00000034   0x2F01             CMP      R7,#+1
   \   00000036   0xD104             BNE.N    ??HAL_FLASH_Program_4
    193              {
    194                /*Program halfword (16-bit) at a specified address.*/
    195                FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \   00000038   0xB2A1             UXTH     R1,R4
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x.... 0x....      BL       FLASH_Program_HalfWord
   \   00000040   0xE00B             B.N      ??HAL_FLASH_Program_3
    196              }
    197              else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \                     ??HAL_FLASH_Program_4: (+1)
   \   00000042   0x2F02             CMP      R7,#+2
   \   00000044   0xD104             BNE.N    ??HAL_FLASH_Program_5
    198              {
    199                /*Program word (32-bit) at a specified address.*/
    200                FLASH_Program_Word(Address, (uint32_t) Data);
   \   00000046   0x4621             MOV      R1,R4
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0x.... 0x....      BL       FLASH_Program_Word
   \   0000004E   0xE004             B.N      ??HAL_FLASH_Program_3
    201              }
    202              else
    203              {
    204                /*Program double word (64-bit) at a specified address.*/
    205                FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_5: (+1)
   \   00000050   0x4622             MOV      R2,R4
   \   00000052   0x462B             MOV      R3,R5
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x.... 0x....      BL       FLASH_Program_DoubleWord
    206              }
    207              
    208              /* Wait for last operation to be completed */
    209              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASH_Program_3: (+1)
   \   0000005A   0x4648             MOV      R0,R9
   \   0000005C   0x.... 0x....      BL       FLASH_WaitForLastOperation
    210              
    211              /* If the program operation is completed, disable the PG Bit */
    212              FLASH->CR &= (~FLASH_CR_PG);  
   \   00000060   0x....             LDR.N    R1,??DataTable13_1  ;; 0x40023c10
   \   00000062   0x680A             LDR      R2,[R1, #+0]
   \   00000064   0x0852             LSRS     R2,R2,#+1
   \   00000066   0x0052             LSLS     R2,R2,#+1
   \   00000068   0x600A             STR      R2,[R1, #+0]
    213            }
    214            
    215            /* Process Unlocked */
    216            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_1: (+1)
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x7631             STRB     R1,[R6, #+24]
    217            
    218            return status;
   \                     ??HAL_FLASH_Program_0: (+1)
   \   0000006E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    219          }
    220          
    221          /**
    222            * @brief   Program byte, halfword, word or double word at a specified address  with interrupt enabled.
    223            * @param  TypeProgram  Indicate the way to program at a specified address.
    224            *                           This parameter can be a value of @ref FLASH_Type_Program
    225            * @param  Address  specifies the address to be programmed.
    226            * @param  Data specifies the data to be programmed
    227            * 
    228            * @retval HAL Status
    229            */

   \                                 In section .text, align 2, keep-with-next
    230          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    231          {
   \                     HAL_FLASH_Program_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4608             MOV      R0,R1
    232            HAL_StatusTypeDef status = HAL_OK;
    233            
    234            /* Process Locked */
    235            __HAL_LOCK(&pFlash);
   \   00000006   0x....             LDR.N    R1,??DataTable13
   \   00000008   0x7E0D             LDRB     R5,[R1, #+24]
   \   0000000A   0x2D01             CMP      R5,#+1
   \   0000000C   0xD101             BNE.N    ??HAL_FLASH_Program_IT_0
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \   00000012   0x2501             MOVS     R5,#+1
   \   00000014   0x760D             STRB     R5,[R1, #+24]
    236          
    237            /* Check the parameters */
    238            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    239          
    240            /* Enable End of FLASH Operation interrupt */
    241            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP);
   \   00000016   0x....             LDR.N    R5,??DataTable13_1  ;; 0x40023c10
   \   00000018   0x682E             LDR      R6,[R5, #+0]
   \   0000001A   0xF046 0x7680      ORR      R6,R6,#0x1000000
   \   0000001E   0x602E             STR      R6,[R5, #+0]
    242            
    243            /* Enable Error source interrupt */
    244            __HAL_FLASH_ENABLE_IT(FLASH_IT_ERR);
   \   00000020   0x682E             LDR      R6,[R5, #+0]
   \   00000022   0xF046 0x7600      ORR      R6,R6,#0x2000000
   \   00000026   0x602E             STR      R6,[R5, #+0]
    245          
    246            pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAM;
   \   00000028   0x2503             MOVS     R5,#+3
   \   0000002A   0x700D             STRB     R5,[R1, #+0]
    247            pFlash.Address = Address;
   \   0000002C   0x6148             STR      R0,[R1, #+20]
    248          
    249            if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
   \   0000002E   0xB91C             CBNZ.N   R4,??HAL_FLASH_Program_IT_1
    250            {
    251              /*Program byte (8-bit) at a specified address.*/
    252                FLASH_Program_Byte(Address, (uint8_t) Data);
   \   00000030   0xB2D1             UXTB     R1,R2
   \   00000032   0x.... 0x....      BL       FLASH_Program_Byte
   \   00000036   0xE00D             B.N      ??HAL_FLASH_Program_IT_2
    253            }
    254            else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \   00000038   0x2C01             CMP      R4,#+1
   \   0000003A   0xD103             BNE.N    ??HAL_FLASH_Program_IT_3
    255            {
    256              /*Program halfword (16-bit) at a specified address.*/
    257              FLASH_Program_HalfWord(Address, (uint16_t) Data);
   \   0000003C   0xB291             UXTH     R1,R2
   \   0000003E   0x.... 0x....      BL       FLASH_Program_HalfWord
   \   00000042   0xE007             B.N      ??HAL_FLASH_Program_IT_2
    258            }
    259            else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \   00000044   0x2C02             CMP      R4,#+2
   \   00000046   0xD103             BNE.N    ??HAL_FLASH_Program_IT_4
    260            {
    261              /*Program word (32-bit) at a specified address.*/
    262              FLASH_Program_Word(Address, (uint32_t) Data);
   \   00000048   0x4611             MOV      R1,R2
   \   0000004A   0x.... 0x....      BL       FLASH_Program_Word
   \   0000004E   0xE001             B.N      ??HAL_FLASH_Program_IT_2
    263            }
    264            else
    265            {
    266              /*Program double word (64-bit) at a specified address.*/
    267              FLASH_Program_DoubleWord(Address, Data);
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \   00000050   0x.... 0x....      BL       FLASH_Program_DoubleWord
    268            }
    269          
    270            return status;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    271          }
    272          
    273          /**
    274            * @brief This function handles FLASH interrupt request.
    275            * @retval None
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          void HAL_FLASH_IRQHandler(void)
    278          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    279            uint32_t addresstmp = 0U;
    280            
    281            /* Check FLASH operation error flags */
    282          #if defined(FLASH_SR_RDERR) 
    283            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    284              FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR | FLASH_FLAG_RDERR)) != RESET)
   \   00000002   0x....             LDR.N    R5,??DataTable13_2  ;; 0x40023c0c
   \   00000004   0x....             LDR.N    R4,??DataTable13
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0xF04F 0x36FF      MOV      R6,#-1
   \   0000000C   0xF410 0x7FF9      TST      R0,#0x1F2
   \   00000010   0xD011             BEQ.N    ??HAL_FLASH_IRQHandler_0
    285          #else
    286            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    287              FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
    288          #endif /* FLASH_SR_RDERR */
    289            {
    290              if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD102             BNE.N    ??HAL_FLASH_IRQHandler_1
    291              {
    292                /*return the faulty sector*/
    293                addresstmp = pFlash.Sector;
   \   00000018   0x68E7             LDR      R7,[R4, #+12]
    294                pFlash.Sector = 0xFFFFFFFFU;
   \   0000001A   0x60E6             STR      R6,[R4, #+12]
   \   0000001C   0xE004             B.N      ??HAL_FLASH_IRQHandler_2
    295              }
    296              else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \   0000001E   0x7820             LDRB     R0,[R4, #+0]
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xBF0C             ITE      EQ 
    297              {
    298                /*return the faulty bank*/
    299                addresstmp = pFlash.Bank;
   \   00000024   0x6927             LDREQ    R7,[R4, #+16]
    300              }
    301              else
    302              {
    303                /*return the faulty address*/
    304                addresstmp = pFlash.Address;
   \   00000026   0x6967             LDRNE    R7,[R4, #+20]
    305              }
    306              
    307              /*Save the Error code*/
    308              FLASH_SetErrorCode();
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \   00000028   0x.... 0x....      BL       FLASH_SetErrorCode
    309              
    310              /* FLASH error interrupt user callback */
    311              HAL_FLASH_OperationErrorCallback(addresstmp);
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0x.... 0x....      BL       HAL_FLASH_OperationErrorCallback
    312              
    313              /*Stop the procedure ongoing*/
    314              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7020             STRB     R0,[R4, #+0]
    315            }
    316            
    317            /* Check FLASH End of Operation flag  */
    318            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \   00000036   0x6828             LDR      R0,[R5, #+0]
   \   00000038   0x07C0             LSLS     R0,R0,#+31
   \   0000003A   0xD528             BPL.N    ??HAL_FLASH_IRQHandler_3
    319            {
    320              /* Clear FLASH End of Operation pending bit */
    321              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x6028             STR      R0,[R5, #+0]
    322              
    323              if(pFlash.ProcedureOnGoing == FLASH_PROC_SECTERASE)
   \   00000040   0x7820             LDRB     R0,[R4, #+0]
   \   00000042   0x2801             CMP      R0,#+1
   \   00000044   0xD117             BNE.N    ??HAL_FLASH_IRQHandler_4
    324              {
    325                /*Nb of sector to erased can be decreased*/
    326                pFlash.NbSectorsToErase--;
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x1E40             SUBS     R0,R0,#+1
   \   0000004A   0x6060             STR      R0,[R4, #+4]
    327                
    328                /* Check if there are still sectors to erase*/
    329                if(pFlash.NbSectorsToErase != 0U)
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0xB150             CBZ.N    R0,??HAL_FLASH_IRQHandler_5
    330                {
    331                  addresstmp = pFlash.Sector;
   \   00000050   0x68E0             LDR      R0,[R4, #+12]
    332                  /*Indicate user which sector has been erased*/
    333                  HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   00000052   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    334                  
    335                  /*Increment sector number*/
    336                  pFlash.Sector++;
   \   00000056   0x68E0             LDR      R0,[R4, #+12]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x60E0             STR      R0,[R4, #+12]
    337                  addresstmp = pFlash.Sector;
   \   0000005C   0x68E0             LDR      R0,[R4, #+12]
    338                  FLASH_Erase_Sector(addresstmp, pFlash.VoltageForErase);
   \   0000005E   0x7A21             LDRB     R1,[R4, #+8]
   \   00000060   0x.... 0x....      BL       FLASH_Erase_Sector
   \   00000064   0xE013             B.N      ??HAL_FLASH_IRQHandler_3
    339                }
    340                else
    341                {
    342                  /*No more sectors to Erase, user callback can be called.*/
    343                  /*Reset Sector and stop Erase sectors procedure*/
    344                  pFlash.Sector = addresstmp = 0xFFFFFFFFU;
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \   00000066   0x60E6             STR      R6,[R4, #+12]
    345                  pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   00000068   0x7020             STRB     R0,[R4, #+0]
    346                  
    347                  /* Flush the caches to be sure of the data consistency */
    348                  FLASH_FlushCaches() ;
   \   0000006A   0x.... 0x....      BL       FLASH_FlushCaches
    349                          
    350                  /* FLASH EOP interrupt user callback */
    351                  HAL_FLASH_EndOfOperationCallback(addresstmp);
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
   \   00000074   0xE00B             B.N      ??HAL_FLASH_IRQHandler_3
    352                }
    353              }
    354              else 
    355              {
    356                if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE) 
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \   00000076   0x7820             LDRB     R0,[R4, #+0]
   \   00000078   0x2802             CMP      R0,#+2
   \   0000007A   0xD103             BNE.N    ??HAL_FLASH_IRQHandler_6
    357                {
    358                  /* MassErase ended. Return the selected bank */
    359                  /* Flush the caches to be sure of the data consistency */
    360                  FLASH_FlushCaches() ;
   \   0000007C   0x.... 0x....      BL       FLASH_FlushCaches
    361          
    362                  /* FLASH EOP interrupt user callback */
    363                  HAL_FLASH_EndOfOperationCallback(pFlash.Bank);
   \   00000080   0x6920             LDR      R0,[R4, #+16]
   \   00000082   0xE000             B.N      ??HAL_FLASH_IRQHandler_7
    364                }
    365                else
    366                {
    367                  /*Program ended. Return the selected address*/
    368                  /* FLASH EOP interrupt user callback */
    369                  HAL_FLASH_EndOfOperationCallback(pFlash.Address);
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \   00000084   0x6960             LDR      R0,[R4, #+20]
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \   00000086   0x.... 0x....      BL       HAL_FLASH_EndOfOperationCallback
    370                }
    371                pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x7020             STRB     R0,[R4, #+0]
    372              }
    373            }
    374            
    375            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \   0000008E   0x7820             LDRB     R0,[R4, #+0]
   \   00000090   0xB968             CBNZ.N   R0,??HAL_FLASH_IRQHandler_8
    376            {
    377              /* Operation is completed, disable the PG, SER, SNB and MER Bits */
    378              CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_SER | FLASH_CR_SNB | FLASH_MER_BIT));
   \   00000092   0x6868             LDR      R0,[R5, #+4]
   \   00000094   0x0A00             LSRS     R0,R0,#+8
   \   00000096   0x0200             LSLS     R0,R0,#+8
   \   00000098   0x6068             STR      R0,[R5, #+4]
    379          
    380              /* Disable End of FLASH Operation interrupt */
    381              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP);
   \   0000009A   0x6868             LDR      R0,[R5, #+4]
   \   0000009C   0xF020 0x7080      BIC      R0,R0,#0x1000000
   \   000000A0   0x6068             STR      R0,[R5, #+4]
    382              
    383              /* Disable Error source interrupt */
    384              __HAL_FLASH_DISABLE_IT(FLASH_IT_ERR);
   \   000000A2   0x6868             LDR      R0,[R5, #+4]
   \   000000A4   0xF020 0x7000      BIC      R0,R0,#0x2000000
   \   000000A8   0x6068             STR      R0,[R5, #+4]
    385              
    386              /* Process Unlocked */
    387              __HAL_UNLOCK(&pFlash);
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x7620             STRB     R0,[R4, #+24]
    388            }
    389          }
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \   000000AE   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    390          
    391          /**
    392            * @brief  FLASH end of operation interrupt callback
    393            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    394            *                  Mass Erase: Bank number which has been requested to erase
    395            *                  Sectors Erase: Sector which has been erased 
    396            *                    (if 0xFFFFFFFFU, it means that all the selected sectors have been erased)
    397            *                  Program: Address which was selected for data program
    398            * @retval None
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    401          {
    402            /* Prevent unused argument(s) compilation warning */
    403            UNUSED(ReturnValue);
    404            /* NOTE : This function Should not be modified, when the callback is needed,
    405                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    406             */ 
    407          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    408          
    409          /**
    410            * @brief  FLASH operation error interrupt callback
    411            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    412            *                 Mass Erase: Bank number which has been requested to erase
    413            *                 Sectors Erase: Sector number which returned an error
    414            *                 Program: Address which was selected for data program
    415            * @retval None
    416            */

   \                                 In section .text, align 2, keep-with-next
    417          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    418          {
    419            /* Prevent unused argument(s) compilation warning */
    420            UNUSED(ReturnValue);
    421            /* NOTE : This function Should not be modified, when the callback is needed,
    422                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    423             */ 
    424          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    425          
    426          /**
    427            * @}
    428            */
    429          
    430          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    431           *  @brief   management functions 
    432           *
    433          @verbatim   
    434           ===============================================================================
    435                                ##### Peripheral Control functions #####
    436           ===============================================================================  
    437              [..]
    438              This subsection provides a set of functions allowing to control the FLASH 
    439              memory operations.
    440          
    441          @endverbatim
    442            * @{
    443            */
    444          
    445          /**
    446            * @brief  Unlock the FLASH control register access
    447            * @retval HAL Status
    448            */

   \                                 In section .text, align 2, keep-with-next
    449          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    450          {
    451            HAL_StatusTypeDef status = HAL_OK;
    452          
    453            if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
   \                     HAL_FLASH_Unlock: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13_3  ;; 0x40023c04
   \   00000002   0x68CA             LDR      R2,[R1, #+12]
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD507             BPL.N    ??HAL_FLASH_Unlock_0
    454            {
    455              /* Authorize the FLASH Registers access */
    456              WRITE_REG(FLASH->KEYR, FLASH_KEY1);
   \   0000000A   0x....             LDR.N    R2,??DataTable13_4  ;; 0x45670123
   \   0000000C   0x600A             STR      R2,[R1, #+0]
    457              WRITE_REG(FLASH->KEYR, FLASH_KEY2);
   \   0000000E   0x....             LDR.N    R2,??DataTable13_5  ;; 0xcdef89ab
   \   00000010   0x600A             STR      R2,[R1, #+0]
    458          
    459              /* Verify Flash is unlocked */
    460              if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xBF48             IT       MI 
    461              {
    462                status = HAL_ERROR;
   \   00000018   0x2001             MOVMI    R0,#+1
    463              }
    464            }
    465          
    466            return status;
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    467          }
    468          
    469          /**
    470            * @brief  Locks the FLASH control register access
    471            * @retval HAL Status
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    474          {
    475            /* Set the LOCK Bit to lock the FLASH Registers access */
    476            FLASH->CR |= FLASH_CR_LOCK;
   \                     HAL_FLASH_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40023c10
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000008                      REQUIRE ?Subroutine0
   \   00000008                      ;; // Fall through to label ?Subroutine0
    477            
    478            return HAL_OK;  
    479          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    480          
    481          /**
    482            * @brief  Unlock the FLASH Option Control Registers access.
    483            * @retval HAL Status
    484            */

   \                                 In section .text, align 2, keep-with-next
    485          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    486          {
    487            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     HAL_FLASH_OB_Unlock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_6  ;; 0x40023c08
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x07C9             LSLS     R1,R1,#+31
   \   00000006   0xD503             BPL.N    ??HAL_FLASH_OB_Unlock_0
    488            {
    489              /* Authorizes the Option Byte register programming */
    490              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   00000008   0x....             LDR.N    R1,??DataTable13_7  ;; 0x8192a3b
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    491              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   0000000C   0x....             LDR.N    R1,??DataTable13_8  ;; 0x4c5d6e7f
   \   0000000E   0x....             B.N      ?Subroutine0
    492            }
    493            else
    494            {
    495              return HAL_ERROR;
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
    496            }  
    497            
    498            return HAL_OK;  
    499          }
    500          
    501          /**
    502            * @brief  Lock the FLASH Option Control Registers access.
    503            * @retval HAL Status 
    504            */

   \                                 In section .text, align 2, keep-with-next
    505          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    506          {
    507            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    508            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     HAL_FLASH_OB_Lock: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_9  ;; 0x40023c14
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000008   0x....             B.N      ?Subroutine0
    509            
    510            return HAL_OK;  
    511          }
    512          
    513          /**
    514            * @brief  Launch the option byte loading.
    515            * @retval HAL Status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    518          {
    519            /* Set the OPTSTRT bit in OPTCR register */
    520            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \                     HAL_FLASH_OB_Launch: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13_9  ;; 0x40023c14
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x7001             STRB     R1,[R0, #+0]
    521          
    522            /* Wait for last operation to be completed */
    523            return(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE)); 
   \   0000000A   0xF24C 0x3050      MOVW     R0,#+50000
   \   0000000E   0x....             B.N      FLASH_WaitForLastOperation
    524          }
    525          
    526          /**
    527            * @}
    528            */
    529          
    530          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions 
    531           *  @brief   Peripheral Errors functions 
    532           *
    533          @verbatim   
    534           ===============================================================================
    535                          ##### Peripheral Errors functions #####
    536           ===============================================================================  
    537              [..]
    538              This subsection permits to get in run-time Errors of the FLASH peripheral.
    539          
    540          @endverbatim
    541            * @{
    542            */
    543          
    544          /**
    545            * @brief  Get the specific FLASH error flag.
    546            * @retval FLASH_ErrorCode: The returned value can be a combination of:
    547            *            @arg HAL_FLASH_ERROR_RD: FLASH Read Protection error flag (PCROP)
    548            *            @arg HAL_FLASH_ERROR_PGS: FLASH Programming Sequence error flag 
    549            *            @arg HAL_FLASH_ERROR_PGP: FLASH Programming Parallelism error flag  
    550            *            @arg HAL_FLASH_ERROR_PGA: FLASH Programming Alignment error flag
    551            *            @arg HAL_FLASH_ERROR_WRP: FLASH Write protected error flag
    552            *            @arg HAL_FLASH_ERROR_OPERATION: FLASH operation Error flag 
    553            */

   \                                 In section .text, align 2, keep-with-next
    554          uint32_t HAL_FLASH_GetError(void)
    555          { 
    556             return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable13
   \   00000002   0x69C0             LDR      R0,[R0, #+28]
   \   00000004   0x4770             BX       LR               ;; return
    557          }  
    558            
    559          /**
    560            * @}
    561            */    
    562          
    563          /**
    564            * @brief  Wait for a FLASH operation to complete.
    565            * @param  Timeout maximum flash operationtimeout
    566            * @retval HAL Status
    567            */

   \                                 In section .text, align 2, keep-with-next
    568          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    569          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    570            uint32_t tickstart = 0U;
    571            
    572            /* Clear Error Code */
    573            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \   00000004   0x....             LDR.N    R1,??DataTable13
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x61C8             STR      R0,[R1, #+28]
    574            
    575            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    576               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    577               flag will be set */
    578            /* Get tick */
    579            tickstart = HAL_GetTick();
   \   0000000A   0x.... 0x....      BL       HAL_GetTick
   \   0000000E   0x4606             MOV      R6,R0
   \   00000010   0x....             LDR.N    R4,??DataTable13_2  ;; 0x40023c0c
    580          
    581            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x03C0             LSLS     R0,R0,#+15
   \   00000016   0xD50A             BPL.N    ??FLASH_WaitForLastOperation_1
    582            { 
    583              if(Timeout != HAL_MAX_DELAY)
   \   00000018   0xF115 0x0F01      CMN      R5,#+1
   \   0000001C   0xD0F9             BEQ.N    ??FLASH_WaitForLastOperation_0
    584              {
    585                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000001E   0xB125             CBZ.N    R5,??FLASH_WaitForLastOperation_2
   \   00000020   0x.... 0x....      BL       HAL_GetTick
   \   00000024   0x1B80             SUBS     R0,R0,R6
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD2F3             BCS.N    ??FLASH_WaitForLastOperation_0
    586                {
    587                  return HAL_TIMEOUT;
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xBD70             POP      {R4-R6,PC}
    588                }
    589              } 
    590            }
    591          
    592            /* Check FLASH End of Operation flag  */
    593            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x07C0             LSLS     R0,R0,#+31
   \   00000032   0xBF44             ITT      MI 
    594            {
    595              /* Clear FLASH End of Operation pending bit */
    596              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \   00000034   0x2001             MOVMI    R0,#+1
   \   00000036   0x6020             STRMI    R0,[R4, #+0]
    597            }
    598          #if defined(FLASH_SR_RDERR)  
    599            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    600                                     FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR | FLASH_FLAG_RDERR)) != RESET)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0xF410 0x7FF9      TST      R0,#0x1F2
   \   0000003E   0xD003             BEQ.N    ??FLASH_WaitForLastOperation_3
    601          #else
    602            if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
    603                                     FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
    604          #endif /* FLASH_SR_RDERR */
    605            {
    606              /*Save the error code*/
    607              FLASH_SetErrorCode();
   \   00000040   0x.... 0x....      BL       FLASH_SetErrorCode
    608              return HAL_ERROR;
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xBD70             POP      {R4-R6,PC}
    609            }
    610          
    611            /* If there is no error flag set */
    612            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
    613            
    614          }  
    615          
    616          /**
    617            * @brief  Program a double word (64-bit) at a specified address.
    618            * @note   This function must be used when the device voltage range is from
    619            *         2.7V to 3.6V and Vpp in the range 7V to 9V.
    620            *
    621            * @note   If an erase and a program operations are requested simultaneously,    
    622            *         the erase operation is performed before the program one.
    623            *  
    624            * @param  Address specifies the address to be programmed.
    625            * @param  Data specifies the data to be programmed.
    626            * @retval None
    627            */

   \                                 In section .text, align 2, keep-with-next
    628          static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
    629          {
   \                     FLASH_Program_DoubleWord: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    630            /* Check the parameters */
    631            assert_param(IS_FLASH_ADDRESS(Address));
    632            
    633            /* If the previous operation is completed, proceed to program the new data */
    634            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \   00000002   0x....             LDR.N    R1,??DataTable13_1  ;; 0x40023c10
   \   00000004   0x680C             LDR      R4,[R1, #+0]
   \   00000006   0xF424 0x7440      BIC      R4,R4,#0x300
   \   0000000A   0x600C             STR      R4,[R1, #+0]
    635            FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   0000000C   0x680C             LDR      R4,[R1, #+0]
   \   0000000E   0xF444 0x7440      ORR      R4,R4,#0x300
   \   00000012   0x600C             STR      R4,[R1, #+0]
    636            FLASH->CR |= FLASH_CR_PG;
   \   00000014   0x680C             LDR      R4,[R1, #+0]
   \   00000016   0xF044 0x0401      ORR      R4,R4,#0x1
   \   0000001A   0x600C             STR      R4,[R1, #+0]
    637          
    638            /* Program the double-word */
    639            *(__IO uint32_t*)Address = (uint32_t)Data;
   \   0000001C   0x6002             STR      R2,[R0, #+0]
    640            *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
   \   0000001E   0x6043             STR      R3,[R0, #+4]
    641          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    642          
    643          
    644          /**
    645            * @brief  Program word (32-bit) at a specified address.
    646            * @note   This function must be used when the device voltage range is from
    647            *         2.7V to 3.6V.
    648            *
    649            * @note   If an erase and a program operations are requested simultaneously,    
    650            *         the erase operation is performed before the program one.
    651            *  
    652            * @param  Address specifies the address to be programmed.
    653            * @param  Data specifies the data to be programmed.
    654            * @retval None
    655            */

   \                                 In section .text, align 2, keep-with-next
    656          static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
    657          {
    658            /* Check the parameters */
    659            assert_param(IS_FLASH_ADDRESS(Address));
    660            
    661            /* If the previous operation is completed, proceed to program the new data */
    662            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \                     FLASH_Program_Word: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable13_1  ;; 0x40023c10
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000008   0x6013             STR      R3,[R2, #+0]
    663            FLASH->CR |= FLASH_PSIZE_WORD;
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
   \   0000000C   0xF443 0x7300      ORR      R3,R3,#0x200
   \   00000010   0x6013             STR      R3,[R2, #+0]
    664            FLASH->CR |= FLASH_CR_PG;
   \   00000012   0x6813             LDR      R3,[R2, #+0]
   \   00000014   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000018   0x6013             STR      R3,[R2, #+0]
    665          
    666            *(__IO uint32_t*)Address = Data;
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    667          }
   \   0000001C   0x4770             BX       LR               ;; return
    668          
    669          /**
    670            * @brief  Program a half-word (16-bit) at a specified address.
    671            * @note   This function must be used when the device voltage range is from
    672            *         2.1V to 3.6V.
    673            *
    674            * @note   If an erase and a program operations are requested simultaneously,    
    675            *         the erase operation is performed before the program one.
    676            *  
    677            * @param  Address specifies the address to be programmed.
    678            * @param  Data specifies the data to be programmed.
    679            * @retval None
    680            */

   \                                 In section .text, align 2, keep-with-next
    681          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    682          {
    683            /* Check the parameters */
    684            assert_param(IS_FLASH_ADDRESS(Address));
    685            
    686            /* If the previous operation is completed, proceed to program the new data */
    687            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \                     FLASH_Program_HalfWord: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable13_1  ;; 0x40023c10
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000008   0x6013             STR      R3,[R2, #+0]
    688            FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
   \   0000000C   0xF443 0x7380      ORR      R3,R3,#0x100
   \   00000010   0x6013             STR      R3,[R2, #+0]
    689            FLASH->CR |= FLASH_CR_PG;
   \   00000012   0x6813             LDR      R3,[R2, #+0]
   \   00000014   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000018   0x6013             STR      R3,[R2, #+0]
    690          
    691            *(__IO uint16_t*)Address = Data;
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    692          }
   \   0000001C   0x4770             BX       LR               ;; return
    693          
    694          /**
    695            * @brief  Program byte (8-bit) at a specified address.
    696            * @note   This function must be used when the device voltage range is from
    697            *         1.8V to 3.6V.
    698            *
    699            * @note   If an erase and a program operations are requested simultaneously,    
    700            *         the erase operation is performed before the program one.
    701            *  
    702            * @param  Address specifies the address to be programmed.
    703            * @param  Data specifies the data to be programmed.
    704            * @retval None
    705            */

   \                                 In section .text, align 2, keep-with-next
    706          static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
    707          {
    708            /* Check the parameters */
    709            assert_param(IS_FLASH_ADDRESS(Address));
    710            
    711            /* If the previous operation is completed, proceed to program the new data */
    712            CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
   \                     FLASH_Program_Byte: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable13_1  ;; 0x40023c10
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0xF423 0x7340      BIC      R3,R3,#0x300
   \   00000008   0x6013             STR      R3,[R2, #+0]
    713            FLASH->CR |= FLASH_PSIZE_BYTE;
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
   \   0000000C   0x6013             STR      R3,[R2, #+0]
    714            FLASH->CR |= FLASH_CR_PG;
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0xF043 0x0301      ORR      R3,R3,#0x1
   \   00000014   0x6013             STR      R3,[R2, #+0]
    715          
    716            *(__IO uint8_t*)Address = Data;
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    717          }
   \   00000018   0x4770             BX       LR               ;; return
    718          
    719          /**
    720            * @brief  Set the specific FLASH error flag.
    721            * @retval None
    722            */

   \                                 In section .text, align 2, keep-with-next
    723          static void FLASH_SetErrorCode(void)
    724          { 
    725            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
   \                     FLASH_SetErrorCode: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable13_2  ;; 0x40023c0c
   \   00000002   0x....             LDR.N    R0,??DataTable13
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x06D2             LSLS     R2,R2,#+27
   \   00000008   0xD505             BPL.N    ??FLASH_SetErrorCode_0
    726            {
    727             pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
   \   0000000A   0x69C2             LDR      R2,[R0, #+28]
   \   0000000C   0xF042 0x0210      ORR      R2,R2,#0x10
   \   00000010   0x61C2             STR      R2,[R0, #+28]
    728             
    729             /* Clear FLASH write protection error pending bit */
    730             __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
   \   00000012   0x2210             MOVS     R2,#+16
   \   00000014   0x600A             STR      R2,[R1, #+0]
    731            }
    732            
    733            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
   \                     ??FLASH_SetErrorCode_0: (+1)
   \   00000016   0x680A             LDR      R2,[R1, #+0]
   \   00000018   0x0692             LSLS     R2,R2,#+26
   \   0000001A   0xD505             BPL.N    ??FLASH_SetErrorCode_1
    734            {
    735             pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
   \   0000001C   0x69C2             LDR      R2,[R0, #+28]
   \   0000001E   0xF042 0x0208      ORR      R2,R2,#0x8
   \   00000022   0x61C2             STR      R2,[R0, #+28]
    736             
    737             /* Clear FLASH Programming alignment error pending bit */
    738             __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
   \   00000024   0x2220             MOVS     R2,#+32
   \   00000026   0x600A             STR      R2,[R1, #+0]
    739            }
    740            
    741            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
   \                     ??FLASH_SetErrorCode_1: (+1)
   \   00000028   0x680A             LDR      R2,[R1, #+0]
   \   0000002A   0x0652             LSLS     R2,R2,#+25
   \   0000002C   0xD505             BPL.N    ??FLASH_SetErrorCode_2
    742            {
    743              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
   \   0000002E   0x69C2             LDR      R2,[R0, #+28]
   \   00000030   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000034   0x61C2             STR      R2,[R0, #+28]
    744              
    745              /* Clear FLASH Programming parallelism error pending bit */
    746              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
   \   00000036   0x2240             MOVS     R2,#+64
   \   00000038   0x600A             STR      R2,[R1, #+0]
    747            }
    748            
    749            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
   \                     ??FLASH_SetErrorCode_2: (+1)
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x0612             LSLS     R2,R2,#+24
   \   0000003E   0xD505             BPL.N    ??FLASH_SetErrorCode_3
    750            {
    751              pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
   \   00000040   0x69C2             LDR      R2,[R0, #+28]
   \   00000042   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000046   0x61C2             STR      R2,[R0, #+28]
    752              
    753              /* Clear FLASH Programming sequence error pending bit */
    754              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
   \   00000048   0x2280             MOVS     R2,#+128
   \   0000004A   0x600A             STR      R2,[R1, #+0]
    755            }
    756          #if defined(FLASH_SR_RDERR) 
    757            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
   \                     ??FLASH_SetErrorCode_3: (+1)
   \   0000004C   0x680A             LDR      R2,[R1, #+0]
   \   0000004E   0x05D2             LSLS     R2,R2,#+23
   \   00000050   0xD506             BPL.N    ??FLASH_SetErrorCode_4
    758            {
    759              pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
   \   00000052   0x69C2             LDR      R2,[R0, #+28]
   \   00000054   0xF042 0x0201      ORR      R2,R2,#0x1
   \   00000058   0x61C2             STR      R2,[R0, #+28]
    760              
    761              /* Clear FLASH Proprietary readout protection error pending bit */
    762              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
   \   0000005A   0xF44F 0x7280      MOV      R2,#+256
   \   0000005E   0x600A             STR      R2,[R1, #+0]
    763            }
    764          #endif /* FLASH_SR_RDERR */  
    765            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
   \                     ??FLASH_SetErrorCode_4: (+1)
   \   00000060   0x680A             LDR      R2,[R1, #+0]
   \   00000062   0x0792             LSLS     R2,R2,#+30
   \   00000064   0xD505             BPL.N    ??FLASH_SetErrorCode_5
    766            {
    767              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
   \   00000066   0x69C2             LDR      R2,[R0, #+28]
   \   00000068   0xF042 0x0220      ORR      R2,R2,#0x20
   \   0000006C   0x61C2             STR      R2,[R0, #+28]
    768              
    769              /* Clear FLASH Operation error pending bit */
    770              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
   \   0000006E   0x2002             MOVS     R0,#+2
   \   00000070   0x6008             STR      R0,[R1, #+0]
    771            }
    772          }
   \                     ??FLASH_SetErrorCode_5: (+1)
   \   00000072   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x40023C14         DC32     0x40023c14
    773          
    774          /**
    775            * @}
    776            */
    777          
    778          #endif /* HAL_FLASH_MODULE_ENABLED */
    779          
    780          /**
    781            * @}
    782            */
    783          
    784          /**
    785            * @}
    786            */
    787          
    788          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_Program_Byte
       8   FLASH_Program_DoubleWord
       0   FLASH_Program_HalfWord
       0   FLASH_Program_Word
       0   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      24   HAL_FLASH_IRQHandler
        24   -> FLASH_Erase_Sector
        24   -> FLASH_FlushCaches
        24   -> FLASH_SetErrorCode
        24   -> HAL_FLASH_EndOfOperationCallback
        24   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       0   HAL_FLASH_OB_Launch
         0   -> FLASH_WaitForLastOperation
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      32   HAL_FLASH_Program
        32   -> FLASH_Program_Byte
        32   -> FLASH_Program_DoubleWord
        32   -> FLASH_Program_HalfWord
        32   -> FLASH_Program_Word
        32   -> FLASH_WaitForLastOperation
      16   HAL_FLASH_Program_IT
        16   -> FLASH_Program_Byte
        16   -> FLASH_Program_DoubleWord
        16   -> FLASH_Program_HalfWord
        16   -> FLASH_Program_Word
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       6  ?Subroutine0
      26  FLASH_Program_Byte
      34  FLASH_Program_DoubleWord
      30  FLASH_Program_HalfWord
      30  FLASH_Program_Word
     116  FLASH_SetErrorCode
      76  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     176  HAL_FLASH_IRQHandler
       8  HAL_FLASH_Lock
      16  HAL_FLASH_OB_Launch
      10  HAL_FLASH_OB_Lock
      20  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     114  HAL_FLASH_Program
      88  HAL_FLASH_Program_IT
      28  HAL_FLASH_Unlock
      32  pFlash

 
  32 bytes in section .bss
 828 bytes in section .text
 
 828 bytes of CODE memory
  32 bytes of DATA memory

Errors: none
Warnings: none
